{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/pure/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f5a0ac5c3a2ce0f30b00f27160a3967b7f947baf","modified":1574863636551},{"_id":"source/CNAME","hash":"a85c94de837d0896258389b43e7931bbb254d860","modified":1574761600243},{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1574697465471},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1574697465472},{"_id":"themes/pure/README.cn.md","hash":"a634af4addbb57088935e060e8ec6035ea7bab76","modified":1574697465472},{"_id":"themes/pure/_config.yml","hash":"dba8fd29389d68981a7a673f876e78177b03b0e1","modified":1575190810062},{"_id":"themes/pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1574697465472},{"_id":"themes/pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1574697465472},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1574697465484},{"_id":"source/_posts/.DS_Store","hash":"e21f316fe3ec6ab54e00bb699830835a1bcffe6a","modified":1574856165726},{"_id":"source/_posts/how-to-write-excellent-dockerfile.md","hash":"06b9468e501815896dbfda4de855c6390f36da9e","modified":1575190882505},{"_id":"source/_posts/gitlab-data-migrate-and-upgrade.md","hash":"3b46cb44803d99f0830cb06272d6ea36cf5c4bd2","modified":1574922273601},{"_id":"source/_posts/http-status-code.md","hash":"ab169bec63397b7a4a729bbf757a944adcab00d8","modified":1574943381227},{"_id":"source/_posts/serial-port-debug-env-automation.md","hash":"43c4a7dc2124532fbaadc22ef62a7cd57054a969","modified":1574856997459},{"_id":"source/_posts/the-art-of-command-line.md","hash":"8a09aa9d2c7bfbba4a4eceb7750e99f081e8aa93","modified":1574910166525},{"_id":"source/_drafts/build-perfect-terminal-env.md","hash":"6de39500ef643b65a2059a87dba1327c53cf506a","modified":1574913048021},{"_id":"source/_drafts/how-to-write-tech-blog.md","hash":"2eaea62ede2da077abb36584e76017a0c7d9c82d","modified":1574866830514},{"_id":"source/_drafts/gitlab-runer-configuration.md","hash":"e88503ba658d0ba8cff912804b7770b6f1b604ec","modified":1574859974562},{"_id":"source/_drafts/hexo-config.md","hash":"6b065961e7ff5480ec190da2f6bc69552eb2f452","modified":1574856954260},{"_id":"source/_drafts/mirrors-of-china.md","hash":"e95982223ea2a25c2bff8d21b6863fdf8a24d1e6","modified":1575007237833},{"_id":"source/_drafts/postgres-tutorial-summary.md","hash":"47223b81c09c8f3661e41b7c200070116064d3c1","modified":1574996150117},{"_id":"source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1574861429893},{"_id":"source/_drafts/sql-basic-query-collection.md","hash":"0c959aecbb3565d9522d1c5e069fd9af6619fc05","modified":1575096804089},{"_id":"source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1574861533982},{"_id":"source/_drafts/using-travis-ci-auto-deploy-my-blog.md","hash":"1efdac2e3b13b12410c02d8798352297ea37ec20","modified":1574911413826},{"_id":"source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1574861528824},{"_id":"source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1574861453100},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1574697465473},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1574697465473},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1574697465474},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1574697465474},{"_id":"themes/pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1574697465483},{"_id":"themes/pure/layout/archive.ejs","hash":"ded5d953b35666e30f4c6e48e2d2c62af8d95ebf","modified":1574697465483},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1574697465483},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1574697465483},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1574697465483},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1574697465483},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1574697465484},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1574697465484},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1574697465484},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1574697465484},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1574697465484},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1574697465484},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1574697465484},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1574697465499},{"_id":"themes/pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1574697465502},{"_id":"source/_posts/Algorithm/.DS_Store","hash":"d861e5f87d4cfff8856b01dce6148c2d67e576e1","modified":1574861958858},{"_id":"source/_posts/DevOps/jenkins-testlink-plugin-source-code-note.md","hash":"13c0b79699457f49e5b0fdf6b77e1b26f73d8401","modified":1574943546983},{"_id":"source/_posts/DevOps/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1574996438331},{"_id":"source/_posts/Tools/introduce-git.md","hash":"55855dd9a49a57a2d8b4710d7fa76a461a7b15d7","modified":1574863403350},{"_id":"source/_posts/Tools/vscode-plugin-dev-intro.md","hash":"34760f38123d031413a51a9252860efa3e85a9e4","modified":1573459160463},{"_id":"source/_posts/Java/.DS_Store","hash":"49b2d4607bbcc1d24f06599c6819a0240969bea9","modified":1574996493430},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1574697465472},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1574697465473},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1574697465472},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1574697465473},{"_id":"themes/pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1574697465472},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1574697465473},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1574697465473},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1574697465473},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1574697465473},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"61ec9d04eaafc44b702294951c3ae03bb53df201","modified":1574753215518},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1574697465474},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1574697465474},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1574697465474},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1574697465474},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"c66c86d6a6a90e00494c380603426fc0f4006311","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"e39dc762d9fe238cede462532e40eaa3d8651122","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1574697465475},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1574697465476},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1574697465476},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1574697465476},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"9f755b0da1ea928dece32c2050d8a04b3a9fb13b","modified":1574697465476},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"41a319642da5af07d6cfb8525796aa610b721879","modified":1574697465476},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"e10ea0176ba87e64888234bafedc01c92544352c","modified":1574697465478},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1574697465478},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"152538ceceb0fdef65c46470ebf0189f7b891c5b","modified":1574697465478},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1574697465480},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"143087db0573772b0bdaf7f93312553158942ec7","modified":1574697465481},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1574697465480},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1574697465481},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1574697465481},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1574697465481},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"14f2e7d4c1055ff6a5f5867dc0e9a9f6f4c28fe1","modified":1574697465481},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1574697465481},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1574697465481},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1574697465481},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1574697465481},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1574697465482},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1574697465482},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1574697465482},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1574697465482},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1574697465482},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1574697465482},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1574697465482},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1574697465483},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1574697465502},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1574697465503},{"_id":"themes/pure/source/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1574697465506},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1574697465507},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1574697465508},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1574697465508},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1574697465506},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1574697465509},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1574697465505},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1574697465513},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1574697465509},{"_id":"source/_posts/Algorithm/Data-Structure/avlree-template-implement.md","hash":"ca83e88b595d3f8f8ac2edcaef09abf25a2b1542","modified":1574825829697},{"_id":"source/_posts/Algorithm/Data-Structure/isBST.md","hash":"3925beb415d83d3076ea59f9eb24bbafc0502244","modified":1574996294540},{"_id":"source/_posts/Algorithm/ForOffer/find-in-two-dimensional-array.md","hash":"fe83955fd11c0fc3f64f8d0335fb1ccee603403b","modified":1573459160429},{"_id":"source/_posts/Algorithm/Data-Structure/topological-sort-all.md","hash":"c128cdbc0abb6f9d869519ac3464413319a83030","modified":1574996339510},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1574697465510},{"_id":"source/_posts/Algorithm/Data-Structure/topological-sort.md","hash":"2fdd0a67b2a957519092b7ac94b9149c0bc7d59e","modified":1574996296570},{"_id":"source/_posts/Algorithm/ForOffer/implement-queue-with-stack.md","hash":"a7a7bc172db030551ca9c2ce297d57669b47416c","modified":1573459160429},{"_id":"source/_posts/Algorithm/ForOffer/min-number-in-rotate-array.md","hash":"2c2a34b95620d2964cc42646e26113507ec40816","modified":1573459160429},{"_id":"source/_posts/Algorithm/ForOffer/print-list-from-tail-to-head.md","hash":"b59858e828c2420f829fc39d170858d0d4bfb59c","modified":1573459160430},{"_id":"source/_posts/Algorithm/ForOffer/reconstruct-binary-tree.md","hash":"8442312fbb56f21effc843b681fd8b05a4e642bf","modified":1573459160430},{"_id":"source/_posts/Algorithm/ForOffer/replace-sapce.md","hash":"bd637cdd78c32dffc0bca6f1899daa01c715714c","modified":1573459160430},{"_id":"source/_posts/Java/Collection-Framework/ArrayList-Grow.md","hash":"166ff002c3f70b650bc8b983dbbe805eacaa94c6","modified":1573459160460},{"_id":"source/_posts/Java/Collection-Framework/ArrayList.md","hash":"c87cc0d38100105c4434d950eaf880d78bdb3213","modified":1573459160461},{"_id":"source/_posts/Java/Collection-Framework/HashMap.md","hash":"48d05f224d82a9e02a9ef23d6ac799197aa607d2","modified":1573459160461},{"_id":"source/_posts/Java/Collection-Framework/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1553312248164},{"_id":"source/_posts/Java/Collection-Framework/LinkedList.md","hash":"f5d3a2b37b79678544c548ad77e903ffa93710ea","modified":1573459160461},{"_id":"source/_posts/Java/Concurrency/questiones-multithread-in-java.md","hash":"c80cceb9fe83a15c3c9a1a13f07bf4b6f58a9c2c","modified":1573459160462},{"_id":"source/_posts/Java/JVM/implement-function-call-in-c.md","hash":"1aacf297b778cc7cf2c30e587fd005879c9b5101","modified":1574856858934},{"_id":"source/_posts/Java/Summary/common-questions.md","hash":"b2f7b53e6f0206250f63b519959c5bb113800f4d","modified":1573459160462},{"_id":"source/_posts/Java/Summary/string.md","hash":"88d67b2239e558e4acd598e8122ba1701eced3e3","modified":1573459160463},{"_id":"source/_posts/Java/Summary/thread.md","hash":"947481028b3cb5ece264a63e25d21e7a3e613aab","modified":1573459160463},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1574697465476},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1574697465476},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"a9d3d05428e5844a07706c7fcfeb842e44a36a64","modified":1574697465476},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"95eabc0fe4033ec61b240a16eeaf7dc62a9e3da1","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1574697465478},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1574697465477},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1574697465478},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1574697465478},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1574697465479},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1574697465479},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1574697465479},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"fb01f1631c3ae7fe6211dc03233506cb344229be","modified":1574697465479},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1574697465479},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1574697465479},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1574697465480},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1574697465480},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1574697465480},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1574697465480},{"_id":"themes/pure/source/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1574697465500},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1574697465507},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1574697465502},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1574697465507},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1574697465507},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1574697465505},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1574697465512},{"_id":"public/atom.xml","hash":"8ed204434ed95b72b7aecd7a286ebc655e486a74","modified":1575190904239},{"_id":"public/content.json","hash":"4f9dc190185f3949d92bf1a61e51955e68d1430c","modified":1575190904251},{"_id":"public/sitemap.xml","hash":"4bc01928d9e04a58c8a6743c379da45941cd8226","modified":1575190904628},{"_id":"public/about/index.html","hash":"78da65ce2ca54838bcea37080f2da850732c8224","modified":1575190904831},{"_id":"public/categories/index.html","hash":"301e5a91e34625b452cea2501fa04ca376169037","modified":1575190904831},{"_id":"public/tags/index.html","hash":"7d01895211c6de13c393cae451cccd657b26c0be","modified":1575190904831},{"_id":"public/repository/index.html","hash":"b8242c73deab999b4acc26167f7b7b0d2847b028","modified":1575190904831},{"_id":"public/2019/12/01/how-to-write-excellent-dockerfile/index.html","hash":"0295bf74bab02f34b26a62601a089349f23eb582","modified":1575190904831},{"_id":"public/2019/11/28/the-art-of-command-line/index.html","hash":"9a73d4610f3ba45d74441cb272d1420467243a08","modified":1575190904831},{"_id":"public/2019/11/27/gitlab-data-migrate-and-upgrade/index.html","hash":"68f94480834f1471c810ddddde1348fdf2a77536","modified":1575190904831},{"_id":"public/2019/11/27/serial-port-debug-env-automation/index.html","hash":"71df4138d628663f3a123d7cf4c59744bdd808d1","modified":1575190904831},{"_id":"public/2019/11/27/DevOps/jenkins-testlink-plugin-source-code-note/index.html","hash":"103c42231aad2cecdb9a7ae2f43e04740af2b720","modified":1575190904831},{"_id":"public/2019/11/27/Java/JVM/implement-function-call-in-c/index.html","hash":"0a6d84ace6ca963db1826b0069a42692e297dd59","modified":1575190904831},{"_id":"public/2019/11/27/Algorithm/Data-Structure/avlree-template-implement/index.html","hash":"f5854d8c9d8a9b4d6372acf9e2fd39ac030999af","modified":1575190904831},{"_id":"public/2019/11/26/http-status-code/index.html","hash":"8fc1419f00642be685c1b8672fcfcebe013acb20","modified":1575190904831},{"_id":"public/2019/11/11/Java/Summary/string/index.html","hash":"d2a4e5a9a3633ade934c4ee578c14d613bfd90b8","modified":1575190904831},{"_id":"public/2019/11/11/Tools/vscode-plugin-dev-intro/index.html","hash":"e8ca4574b073568962b9a0d638ac1417f3c3119c","modified":1575190904831},{"_id":"public/2019/11/11/Java/Summary/thread/index.html","hash":"84b76a9e60fc60d2319d7fe73ebf4b1798974f67","modified":1575190904832},{"_id":"public/2019/11/11/Java/Concurrency/questiones-multithread-in-java/index.html","hash":"2365e751230b42013d76dad477614d6245ee8542","modified":1575190904832},{"_id":"public/2019/11/11/Java/Summary/common-questions/index.html","hash":"8a0b2b768f0356b7a4454e26a128b34509522c93","modified":1575190904832},{"_id":"public/2019/11/11/Java/Collection-Framework/LinkedList/index.html","hash":"5efda7054b99d04fd3354148544b6c007ff5bbe5","modified":1575190904832},{"_id":"public/2019/11/11/Java/Collection-Framework/HashMap/index.html","hash":"fa8cd1a52f9a425c23438924eaa608fb678d035d","modified":1575190904832},{"_id":"public/2019/11/11/Java/Collection-Framework/ArrayList/index.html","hash":"d553075c2e373fee9b0e40bebba2e751ab484067","modified":1575190904832},{"_id":"public/2019/11/11/Java/Collection-Framework/ArrayList-Grow/index.html","hash":"0b826ecd4469ddf7a9afe9ffc224fe697216c844","modified":1575190904832},{"_id":"public/2019/11/11/Tools/introduce-git/index.html","hash":"ab074c42ded707e41ab515a024ca78fa80b6dae8","modified":1575190904832},{"_id":"public/2019/11/11/Algorithm/ForOffer/replace-sapce/index.html","hash":"36dd0dd18add8fe4b2ed08412c5084d37bf149bf","modified":1575190904832},{"_id":"public/2019/11/11/Algorithm/ForOffer/reconstruct-binary-tree/index.html","hash":"cc9363d10be9976f57e2a1aad5ad35a10dc63f90","modified":1575190904832},{"_id":"public/2019/11/11/Algorithm/Data-Structure/topological-sort/index.html","hash":"967ceb3c225c96866a388412d4afbd32a9059980","modified":1575190904832},{"_id":"public/2019/11/11/Algorithm/ForOffer/min-number-in-rotate-array/index.html","hash":"ed15aeaa6231f9eca2e292ab70e0285e50ffce2c","modified":1575190904833},{"_id":"public/2019/11/11/Algorithm/ForOffer/implement-queue-with-stack/index.html","hash":"c820a83d367a061cdf7118aaf3746567062f99dc","modified":1575190904833},{"_id":"public/2019/11/11/Algorithm/ForOffer/find-in-two-dimensional-array/index.html","hash":"266cb2f86e0d7206ccdf7f124d878018442c1c4c","modified":1575190904833},{"_id":"public/2019/11/11/Algorithm/ForOffer/print-list-from-tail-to-head/index.html","hash":"606233fd2e3c6e8a9b050c46e22cbd62a6614c7a","modified":1575190904833},{"_id":"public/2019/11/11/Algorithm/Data-Structure/isBST/index.html","hash":"fbbc14dd0385594e79e5f4a02a697334008573fe","modified":1575190904833},{"_id":"public/2019/11/11/Algorithm/Data-Structure/topological-sort-all/index.html","hash":"a8d97bc29bee6ea6c08b97433865fdd1e1cf5a80","modified":1575190904833},{"_id":"public/archives/index.html","hash":"96dbe875e79e09c8a955c29e0927a41e7e0dad0d","modified":1575190904833},{"_id":"public/archives/page/2/index.html","hash":"551a48633e375fe415914ab59ccb2c0c3b49d5fd","modified":1575190904833},{"_id":"public/archives/page/3/index.html","hash":"8bca7d0b747b062454c0ad4f6d1521bf0ebb5ecb","modified":1575190904833},{"_id":"public/archives/2019/index.html","hash":"1bac090ac76fa2e47d882a4337b844a9bec30d02","modified":1575190904833},{"_id":"public/archives/2019/page/2/index.html","hash":"705d12523dc8e1f3fa13bcd66cffd5b5feec47e0","modified":1575190904833},{"_id":"public/archives/2019/page/3/index.html","hash":"237118a473e8ea24dcd8b5cdf2587f4bfc24292f","modified":1575190904833},{"_id":"public/archives/2019/11/index.html","hash":"ff952ac6ebfc3814ffe4ff61653abb19687864bd","modified":1575190904833},{"_id":"public/archives/2019/11/page/2/index.html","hash":"a1883e8d655301673377990443b0c8d8dc1a943b","modified":1575190904833},{"_id":"public/archives/2019/11/page/3/index.html","hash":"3fd5abaa6f379319c5ed5f68f0e171652f198205","modified":1575190904834},{"_id":"public/archives/2019/12/index.html","hash":"6b8db35f464558e6852d0121fb9a94ee118df776","modified":1575190904834},{"_id":"public/categories/DevOps/index.html","hash":"6f8a6dfcc59b6d55f37093ea84e28b25d85102d4","modified":1575190904834},{"_id":"public/categories/Tools/index.html","hash":"0c91b42c4725472ba5c8dd2bf1089e068d820292","modified":1575190904834},{"_id":"public/categories/Algorithm/index.html","hash":"49f0e2e2a3618d04e50aab95d4bc80159fa70016","modified":1575190904834},{"_id":"public/categories/Algorithm/ForOffer/index.html","hash":"d58a4e7063adb1286edf72eb0cff166f9320e53b","modified":1575190904834},{"_id":"public/categories/Algorithm/Data-Structure/index.html","hash":"916e2fa79232cde8c703f27c8173fab1853f707c","modified":1575190904834},{"_id":"public/categories/Java/index.html","hash":"3f46b8310c6bf672f169c4104c793596859d54fe","modified":1575190904834},{"_id":"public/categories/Java/JVM/index.html","hash":"14ac68e0651269558479ec816383f8788328e401","modified":1575190904834},{"_id":"public/categories/Java/Collection-Framework/index.html","hash":"f99536ef1b727a7359da366ee13902be7f2698a0","modified":1575190904834},{"_id":"public/categories/Java/Summary/index.html","hash":"c2c5fbfe16ac7de7dc21d0cad06862acce49c2de","modified":1575190904834},{"_id":"public/categories/Java/Concurrency/index.html","hash":"d26356c4cd6bc8a876cbbc63fd5fbdc270401202","modified":1575190904834},{"_id":"public/index.html","hash":"f0eb230baeaae8a74b638b5d56e997aacc02f444","modified":1575190904835},{"_id":"public/page/2/index.html","hash":"5ff2d676e92901991c799f68d7aef61c746a77d6","modified":1575190904835},{"_id":"public/page/3/index.html","hash":"69b22c14361c029564121cba217b8c437ce13c93","modified":1575190904835},{"_id":"public/tags/gitlab/index.html","hash":"155c7fccc347de5ce6a7ebb932999c2ec6e83def","modified":1575190904835},{"_id":"public/tags/automation/index.html","hash":"d2e32a96ff93bffa1d3781f500316e1544ced56e","modified":1575190904835},{"_id":"public/tags/tool/index.html","hash":"9fa2e8726ef6a87ad73683010f54fecf5a2b7b4b","modified":1575190904835},{"_id":"public/tags/docker/index.html","hash":"aa348fc59e08c6a6a6e2e96facdc79be463bcbe0","modified":1575190904835},{"_id":"public/tags/http/index.html","hash":"79fbb60c987e233445f34154fc580bbe63b870c8","modified":1575190904836},{"_id":"public/tags/jenkins/index.html","hash":"9bc6a71422446e46062d46f791645b1074c08514","modified":1575190904836},{"_id":"public/tags/testlink/index.html","hash":"27f52039d45fae0521c6d973f933da389b91aed7","modified":1575190904836},{"_id":"public/tags/plugin/index.html","hash":"4a5d7859a92d5dcaa99a717c37eb38356ed3e753","modified":1575190904836},{"_id":"public/tags/vscode/index.html","hash":"612bb4fb1f2a71fb97034f30fdd0e58e55538777","modified":1575190904836},{"_id":"public/tags/tools/index.html","hash":"2bd31cde73a36bee4ced499273a081f0b6579a20","modified":1575190904836},{"_id":"public/tags/algorithm/index.html","hash":"21a9c7d5c042a7d6bf0f0839c09885917b5fe4e9","modified":1575190904836},{"_id":"public/tags/array/index.html","hash":"68b9b818e4f0b283999a23f6dc8e48a574490efe","modified":1575190904836},{"_id":"public/tags/graph/index.html","hash":"1244e87059e07baf946528013e67ea46df20a03b","modified":1575190904836},{"_id":"public/tags/topological-sort/index.html","hash":"7affdfbe80db83d571ffc30461bdf6721eec9a75","modified":1575190904836},{"_id":"public/tags/tree/index.html","hash":"9f3a3f75462f9e8c64c692fab045f2fc8b9e6019","modified":1575190904836},{"_id":"public/tags/queue/index.html","hash":"7954bf95362895db0895ae7068f2198b69624b5a","modified":1575190904836},{"_id":"public/tags/stack/index.html","hash":"38ce56230a05e0ef4396193ad44c62de257a6994","modified":1575190904836},{"_id":"public/tags/search/index.html","hash":"f4e566732af19442ecdea166b7c2fbb0dd893f5a","modified":1575190904837},{"_id":"public/tags/linked-list/index.html","hash":"3f70fcebd60086667e8356c0d36f88704617dfb1","modified":1575190904837},{"_id":"public/tags/binary-tree/index.html","hash":"cba284a632aee44a4842718bf052fe09a360379d","modified":1575190904837},{"_id":"public/tags/string/index.html","hash":"d4cdacacf7fdf6896dac4515066bcdd9b60a7e03","modified":1575190904837},{"_id":"public/tags/jvm/index.html","hash":"7193bf7702667f420cb3be0912a28d77cb1811bf","modified":1575190904837},{"_id":"public/tags/array-list/index.html","hash":"071031b197a8ade4a66ef22ae17217459c4683c9","modified":1575190904837},{"_id":"public/tags/interview-questions/index.html","hash":"266a44cf43b25b7cad7c23cb2518b33d442aa875","modified":1575190904837},{"_id":"public/tags/multithread/index.html","hash":"b36687f2af811ea102dde2278f10ec2770ad6b88","modified":1575190904837},{"_id":"public/tags/interview/index.html","hash":"32d3c7b635af21128fa498243192032374780857","modified":1575190904837},{"_id":"public/tags/map/index.html","hash":"a0d6ff4876474017ee75e84428c15c373ecdb276","modified":1575190904837},{"_id":"public/tags/hashmap/index.html","hash":"a28fcb1758be080d4355349a7348796895bda6f6","modified":1575190904837},{"_id":"public/CNAME","hash":"a85c94de837d0896258389b43e7931bbb254d860","modified":1575190904841},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1575190904841},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1575190904841},{"_id":"public/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1575190904841},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1575190904841},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1575190904841},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1575190904841},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1575190904841},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1575190904841},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1575190904841},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1575190904848},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1575190904848},{"_id":"public/fonts/README.html","hash":"43b6265aeccff3f9d495e2b44d07b249a2197bd7","modified":1575190904848},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1575190904848},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1575190904848},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1575190904853},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1575190904881},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1575190904883},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1575190904895},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1575190904897},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1575190904906}],"Category":[{"name":"DevOps","_id":"ck3mrzrbj0004lon9an6mpyzd"},{"name":"Tools","_id":"ck3mrzrcs000vlon9vkqqn9oc"},{"name":"Algorithm","_id":"ck3mrzrda001flon9b12isibc"},{"name":"ForOffer","parent":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdg001tlon9484x1pd1"},{"name":"Data-Structure","parent":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdj0024lon9s3vk4ehk"},{"name":"Java","_id":"ck3mrzrdo002vlon98gnhmlu0"},{"name":"JVM","parent":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzrdp0034lon92lmoltjr"},{"name":"Collection-Framework","parent":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzrdw003plon9yjosylz2"},{"name":"Summary","parent":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzrdz003wlon9pw1h5xcr"},{"name":"Concurrency","parent":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre00041lon94sml7bbi"}],"Data":[],"Page":[{"title":"关于","description":"个人简介","layout":"about","comments":0,"sidebar":"custom","_content":"个人详细介绍","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人简介\nlayout: about\ncomments: false\nsidebar: custom\n---\n个人详细介绍","date":"2019-11-28T02:50:53.123Z","updated":"2019-11-27T13:30:29.893Z","path":"about/index.html","_id":"ck3mrzrbg0001lon9egq2n1y4","content":"<p>个人详细介绍</p>\n","site":{"data":{}},"excerpt":"","more":"<p>个人详细介绍</p>\n"},{"title":"分类","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\nlayout: categories\ncomments: false\n---\n","date":"2019-11-27T13:32:13.983Z","updated":"2019-11-27T13:32:13.982Z","path":"categories/index.html","_id":"ck3mrzrbi0003lon9b8wh1hyu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2019-11-27T13:32:08.827Z","updated":"2019-11-27T13:32:08.824Z","path":"tags/index.html","_id":"ck3mrzrbl0007lon9jq1omhva","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Repositories","layout":"repository","comments":0,"sidebar":"none","_content":"","source":"repository/index.md","raw":"---\ntitle: Repositories\nlayout: repository\ncomments: false\nsidebar: none\n---\n","date":"2019-11-27T13:30:53.100Z","updated":"2019-11-27T13:30:53.100Z","path":"repository/index.html","_id":"ck3mrzrbn0009lon9auu7sp5j","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"GitLab 迁移与升级","date":"2019-11-27T12:16:23.000Z","_content":"\n## 关于 GItlab 数据迁移与升级\n\n## 背景\n\n公司内部的 SDK 版本是通过 GItlab 进行版本管理，而在 SDK 中存在着大量的二进制文件，在进行多次版本发布之后，`.git` 文件越来越大，pull 新版本的时间也越来越长。\n\nGit LFS 工具可以很好的解决这个问题，通过将二进制文件直接上传的方式，git 只需要保存字符链接，关于 git LFS 的原理可以看这里：\n\n![image-20191101162007033](/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101162007033.png)\n\n那么问题来了，由于 gitlab 的开始对 LFS 的版本高于目前公司使用的版本，那么就开始升级采坑之旅吧。\n\n## 问题\n\n之前的 gitlab 的部署是通过 bitnami 的 VM 部署到 host 机器上的，想转到用 docker 来进行部署。\n\n首先我预想的方式是，将之前的 bitnami VM 的备份导入到 dockerhub 对应版本的镜像，在 Restore 之后换成更高版本的 gitlab image。不过很遗憾，这个方法失败了，gitlab 的升级需要递进的升级，在这里给出官方推荐的升级路线：\n\npic\n\n\n\n那么换一种思路，先把之前的备份先恢复到对应的 gitlab image 上，在容器内部进行升级，之后再做一个备份，迁移到更高版本的 gitlab image。结论是，这个方法是可行的。\n\n## 踩坑之旅\n\n1. 前期准备：\n\n- gitlab 8.5.1 备份\n- Linux server with docker \n\n了解关于与备份恢复相关的一些命令：\n\n~~~bash\n# 查看 gitlab 版本\ngitlab-rake gitlab:env:info\n\n# 创建备份\ngitlab-rake gitlab:backup:create\n\n# 恢复备份\n# 停止相关数据连接服务\ngitlab-ctl stop unicorn\ngitlab-ctl stop sidekiq\n\n# 从备份中恢复，通过备份文件名前缀选择\ngitlab-rake gitlab:backup:restore BACKUP=1572508219_2019_10_31_11.3.4\n~~~\n\n创建备份后得到一个文件 `1572508219_2019_10_31_11.3.4_gitlab_backup.tar`\n\n根据查看的 gitlab 版本为 8.5.1\n\n`docker pull gitlab/gitlab-ce:8.5.1-ce.0`\n\n运行：\n\n~~~bash\n#!/bin/bash\n\nsudo docker run --detach \\\n  --hostname gitlab.qa \\\n  --publish 443:443 --publish 80:80 --publish 22:22 \\\n  --name gitlab \\\n  --restart always \\\n  --volume /srv/gitlab/config:/etc/gitlab \\\n  --volume /srv/gitlab/logs:/var/log/gitlab \\\n  --volume /srv/gitlab/data:/var/opt/gitlab \\\n  --volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\\n  --env GITLAB_OMNIBUS_CONFIG=\"external_url 'http://192.168.205.236';\" \\\n  gitlab/gitlab-ce:8.5.1-ce.0\n\n~~~\n\n关于`--volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\`：\n\n如果去掉会有如下错误\n\n![image-20191101120624086](/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101120624086.png)\n\n`docker exec -ti gitlab /bin/bash` 进入容器，\n\n首先进行恢复\n~~~bash\nsudo gitlab-ctl stop unicorn\nsudo gitlab-ctl stop sidekiq\ngitlab-rake gitlab:backup:restore BACKUP=1572508219_xxxx\n~~~\n如果在恢复前对 gitlab 进行过设置，恢复时候将会覆盖掉，所以最好是在一个干净的 server 上进行恢复\n\n恢复后按照官方推荐的方式逐个版本升级 \n\n<img src=\"/Users/Xiaoy/Documents/MarkDown Files/imgs/gitlab-upgrade-version-path.png\" alt=\"image-20191101161240814\" style=\"zoom:;\" />\n\n[GitLab Release and Maintenance Policy](https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations)\n\n## 升级过程：\nTips:由于某ZZ的墙的原因,使用Gitlab的官方apt源会出现下载不了，可以选择清华的镜像，你也可以使用apt-mirror来自建本地的apt源(`https://packages.gitlab.com/gitlab/gitlab-ce/mirror`)但是版本可能会跟不上官方的更新。\n\n1. 先进行数据的备份,这一步可以省略，因为gitlab在升级的时候会自动为你备份\n   `gitlab-rake gitlab :backup :create RAILS_ENV=production`\n\n2. 下载官方的提供的apt源自动更新脚本\n   我的是ubuntu系统，所以选择的是apt源官方的package list 地址:\n   手动更新apt源，最终我采用的是官方提供的这个文档：`https://packages.gitlab.com/gitlab/gitlab-ce/install#manual`\n\n- refreshing package cache :\n  `sudo apt-get update`\n\n- Ensure the required tools are installed before proceeding \n\n  `sudo apt-get install curl gnupg apt-transport-https`\n\n- install GPG Key:\n  `curl -L https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey | sudo apt-key add –`\n\n- create apt file: /etc/apt/sources.list.d/gitlab_gitlab_ce.list ,please include repository configuration below :\n  如果是ubuntu 系统如下:\n\n  ```bash\n  deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main\n  deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main\n  ```\n\n  如果是别的Linux Distribution and version ，参考如下的文档:\n  `https://packagecloud.io/docs#os_distro_version`\n\n- `sudo apt-get update`\n\n3. apt源配置完毕，下面可是执行上面的安装命令:\n   先升级到9.5.0\n   `sudo apt-get install gitlab-ce=9.5.1-ce.0`\n   完毕后没有问题,要重启gitlab-ctl restart\n   升级到10.8.7\n   `sudo apt-get install gitlab-ce=10.8.7-ce.0`\n   没有问题，重启sudo gitlab-ctl restart\n   升级到最新版:\n   `sudo apt-get install gitlab-ce`\n   最后一部，如果没有大的版本发布，直接执行install 就行\n   没有问题，重启`sudo gitlab-ctl restart`\n\n4. 至此，gitlab的升级完成\n\n   在升级好的 gitlab 上进行备份`gitlab-rake gitlab:backup:create` 再次迁移，即可\n\n\n\n## 关于常见报错\n\n### 访问 500 错误\n\n\n\n## Reference\n\n[Gitlab 升级总结](https://www.darrykinger.com/index.php/archives/27/)\n\n[Gitlab 无损升级](https://www.jianshu.com/p/4b9a22d67466)\n\n[Git 迁移到 Git LFS 实践]([https://networm.me/2018/05/13/migrate-to-gitlfs/#%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7](https://networm.me/2018/05/13/migrate-to-gitlfs/#转换工具))\n\n[GitLab数据备份与恢复](https://www.jianshu.com/p/a2600f8dffc2)\n\n[Migrate a Git repo into Git LFS with BFG](https://docs.gitlab.com/ee/topics/git/migrate_to_git_lfs/index.html)\n\n[化繁为简的企业级 Git 管理实战（五）：二进制大文件的版本控制](https://www.hahack.com/work/enterprise-class-git-version-control-5/)\n\n","source":"_posts/gitlab-data-migrate-and-upgrade.md","raw":"---\ntitle: GitLab 迁移与升级\ndate: 2019-11-27 20:16:23\ntags:\n  - gitlab\ncategories:\n  - DevOps\n---\n\n## 关于 GItlab 数据迁移与升级\n\n## 背景\n\n公司内部的 SDK 版本是通过 GItlab 进行版本管理，而在 SDK 中存在着大量的二进制文件，在进行多次版本发布之后，`.git` 文件越来越大，pull 新版本的时间也越来越长。\n\nGit LFS 工具可以很好的解决这个问题，通过将二进制文件直接上传的方式，git 只需要保存字符链接，关于 git LFS 的原理可以看这里：\n\n![image-20191101162007033](/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101162007033.png)\n\n那么问题来了，由于 gitlab 的开始对 LFS 的版本高于目前公司使用的版本，那么就开始升级采坑之旅吧。\n\n## 问题\n\n之前的 gitlab 的部署是通过 bitnami 的 VM 部署到 host 机器上的，想转到用 docker 来进行部署。\n\n首先我预想的方式是，将之前的 bitnami VM 的备份导入到 dockerhub 对应版本的镜像，在 Restore 之后换成更高版本的 gitlab image。不过很遗憾，这个方法失败了，gitlab 的升级需要递进的升级，在这里给出官方推荐的升级路线：\n\npic\n\n\n\n那么换一种思路，先把之前的备份先恢复到对应的 gitlab image 上，在容器内部进行升级，之后再做一个备份，迁移到更高版本的 gitlab image。结论是，这个方法是可行的。\n\n## 踩坑之旅\n\n1. 前期准备：\n\n- gitlab 8.5.1 备份\n- Linux server with docker \n\n了解关于与备份恢复相关的一些命令：\n\n~~~bash\n# 查看 gitlab 版本\ngitlab-rake gitlab:env:info\n\n# 创建备份\ngitlab-rake gitlab:backup:create\n\n# 恢复备份\n# 停止相关数据连接服务\ngitlab-ctl stop unicorn\ngitlab-ctl stop sidekiq\n\n# 从备份中恢复，通过备份文件名前缀选择\ngitlab-rake gitlab:backup:restore BACKUP=1572508219_2019_10_31_11.3.4\n~~~\n\n创建备份后得到一个文件 `1572508219_2019_10_31_11.3.4_gitlab_backup.tar`\n\n根据查看的 gitlab 版本为 8.5.1\n\n`docker pull gitlab/gitlab-ce:8.5.1-ce.0`\n\n运行：\n\n~~~bash\n#!/bin/bash\n\nsudo docker run --detach \\\n  --hostname gitlab.qa \\\n  --publish 443:443 --publish 80:80 --publish 22:22 \\\n  --name gitlab \\\n  --restart always \\\n  --volume /srv/gitlab/config:/etc/gitlab \\\n  --volume /srv/gitlab/logs:/var/log/gitlab \\\n  --volume /srv/gitlab/data:/var/opt/gitlab \\\n  --volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\\n  --env GITLAB_OMNIBUS_CONFIG=\"external_url 'http://192.168.205.236';\" \\\n  gitlab/gitlab-ce:8.5.1-ce.0\n\n~~~\n\n关于`--volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\`：\n\n如果去掉会有如下错误\n\n![image-20191101120624086](/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101120624086.png)\n\n`docker exec -ti gitlab /bin/bash` 进入容器，\n\n首先进行恢复\n~~~bash\nsudo gitlab-ctl stop unicorn\nsudo gitlab-ctl stop sidekiq\ngitlab-rake gitlab:backup:restore BACKUP=1572508219_xxxx\n~~~\n如果在恢复前对 gitlab 进行过设置，恢复时候将会覆盖掉，所以最好是在一个干净的 server 上进行恢复\n\n恢复后按照官方推荐的方式逐个版本升级 \n\n<img src=\"/Users/Xiaoy/Documents/MarkDown Files/imgs/gitlab-upgrade-version-path.png\" alt=\"image-20191101161240814\" style=\"zoom:;\" />\n\n[GitLab Release and Maintenance Policy](https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations)\n\n## 升级过程：\nTips:由于某ZZ的墙的原因,使用Gitlab的官方apt源会出现下载不了，可以选择清华的镜像，你也可以使用apt-mirror来自建本地的apt源(`https://packages.gitlab.com/gitlab/gitlab-ce/mirror`)但是版本可能会跟不上官方的更新。\n\n1. 先进行数据的备份,这一步可以省略，因为gitlab在升级的时候会自动为你备份\n   `gitlab-rake gitlab :backup :create RAILS_ENV=production`\n\n2. 下载官方的提供的apt源自动更新脚本\n   我的是ubuntu系统，所以选择的是apt源官方的package list 地址:\n   手动更新apt源，最终我采用的是官方提供的这个文档：`https://packages.gitlab.com/gitlab/gitlab-ce/install#manual`\n\n- refreshing package cache :\n  `sudo apt-get update`\n\n- Ensure the required tools are installed before proceeding \n\n  `sudo apt-get install curl gnupg apt-transport-https`\n\n- install GPG Key:\n  `curl -L https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey | sudo apt-key add –`\n\n- create apt file: /etc/apt/sources.list.d/gitlab_gitlab_ce.list ,please include repository configuration below :\n  如果是ubuntu 系统如下:\n\n  ```bash\n  deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main\n  deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main\n  ```\n\n  如果是别的Linux Distribution and version ，参考如下的文档:\n  `https://packagecloud.io/docs#os_distro_version`\n\n- `sudo apt-get update`\n\n3. apt源配置完毕，下面可是执行上面的安装命令:\n   先升级到9.5.0\n   `sudo apt-get install gitlab-ce=9.5.1-ce.0`\n   完毕后没有问题,要重启gitlab-ctl restart\n   升级到10.8.7\n   `sudo apt-get install gitlab-ce=10.8.7-ce.0`\n   没有问题，重启sudo gitlab-ctl restart\n   升级到最新版:\n   `sudo apt-get install gitlab-ce`\n   最后一部，如果没有大的版本发布，直接执行install 就行\n   没有问题，重启`sudo gitlab-ctl restart`\n\n4. 至此，gitlab的升级完成\n\n   在升级好的 gitlab 上进行备份`gitlab-rake gitlab:backup:create` 再次迁移，即可\n\n\n\n## 关于常见报错\n\n### 访问 500 错误\n\n\n\n## Reference\n\n[Gitlab 升级总结](https://www.darrykinger.com/index.php/archives/27/)\n\n[Gitlab 无损升级](https://www.jianshu.com/p/4b9a22d67466)\n\n[Git 迁移到 Git LFS 实践]([https://networm.me/2018/05/13/migrate-to-gitlfs/#%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7](https://networm.me/2018/05/13/migrate-to-gitlfs/#转换工具))\n\n[GitLab数据备份与恢复](https://www.jianshu.com/p/a2600f8dffc2)\n\n[Migrate a Git repo into Git LFS with BFG](https://docs.gitlab.com/ee/topics/git/migrate_to_git_lfs/index.html)\n\n[化繁为简的企业级 Git 管理实战（五）：二进制大文件的版本控制](https://www.hahack.com/work/enterprise-class-git-version-control-5/)\n\n","slug":"gitlab-data-migrate-and-upgrade","published":1,"updated":"2019-11-28T06:24:33.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrb90000lon9dtgopunz","content":"<h2 id=\"关于-GItlab-数据迁移与升级\"><a href=\"#关于-GItlab-数据迁移与升级\" class=\"headerlink\" title=\"关于 GItlab 数据迁移与升级\"></a>关于 GItlab 数据迁移与升级</h2><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司内部的 SDK 版本是通过 GItlab 进行版本管理，而在 SDK 中存在着大量的二进制文件，在进行多次版本发布之后，<code>.git</code> 文件越来越大，pull 新版本的时间也越来越长。</p>\n<p>Git LFS 工具可以很好的解决这个问题，通过将二进制文件直接上传的方式，git 只需要保存字符链接，关于 git LFS 的原理可以看这里：</p>\n<p><img src=\"/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101162007033.png\" alt=\"image-20191101162007033\"></p>\n<p>那么问题来了，由于 gitlab 的开始对 LFS 的版本高于目前公司使用的版本，那么就开始升级采坑之旅吧。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>之前的 gitlab 的部署是通过 bitnami 的 VM 部署到 host 机器上的，想转到用 docker 来进行部署。</p>\n<p>首先我预想的方式是，将之前的 bitnami VM 的备份导入到 dockerhub 对应版本的镜像，在 Restore 之后换成更高版本的 gitlab image。不过很遗憾，这个方法失败了，gitlab 的升级需要递进的升级，在这里给出官方推荐的升级路线：</p>\n<p>pic</p>\n<p>那么换一种思路，先把之前的备份先恢复到对应的 gitlab image 上，在容器内部进行升级，之后再做一个备份，迁移到更高版本的 gitlab image。结论是，这个方法是可行的。</p>\n<h2 id=\"踩坑之旅\"><a href=\"#踩坑之旅\" class=\"headerlink\" title=\"踩坑之旅\"></a>踩坑之旅</h2><ol>\n<li>前期准备：</li>\n</ol>\n<ul>\n<li>gitlab 8.5.1 备份</li>\n<li>Linux server with docker </li>\n</ul>\n<p>了解关于与备份恢复相关的一些命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 gitlab 版本</span></span><br><span class=\"line\">gitlab-rake gitlab:env:info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建备份</span></span><br><span class=\"line\">gitlab-rake gitlab:backup:create</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复备份</span></span><br><span class=\"line\"><span class=\"comment\"># 停止相关数据连接服务</span></span><br><span class=\"line\">gitlab-ctl stop unicorn</span><br><span class=\"line\">gitlab-ctl stop sidekiq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从备份中恢复，通过备份文件名前缀选择</span></span><br><span class=\"line\">gitlab-rake gitlab:backup:restore BACKUP=1572508219_2019_10_31_11.3.4</span><br></pre></td></tr></table></figure>\n<p>创建备份后得到一个文件 <code>1572508219_2019_10_31_11.3.4_gitlab_backup.tar</code></p>\n<p>根据查看的 gitlab 版本为 8.5.1</p>\n<p><code>docker pull gitlab/gitlab-ce:8.5.1-ce.0</code></p>\n<p>运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo docker run --detach \\</span><br><span class=\"line\">  --hostname gitlab.qa \\</span><br><span class=\"line\">  --publish 443:443 --publish 80:80 --publish 22:22 \\</span><br><span class=\"line\">  --name gitlab \\</span><br><span class=\"line\">  --restart always \\</span><br><span class=\"line\">  --volume /srv/gitlab/config:/etc/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/logs:/var/<span class=\"built_in\">log</span>/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/data:/var/opt/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/logs/reconfigure:/var/<span class=\"built_in\">log</span>/gitlab/reconfigure \\</span><br><span class=\"line\">  --env GITLAB_OMNIBUS_CONFIG=<span class=\"string\">\"external_url 'http://192.168.205.236';\"</span> \\</span><br><span class=\"line\">  gitlab/gitlab-ce:8.5.1-ce.0</span><br></pre></td></tr></table></figure>\n<p>关于<code>--volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\</code>：</p>\n<p>如果去掉会有如下错误</p>\n<p><img src=\"/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101120624086.png\" alt=\"image-20191101120624086\"></p>\n<p><code>docker exec -ti gitlab /bin/bash</code> 进入容器，</p>\n<p>首先进行恢复<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-ctl stop unicorn</span><br><span class=\"line\">sudo gitlab-ctl stop sidekiq</span><br><span class=\"line\">gitlab-rake gitlab:backup:restore BACKUP=1572508219_xxxx</span><br></pre></td></tr></table></figure></p>\n<p>如果在恢复前对 gitlab 进行过设置，恢复时候将会覆盖掉，所以最好是在一个干净的 server 上进行恢复</p>\n<p>恢复后按照官方推荐的方式逐个版本升级 </p>\n<p><img src=\"/Users/Xiaoy/Documents/MarkDown Files/imgs/gitlab-upgrade-version-path.png\" alt=\"image-20191101161240814\" style=\"zoom:;\"></p>\n<p><a href=\"https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations\" target=\"_blank\" rel=\"noopener\">GitLab Release and Maintenance Policy</a></p>\n<h2 id=\"升级过程：\"><a href=\"#升级过程：\" class=\"headerlink\" title=\"升级过程：\"></a>升级过程：</h2><p>Tips:由于某ZZ的墙的原因,使用Gitlab的官方apt源会出现下载不了，可以选择清华的镜像，你也可以使用apt-mirror来自建本地的apt源(<code>https://packages.gitlab.com/gitlab/gitlab-ce/mirror</code>)但是版本可能会跟不上官方的更新。</p>\n<ol>\n<li><p>先进行数据的备份,这一步可以省略，因为gitlab在升级的时候会自动为你备份<br><code>gitlab-rake gitlab :backup :create RAILS_ENV=production</code></p>\n</li>\n<li><p>下载官方的提供的apt源自动更新脚本<br>我的是ubuntu系统，所以选择的是apt源官方的package list 地址:<br>手动更新apt源，最终我采用的是官方提供的这个文档：<code>https://packages.gitlab.com/gitlab/gitlab-ce/install#manual</code></p>\n</li>\n</ol>\n<ul>\n<li><p>refreshing package cache :<br><code>sudo apt-get update</code></p>\n</li>\n<li><p>Ensure the required tools are installed before proceeding </p>\n<p><code>sudo apt-get install curl gnupg apt-transport-https</code></p>\n</li>\n<li><p>install GPG Key:<br><code>curl -L https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey | sudo apt-key add –</code></p>\n</li>\n<li><p>create apt file: /etc/apt/sources.list.d/gitlab_gitlab_ce.list ,please include repository configuration below :<br>如果是ubuntu 系统如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main</span><br><span class=\"line\">deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main</span><br></pre></td></tr></table></figure>\n<p>如果是别的Linux Distribution and version ，参考如下的文档:<br><code>https://packagecloud.io/docs#os_distro_version</code></p>\n</li>\n<li><p><code>sudo apt-get update</code></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>apt源配置完毕，下面可是执行上面的安装命令:<br>先升级到9.5.0<br><code>sudo apt-get install gitlab-ce=9.5.1-ce.0</code><br>完毕后没有问题,要重启gitlab-ctl restart<br>升级到10.8.7<br><code>sudo apt-get install gitlab-ce=10.8.7-ce.0</code><br>没有问题，重启sudo gitlab-ctl restart<br>升级到最新版:<br><code>sudo apt-get install gitlab-ce</code><br>最后一部，如果没有大的版本发布，直接执行install 就行<br>没有问题，重启<code>sudo gitlab-ctl restart</code></p>\n</li>\n<li><p>至此，gitlab的升级完成</p>\n<p>在升级好的 gitlab 上进行备份<code>gitlab-rake gitlab:backup:create</code> 再次迁移，即可</p>\n</li>\n</ol>\n<h2 id=\"关于常见报错\"><a href=\"#关于常见报错\" class=\"headerlink\" title=\"关于常见报错\"></a>关于常见报错</h2><h3 id=\"访问-500-错误\"><a href=\"#访问-500-错误\" class=\"headerlink\" title=\"访问 500 错误\"></a>访问 500 错误</h3><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.darrykinger.com/index.php/archives/27/\" target=\"_blank\" rel=\"noopener\">Gitlab 升级总结</a></p>\n<p><a href=\"https://www.jianshu.com/p/4b9a22d67466\" target=\"_blank\" rel=\"noopener\">Gitlab 无损升级</a></p>\n<p><a href=\"[https://networm.me/2018/05/13/migrate-to-gitlfs/#%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7](https://networm.me/2018/05/13/migrate-to-gitlfs/#转换工具\">Git 迁移到 Git LFS 实践</a>)</p>\n<p><a href=\"https://www.jianshu.com/p/a2600f8dffc2\" target=\"_blank\" rel=\"noopener\">GitLab数据备份与恢复</a></p>\n<p><a href=\"https://docs.gitlab.com/ee/topics/git/migrate_to_git_lfs/index.html\" target=\"_blank\" rel=\"noopener\">Migrate a Git repo into Git LFS with BFG</a></p>\n<p><a href=\"https://www.hahack.com/work/enterprise-class-git-version-control-5/\" target=\"_blank\" rel=\"noopener\">化繁为简的企业级 Git 管理实战（五）：二进制大文件的版本控制</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于-GItlab-数据迁移与升级\"><a href=\"#关于-GItlab-数据迁移与升级\" class=\"headerlink\" title=\"关于 GItlab 数据迁移与升级\"></a>关于 GItlab 数据迁移与升级</h2><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>公司内部的 SDK 版本是通过 GItlab 进行版本管理，而在 SDK 中存在着大量的二进制文件，在进行多次版本发布之后，<code>.git</code> 文件越来越大，pull 新版本的时间也越来越长。</p>\n<p>Git LFS 工具可以很好的解决这个问题，通过将二进制文件直接上传的方式，git 只需要保存字符链接，关于 git LFS 的原理可以看这里：</p>\n<p><img src=\"/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101162007033.png\" alt=\"image-20191101162007033\"></p>\n<p>那么问题来了，由于 gitlab 的开始对 LFS 的版本高于目前公司使用的版本，那么就开始升级采坑之旅吧。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>之前的 gitlab 的部署是通过 bitnami 的 VM 部署到 host 机器上的，想转到用 docker 来进行部署。</p>\n<p>首先我预想的方式是，将之前的 bitnami VM 的备份导入到 dockerhub 对应版本的镜像，在 Restore 之后换成更高版本的 gitlab image。不过很遗憾，这个方法失败了，gitlab 的升级需要递进的升级，在这里给出官方推荐的升级路线：</p>\n<p>pic</p>\n<p>那么换一种思路，先把之前的备份先恢复到对应的 gitlab image 上，在容器内部进行升级，之后再做一个备份，迁移到更高版本的 gitlab image。结论是，这个方法是可行的。</p>\n<h2 id=\"踩坑之旅\"><a href=\"#踩坑之旅\" class=\"headerlink\" title=\"踩坑之旅\"></a>踩坑之旅</h2><ol>\n<li>前期准备：</li>\n</ol>\n<ul>\n<li>gitlab 8.5.1 备份</li>\n<li>Linux server with docker </li>\n</ul>\n<p>了解关于与备份恢复相关的一些命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 gitlab 版本</span></span><br><span class=\"line\">gitlab-rake gitlab:env:info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建备份</span></span><br><span class=\"line\">gitlab-rake gitlab:backup:create</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 恢复备份</span></span><br><span class=\"line\"><span class=\"comment\"># 停止相关数据连接服务</span></span><br><span class=\"line\">gitlab-ctl stop unicorn</span><br><span class=\"line\">gitlab-ctl stop sidekiq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从备份中恢复，通过备份文件名前缀选择</span></span><br><span class=\"line\">gitlab-rake gitlab:backup:restore BACKUP=1572508219_2019_10_31_11.3.4</span><br></pre></td></tr></table></figure>\n<p>创建备份后得到一个文件 <code>1572508219_2019_10_31_11.3.4_gitlab_backup.tar</code></p>\n<p>根据查看的 gitlab 版本为 8.5.1</p>\n<p><code>docker pull gitlab/gitlab-ce:8.5.1-ce.0</code></p>\n<p>运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo docker run --detach \\</span><br><span class=\"line\">  --hostname gitlab.qa \\</span><br><span class=\"line\">  --publish 443:443 --publish 80:80 --publish 22:22 \\</span><br><span class=\"line\">  --name gitlab \\</span><br><span class=\"line\">  --restart always \\</span><br><span class=\"line\">  --volume /srv/gitlab/config:/etc/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/logs:/var/<span class=\"built_in\">log</span>/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/data:/var/opt/gitlab \\</span><br><span class=\"line\">  --volume /srv/gitlab/logs/reconfigure:/var/<span class=\"built_in\">log</span>/gitlab/reconfigure \\</span><br><span class=\"line\">  --env GITLAB_OMNIBUS_CONFIG=<span class=\"string\">\"external_url 'http://192.168.205.236';\"</span> \\</span><br><span class=\"line\">  gitlab/gitlab-ce:8.5.1-ce.0</span><br></pre></td></tr></table></figure>\n<p>关于<code>--volume /srv/gitlab/logs/reconfigure:/var/log/gitlab/reconfigure \\</code>：</p>\n<p>如果去掉会有如下错误</p>\n<p><img src=\"/Users/Xiaoy/Library/Application Support/typora-user-images/image-20191101120624086.png\" alt=\"image-20191101120624086\"></p>\n<p><code>docker exec -ti gitlab /bin/bash</code> 进入容器，</p>\n<p>首先进行恢复<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-ctl stop unicorn</span><br><span class=\"line\">sudo gitlab-ctl stop sidekiq</span><br><span class=\"line\">gitlab-rake gitlab:backup:restore BACKUP=1572508219_xxxx</span><br></pre></td></tr></table></figure></p>\n<p>如果在恢复前对 gitlab 进行过设置，恢复时候将会覆盖掉，所以最好是在一个干净的 server 上进行恢复</p>\n<p>恢复后按照官方推荐的方式逐个版本升级 </p>\n<p><img src=\"/Users/Xiaoy/Documents/MarkDown Files/imgs/gitlab-upgrade-version-path.png\" alt=\"image-20191101161240814\" style=\"zoom:;\"></p>\n<p><a href=\"https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations\" target=\"_blank\" rel=\"noopener\">GitLab Release and Maintenance Policy</a></p>\n<h2 id=\"升级过程：\"><a href=\"#升级过程：\" class=\"headerlink\" title=\"升级过程：\"></a>升级过程：</h2><p>Tips:由于某ZZ的墙的原因,使用Gitlab的官方apt源会出现下载不了，可以选择清华的镜像，你也可以使用apt-mirror来自建本地的apt源(<code>https://packages.gitlab.com/gitlab/gitlab-ce/mirror</code>)但是版本可能会跟不上官方的更新。</p>\n<ol>\n<li><p>先进行数据的备份,这一步可以省略，因为gitlab在升级的时候会自动为你备份<br><code>gitlab-rake gitlab :backup :create RAILS_ENV=production</code></p>\n</li>\n<li><p>下载官方的提供的apt源自动更新脚本<br>我的是ubuntu系统，所以选择的是apt源官方的package list 地址:<br>手动更新apt源，最终我采用的是官方提供的这个文档：<code>https://packages.gitlab.com/gitlab/gitlab-ce/install#manual</code></p>\n</li>\n</ol>\n<ul>\n<li><p>refreshing package cache :<br><code>sudo apt-get update</code></p>\n</li>\n<li><p>Ensure the required tools are installed before proceeding </p>\n<p><code>sudo apt-get install curl gnupg apt-transport-https</code></p>\n</li>\n<li><p>install GPG Key:<br><code>curl -L https://packages.gitlab.com/gitlab/gitlab-ce/gpgkey | sudo apt-key add –</code></p>\n</li>\n<li><p>create apt file: /etc/apt/sources.list.d/gitlab_gitlab_ce.list ,please include repository configuration below :<br>如果是ubuntu 系统如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main</span><br><span class=\"line\">deb-src https://packages.gitlab.com/gitlab/gitlab-ce/ubuntu/ trusty main</span><br></pre></td></tr></table></figure>\n<p>如果是别的Linux Distribution and version ，参考如下的文档:<br><code>https://packagecloud.io/docs#os_distro_version</code></p>\n</li>\n<li><p><code>sudo apt-get update</code></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>apt源配置完毕，下面可是执行上面的安装命令:<br>先升级到9.5.0<br><code>sudo apt-get install gitlab-ce=9.5.1-ce.0</code><br>完毕后没有问题,要重启gitlab-ctl restart<br>升级到10.8.7<br><code>sudo apt-get install gitlab-ce=10.8.7-ce.0</code><br>没有问题，重启sudo gitlab-ctl restart<br>升级到最新版:<br><code>sudo apt-get install gitlab-ce</code><br>最后一部，如果没有大的版本发布，直接执行install 就行<br>没有问题，重启<code>sudo gitlab-ctl restart</code></p>\n</li>\n<li><p>至此，gitlab的升级完成</p>\n<p>在升级好的 gitlab 上进行备份<code>gitlab-rake gitlab:backup:create</code> 再次迁移，即可</p>\n</li>\n</ol>\n<h2 id=\"关于常见报错\"><a href=\"#关于常见报错\" class=\"headerlink\" title=\"关于常见报错\"></a>关于常见报错</h2><h3 id=\"访问-500-错误\"><a href=\"#访问-500-错误\" class=\"headerlink\" title=\"访问 500 错误\"></a>访问 500 错误</h3><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://www.darrykinger.com/index.php/archives/27/\" target=\"_blank\" rel=\"noopener\">Gitlab 升级总结</a></p>\n<p><a href=\"https://www.jianshu.com/p/4b9a22d67466\" target=\"_blank\" rel=\"noopener\">Gitlab 无损升级</a></p>\n<p><a href=\"[https://networm.me/2018/05/13/migrate-to-gitlfs/#%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7](https://networm.me/2018/05/13/migrate-to-gitlfs/#转换工具\">Git 迁移到 Git LFS 实践</a>)</p>\n<p><a href=\"https://www.jianshu.com/p/a2600f8dffc2\" target=\"_blank\" rel=\"noopener\">GitLab数据备份与恢复</a></p>\n<p><a href=\"https://docs.gitlab.com/ee/topics/git/migrate_to_git_lfs/index.html\" target=\"_blank\" rel=\"noopener\">Migrate a Git repo into Git LFS with BFG</a></p>\n<p><a href=\"https://www.hahack.com/work/enterprise-class-git-version-control-5/\" target=\"_blank\" rel=\"noopener\">化繁为简的企业级 Git 管理实战（五）：二进制大文件的版本控制</a></p>\n"},{"title":"关于串口调试自动化的解决方案","date":"2019-11-27T12:16:23.000Z","_content":"\n## 问题\n\n在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个\n\n- 重复命令手动输入执行\n- 交互性输入\n- 等待执行信息，不能自动保存到文件\n- 串口调试环境本身edit 便利性\n\n基于以上的问题，需要存在需求：\n\n- 可以将执行命令存放脚本中，而且可以去调用执行\n- 可处理交互性输入\n- 对于执行命令输出可以保存到 log 文件\n\n## 基本方案\n\n1. 基于 SecureCRT \n\n   SecureCRT 脚本，使用 python 语言\n\n   优点：\n\n   - GUI 界面，操作直观\n   - python syntax 语法特性支持强大\n\n   缺点：\n\n   - SecureCRT 过重，本身安装麻烦\n   - 仍然需要基本交互，SecureCRT 内调用脚本\n   - 与 jenkins 的集成\n\n2. 基于 Terminal 环境\n\n   首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。\n\n   其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）\n\n   最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。\n\n   优点：\n\n   - 轻量化，可通过命令行安装\n   - 所有过程都在 Terminal 操作\n   - 集成到 Jenkins，完全支持自动化流程\n\n   缺点：\n\n   - picocom 在功能性方面较弱\n\n##实际解决\n\n针对上面两种方案，如果是非重复性调试，使用前者上手更快。\n\n如果有需要多次重复性，或者自动化测试需求，选择后者。\n\n下面给出使用 Expect 的一个 demo：\n\n~~~tcl\n#!/usr/bin/expect \n# -d: debug mode\n\n# expect config\nset timeout 30\nlog_file test-expect.log\n\n# picocom config\nset baudrate \"115200\"\nset device \"/dev/ttyUSB0\"\nset prompt \"=>\"\n\n# function define\nset interval 5\nset iter_cnt 10\n\nproc start_xvr_debug { prompt } {\n    send \"xvr_client_dbus\\r\"\n    expect $prompt\n}\n\nproc test_switch_channel_display { iter_cnt interval prompt } {\n\n    for { set i 1 }  { $i < $iter_cnt } { incr i 1 } {\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n}\n\nproc test_start_stop_pipeline { iter_cnt interval prompt } {\n    for { set i 1 } { $i < $iter_cnt } { incr i 1 } {\n        send \"stop_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"stop_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n} \n\nspawn picocom -b $baudrate $device\nexpect \"Terminal ready\\r\"\nsend \"\\r\"\n\n# send \"xvr_client_dbus\\r\" \n# expect $prompt\n\nstart_xvr_debug $prompt\ntest_switch_channel_display $iter_cnt $interval $prompt \n# test_start_stop_pipeline $iter_cnt $interval $prompt \n\nexpect eof\n# interact\nwait\n~~~\n\n在具体使用中遇到的有几个小坑:\n\n1. 集成到 jenkins 时，jenkins 用户无法获得 `/dev/ttyUSB0` 权限。\n2. `sudo ` 执行 Expect 脚本进程 kill\n\n详情见尾注意小节。\n\n## 参考\n\n- [SecureCRT-python-scripts](https://blog.csdn.net/qq_14935437/article/details/78043904)\n- [Expect manual](https://linux.die.net/man/1/expect)\n- [Expect 使用教程](https://www.cnblogs.com/arlenhou/p/learn_expect.html)\n- [Expect interact & expect eof](https://blog.csdn.net/qq_20745901/article/details/54692610)\n\n## 注意\n\n1. 关于 jenkins 用户无法获取 `/dev/ttyUSB0` 权限\n\n   在这里最好不要直接使用 `sudo` ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。\n\n   解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。\n\n   ~~~bash\n   sudo usermod aG dialout jenkins\n   ~~~\n\n    \n\n2. sudo 执行的 expect 进程kill\n\n   `sudo killall -u USER expect `\n\n","source":"_posts/serial-port-debug-env-automation.md","raw":"---\ntitle: 关于串口调试自动化的解决方案\ndate: 2019-11-27 20:16:23\ntags:\n  - automation\n  - tool\ncategories:\n  - DevOps\n---\n\n## 问题\n\n在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个\n\n- 重复命令手动输入执行\n- 交互性输入\n- 等待执行信息，不能自动保存到文件\n- 串口调试环境本身edit 便利性\n\n基于以上的问题，需要存在需求：\n\n- 可以将执行命令存放脚本中，而且可以去调用执行\n- 可处理交互性输入\n- 对于执行命令输出可以保存到 log 文件\n\n## 基本方案\n\n1. 基于 SecureCRT \n\n   SecureCRT 脚本，使用 python 语言\n\n   优点：\n\n   - GUI 界面，操作直观\n   - python syntax 语法特性支持强大\n\n   缺点：\n\n   - SecureCRT 过重，本身安装麻烦\n   - 仍然需要基本交互，SecureCRT 内调用脚本\n   - 与 jenkins 的集成\n\n2. 基于 Terminal 环境\n\n   首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。\n\n   其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）\n\n   最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。\n\n   优点：\n\n   - 轻量化，可通过命令行安装\n   - 所有过程都在 Terminal 操作\n   - 集成到 Jenkins，完全支持自动化流程\n\n   缺点：\n\n   - picocom 在功能性方面较弱\n\n##实际解决\n\n针对上面两种方案，如果是非重复性调试，使用前者上手更快。\n\n如果有需要多次重复性，或者自动化测试需求，选择后者。\n\n下面给出使用 Expect 的一个 demo：\n\n~~~tcl\n#!/usr/bin/expect \n# -d: debug mode\n\n# expect config\nset timeout 30\nlog_file test-expect.log\n\n# picocom config\nset baudrate \"115200\"\nset device \"/dev/ttyUSB0\"\nset prompt \"=>\"\n\n# function define\nset interval 5\nset iter_cnt 10\n\nproc start_xvr_debug { prompt } {\n    send \"xvr_client_dbus\\r\"\n    expect $prompt\n}\n\nproc test_switch_channel_display { iter_cnt interval prompt } {\n\n    for { set i 1 }  { $i < $iter_cnt } { incr i 1 } {\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n}\n\nproc test_start_stop_pipeline { iter_cnt interval prompt } {\n    for { set i 1 } { $i < $iter_cnt } { incr i 1 } {\n        send \"stop_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"stop_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n} \n\nspawn picocom -b $baudrate $device\nexpect \"Terminal ready\\r\"\nsend \"\\r\"\n\n# send \"xvr_client_dbus\\r\" \n# expect $prompt\n\nstart_xvr_debug $prompt\ntest_switch_channel_display $iter_cnt $interval $prompt \n# test_start_stop_pipeline $iter_cnt $interval $prompt \n\nexpect eof\n# interact\nwait\n~~~\n\n在具体使用中遇到的有几个小坑:\n\n1. 集成到 jenkins 时，jenkins 用户无法获得 `/dev/ttyUSB0` 权限。\n2. `sudo ` 执行 Expect 脚本进程 kill\n\n详情见尾注意小节。\n\n## 参考\n\n- [SecureCRT-python-scripts](https://blog.csdn.net/qq_14935437/article/details/78043904)\n- [Expect manual](https://linux.die.net/man/1/expect)\n- [Expect 使用教程](https://www.cnblogs.com/arlenhou/p/learn_expect.html)\n- [Expect interact & expect eof](https://blog.csdn.net/qq_20745901/article/details/54692610)\n\n## 注意\n\n1. 关于 jenkins 用户无法获取 `/dev/ttyUSB0` 权限\n\n   在这里最好不要直接使用 `sudo` ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。\n\n   解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。\n\n   ~~~bash\n   sudo usermod aG dialout jenkins\n   ~~~\n\n    \n\n2. sudo 执行的 expect 进程kill\n\n   `sudo killall -u USER expect `\n\n","slug":"serial-port-debug-env-automation","published":1,"updated":"2019-11-27T12:16:37.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbh0002lon9inqib3st","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个</p>\n<ul>\n<li>重复命令手动输入执行</li>\n<li>交互性输入</li>\n<li>等待执行信息，不能自动保存到文件</li>\n<li>串口调试环境本身edit 便利性</li>\n</ul>\n<p>基于以上的问题，需要存在需求：</p>\n<ul>\n<li>可以将执行命令存放脚本中，而且可以去调用执行</li>\n<li>可处理交互性输入</li>\n<li>对于执行命令输出可以保存到 log 文件</li>\n</ul>\n<h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ol>\n<li><p>基于 SecureCRT </p>\n<p>SecureCRT 脚本，使用 python 语言</p>\n<p>优点：</p>\n<ul>\n<li>GUI 界面，操作直观</li>\n<li>python syntax 语法特性支持强大</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>SecureCRT 过重，本身安装麻烦</li>\n<li>仍然需要基本交互，SecureCRT 内调用脚本</li>\n<li>与 jenkins 的集成</li>\n</ul>\n</li>\n<li><p>基于 Terminal 环境</p>\n<p>首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。</p>\n<p>其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）</p>\n<p>最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。</p>\n<p>优点：</p>\n<ul>\n<li>轻量化，可通过命令行安装</li>\n<li>所有过程都在 Terminal 操作</li>\n<li>集成到 Jenkins，完全支持自动化流程</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>picocom 在功能性方面较弱</li>\n</ul>\n</li>\n</ol>\n<p>##实际解决</p>\n<p>针对上面两种方案，如果是非重复性调试，使用前者上手更快。</p>\n<p>如果有需要多次重复性，或者自动化测试需求，选择后者。</p>\n<p>下面给出使用 Expect 的一个 demo：</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/expect </span></span><br><span class=\"line\"><span class=\"comment\"># -d: debug mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># expect config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> timeout <span class=\"number\">30</span></span><br><span class=\"line\">log_file test-expect.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># picocom config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> baudrate <span class=\"string\">\"115200\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> device <span class=\"string\">\"/dev/ttyUSB0\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> prompt <span class=\"string\">\"=&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># function define</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> interval <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> iter_cnt <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> start_xvr_debug</span> &#123; prompt &#125; &#123;</span><br><span class=\"line\">    send <span class=\"string\">\"xvr_client_dbus\\r\"</span></span><br><span class=\"line\">    expect $prompt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">proc test_switch_channel_display &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125;  &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test_start_stop_pipeline</span> &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125; &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">spawn picocom -b $baudrate $device</span><br><span class=\"line\">expect <span class=\"string\">\"Terminal ready\\r\"</span></span><br><span class=\"line\">send <span class=\"string\">\"\\r\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send \"xvr_client_dbus\\r\" </span></span><br><span class=\"line\"><span class=\"comment\"># expect $prompt</span></span><br><span class=\"line\"></span><br><span class=\"line\">start_xvr_debug $prompt</span><br><span class=\"line\">test_switch_channel_display $iter_cnt $interval $prompt </span><br><span class=\"line\"><span class=\"comment\"># test_start_stop_pipeline $iter_cnt $interval $prompt </span></span><br><span class=\"line\"></span><br><span class=\"line\">expect <span class=\"keyword\">eof</span></span><br><span class=\"line\"><span class=\"comment\"># interact</span></span><br><span class=\"line\">wait</span><br></pre></td></tr></table></figure>\n<p>在具体使用中遇到的有几个小坑:</p>\n<ol>\n<li>集成到 jenkins 时，jenkins 用户无法获得 <code>/dev/ttyUSB0</code> 权限。</li>\n<li><code>sudo</code> 执行 Expect 脚本进程 kill</li>\n</ol>\n<p>详情见尾注意小节。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_14935437/article/details/78043904\" target=\"_blank\" rel=\"noopener\">SecureCRT-python-scripts</a></li>\n<li><a href=\"https://linux.die.net/man/1/expect\" target=\"_blank\" rel=\"noopener\">Expect manual</a></li>\n<li><a href=\"https://www.cnblogs.com/arlenhou/p/learn_expect.html\" target=\"_blank\" rel=\"noopener\">Expect 使用教程</a></li>\n<li><a href=\"https://blog.csdn.net/qq_20745901/article/details/54692610\" target=\"_blank\" rel=\"noopener\">Expect interact &amp; expect eof</a></li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li><p>关于 jenkins 用户无法获取 <code>/dev/ttyUSB0</code> 权限</p>\n<p>在这里最好不要直接使用 <code>sudo</code> ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。</p>\n<p>解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod aG dialout jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>sudo 执行的 expect 进程kill</p>\n<p><code>sudo killall -u USER expect</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个</p>\n<ul>\n<li>重复命令手动输入执行</li>\n<li>交互性输入</li>\n<li>等待执行信息，不能自动保存到文件</li>\n<li>串口调试环境本身edit 便利性</li>\n</ul>\n<p>基于以上的问题，需要存在需求：</p>\n<ul>\n<li>可以将执行命令存放脚本中，而且可以去调用执行</li>\n<li>可处理交互性输入</li>\n<li>对于执行命令输出可以保存到 log 文件</li>\n</ul>\n<h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ol>\n<li><p>基于 SecureCRT </p>\n<p>SecureCRT 脚本，使用 python 语言</p>\n<p>优点：</p>\n<ul>\n<li>GUI 界面，操作直观</li>\n<li>python syntax 语法特性支持强大</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>SecureCRT 过重，本身安装麻烦</li>\n<li>仍然需要基本交互，SecureCRT 内调用脚本</li>\n<li>与 jenkins 的集成</li>\n</ul>\n</li>\n<li><p>基于 Terminal 环境</p>\n<p>首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。</p>\n<p>其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）</p>\n<p>最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。</p>\n<p>优点：</p>\n<ul>\n<li>轻量化，可通过命令行安装</li>\n<li>所有过程都在 Terminal 操作</li>\n<li>集成到 Jenkins，完全支持自动化流程</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>picocom 在功能性方面较弱</li>\n</ul>\n</li>\n</ol>\n<p>##实际解决</p>\n<p>针对上面两种方案，如果是非重复性调试，使用前者上手更快。</p>\n<p>如果有需要多次重复性，或者自动化测试需求，选择后者。</p>\n<p>下面给出使用 Expect 的一个 demo：</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/expect </span></span><br><span class=\"line\"><span class=\"comment\"># -d: debug mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># expect config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> timeout <span class=\"number\">30</span></span><br><span class=\"line\">log_file test-expect.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># picocom config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> baudrate <span class=\"string\">\"115200\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> device <span class=\"string\">\"/dev/ttyUSB0\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> prompt <span class=\"string\">\"=&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># function define</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> interval <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> iter_cnt <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> start_xvr_debug</span> &#123; prompt &#125; &#123;</span><br><span class=\"line\">    send <span class=\"string\">\"xvr_client_dbus\\r\"</span></span><br><span class=\"line\">    expect $prompt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">proc test_switch_channel_display &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125;  &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test_start_stop_pipeline</span> &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125; &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">spawn picocom -b $baudrate $device</span><br><span class=\"line\">expect <span class=\"string\">\"Terminal ready\\r\"</span></span><br><span class=\"line\">send <span class=\"string\">\"\\r\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send \"xvr_client_dbus\\r\" </span></span><br><span class=\"line\"><span class=\"comment\"># expect $prompt</span></span><br><span class=\"line\"></span><br><span class=\"line\">start_xvr_debug $prompt</span><br><span class=\"line\">test_switch_channel_display $iter_cnt $interval $prompt </span><br><span class=\"line\"><span class=\"comment\"># test_start_stop_pipeline $iter_cnt $interval $prompt </span></span><br><span class=\"line\"></span><br><span class=\"line\">expect <span class=\"keyword\">eof</span></span><br><span class=\"line\"><span class=\"comment\"># interact</span></span><br><span class=\"line\">wait</span><br></pre></td></tr></table></figure>\n<p>在具体使用中遇到的有几个小坑:</p>\n<ol>\n<li>集成到 jenkins 时，jenkins 用户无法获得 <code>/dev/ttyUSB0</code> 权限。</li>\n<li><code>sudo</code> 执行 Expect 脚本进程 kill</li>\n</ol>\n<p>详情见尾注意小节。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_14935437/article/details/78043904\" target=\"_blank\" rel=\"noopener\">SecureCRT-python-scripts</a></li>\n<li><a href=\"https://linux.die.net/man/1/expect\" target=\"_blank\" rel=\"noopener\">Expect manual</a></li>\n<li><a href=\"https://www.cnblogs.com/arlenhou/p/learn_expect.html\" target=\"_blank\" rel=\"noopener\">Expect 使用教程</a></li>\n<li><a href=\"https://blog.csdn.net/qq_20745901/article/details/54692610\" target=\"_blank\" rel=\"noopener\">Expect interact &amp; expect eof</a></li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li><p>关于 jenkins 用户无法获取 <code>/dev/ttyUSB0</code> 权限</p>\n<p>在这里最好不要直接使用 <code>sudo</code> ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。</p>\n<p>解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod aG dialout jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>sudo 执行的 expect 进程kill</p>\n<p><code>sudo killall -u USER expect</code></p>\n</li>\n</ol>\n"},{"title":"打造一个完美的终端环境","toc":true,"comments":0,"date":"2019-11-27T13:21:22.000Z","_content":"\n\n> 日常的开发工作中，需要长时间面对 Terminal。如何让 Terminal 使用起来更加顺手，提高效率呢？\n>\n> \n\n![image-20191127211949189](https://blog-1252790741.cos.ap-shanghai.myqcloud.com/imgs/2019-11-27-131952.png)\n\n","source":"_drafts/build-perfect-terminal-env.md","raw":"---\ntitle: 打造一个完美的终端环境\ntoc: true\ncomments: false\ndate: 2019-11-27 21:21:22\ntags:\n---\n\n\n> 日常的开发工作中，需要长时间面对 Terminal。如何让 Terminal 使用起来更加顺手，提高效率呢？\n>\n> \n\n![image-20191127211949189](https://blog-1252790741.cos.ap-shanghai.myqcloud.com/imgs/2019-11-27-131952.png)\n\n","slug":"build-perfect-terminal-env","published":0,"updated":"2019-11-28T03:50:48.021Z","layout":"post","photos":[],"link":"","_id":"ck3mrzrbl0006lon9bai3zmdk","content":"<blockquote>\n<p>日常的开发工作中，需要长时间面对 Terminal。如何让 Terminal 使用起来更加顺手，提高效率呢？</p>\n</blockquote>\n<p><img src=\"https://blog-1252790741.cos.ap-shanghai.myqcloud.com/imgs/2019-11-27-131952.png\" alt=\"image-20191127211949189\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>日常的开发工作中，需要长时间面对 Terminal。如何让 Terminal 使用起来更加顺手，提高效率呢？</p>\n</blockquote>\n<p><img src=\"https://blog-1252790741.cos.ap-shanghai.myqcloud.com/imgs/2019-11-27-131952.png\" alt=\"image-20191127211949189\"></p>\n"},{"title":"如何写技术博客","toc":true,"comments":0,"date":"2019-11-27T15:00:30.000Z","_content":"\n\n> 我第一次接触萌生写技术博客的念头，应该是在大三的时期。那时候刚刚从机械转到计算机。刚开始的时候有许多概念啊，代码啊看不太懂，于是就开始疯狂百度，那时候 CSDN 气氛还蛮好，上面有许多非常棒的文章都来自个人博客。现在比较好一点的应该是掘金和简书吧。\n>\n> 总之，看到别人输出的内容之后，我感觉好像打开了一扇大门，有许多的想法和念头想要分享。去获得别人的反馈，然而作为一个菜鸡。当我开始写博客的时候却感觉什么地方都不对，又重新回去看别人是怎么写的。胡乱写了几篇之后，发现写好一篇技术博客好难。\n>\n> 一直到现在，我仍然觉得创作出一篇优质的技术博客仍是需要耗心费力的一件事情，不过，找到方法论，发现优秀博客的共性，能够写出一篇合格的博文也并非难事，这就是这篇博文产生的原因。\n\n\n\n## 关于技术博客的分类\n\n作为开发们来说，最常见的工作状态不是解决问题，就是在产生问题的路上。在使用 google 时候第一个开头的词儿很大概率是 how to。在开发者的打开的浏览器上最常见到的就是官方文档，博客，Stack Overflow。\n\n在看过无数篇质量参差不齐的博客后，我觉得技术博客可以分成以下几类：\n\n1.  细节型\n\n   所谓细节型，就是说博客所包含的信息量相对比较少，或者讨论的范围比较在细节之处。比如环境配置，语法细节这些地方，比如 Pycharm 如何配置 anaconda，c++ 如何初始化二维数组这些问题。\n\n   本身上来说，这些信息都是能够在官方文档，语法手册里面去找到的。信息量不大，较为琐碎，如果它能解决当前的问题，也挺好。但去写这些无疑问是浪费你的时间。\n\n2. 快速上手\n\n   这一类的博客比起第一种类型包含更多的信息量，经过一系列的步骤，完成一个小 demo，对博客中讨论的对象有一点初步的认识。\n\n3. 问题情境\n\n   在遇到一个具体的问题场景下，通过一些技术方案，或者多个工具的组合来解决一个具体问题。如果第二类的博客主题对象是某项技术，某个工具的话，那么第三种的情况更像是针对问题情境的技术解决方案。\n\n   它们的确会有一些类似，比如某工具就是专门解决某问题的。不过我觉得以问题情境为导向可以更加开阔一些。\n\n上面三种类型显然不能完全概况全部的情况，但我会认为 1，2 类型，通过阅读相关的技术文档都是可以被解决的。如果博客要有特殊的价值的话，多写第三类的文章会更好一点。","source":"_drafts/how-to-write-tech-blog.md","raw":"---\ntitle: 如何写技术博客\ntoc: true\ncomments: false\ndate: 2019-11-27 23:00:30\ntags:\n---\n\n\n> 我第一次接触萌生写技术博客的念头，应该是在大三的时期。那时候刚刚从机械转到计算机。刚开始的时候有许多概念啊，代码啊看不太懂，于是就开始疯狂百度，那时候 CSDN 气氛还蛮好，上面有许多非常棒的文章都来自个人博客。现在比较好一点的应该是掘金和简书吧。\n>\n> 总之，看到别人输出的内容之后，我感觉好像打开了一扇大门，有许多的想法和念头想要分享。去获得别人的反馈，然而作为一个菜鸡。当我开始写博客的时候却感觉什么地方都不对，又重新回去看别人是怎么写的。胡乱写了几篇之后，发现写好一篇技术博客好难。\n>\n> 一直到现在，我仍然觉得创作出一篇优质的技术博客仍是需要耗心费力的一件事情，不过，找到方法论，发现优秀博客的共性，能够写出一篇合格的博文也并非难事，这就是这篇博文产生的原因。\n\n\n\n## 关于技术博客的分类\n\n作为开发们来说，最常见的工作状态不是解决问题，就是在产生问题的路上。在使用 google 时候第一个开头的词儿很大概率是 how to。在开发者的打开的浏览器上最常见到的就是官方文档，博客，Stack Overflow。\n\n在看过无数篇质量参差不齐的博客后，我觉得技术博客可以分成以下几类：\n\n1.  细节型\n\n   所谓细节型，就是说博客所包含的信息量相对比较少，或者讨论的范围比较在细节之处。比如环境配置，语法细节这些地方，比如 Pycharm 如何配置 anaconda，c++ 如何初始化二维数组这些问题。\n\n   本身上来说，这些信息都是能够在官方文档，语法手册里面去找到的。信息量不大，较为琐碎，如果它能解决当前的问题，也挺好。但去写这些无疑问是浪费你的时间。\n\n2. 快速上手\n\n   这一类的博客比起第一种类型包含更多的信息量，经过一系列的步骤，完成一个小 demo，对博客中讨论的对象有一点初步的认识。\n\n3. 问题情境\n\n   在遇到一个具体的问题场景下，通过一些技术方案，或者多个工具的组合来解决一个具体问题。如果第二类的博客主题对象是某项技术，某个工具的话，那么第三种的情况更像是针对问题情境的技术解决方案。\n\n   它们的确会有一些类似，比如某工具就是专门解决某问题的。不过我觉得以问题情境为导向可以更加开阔一些。\n\n上面三种类型显然不能完全概况全部的情况，但我会认为 1，2 类型，通过阅读相关的技术文档都是可以被解决的。如果博客要有特殊的价值的话，多写第三类的文章会更好一点。","slug":"how-to-write-tech-blog","published":0,"updated":"2019-11-27T15:00:30.514Z","layout":"post","photos":[],"link":"","_id":"ck3mrzrbm0008lon9iw89p007","content":"<blockquote>\n<p>我第一次接触萌生写技术博客的念头，应该是在大三的时期。那时候刚刚从机械转到计算机。刚开始的时候有许多概念啊，代码啊看不太懂，于是就开始疯狂百度，那时候 CSDN 气氛还蛮好，上面有许多非常棒的文章都来自个人博客。现在比较好一点的应该是掘金和简书吧。</p>\n<p>总之，看到别人输出的内容之后，我感觉好像打开了一扇大门，有许多的想法和念头想要分享。去获得别人的反馈，然而作为一个菜鸡。当我开始写博客的时候却感觉什么地方都不对，又重新回去看别人是怎么写的。胡乱写了几篇之后，发现写好一篇技术博客好难。</p>\n<p>一直到现在，我仍然觉得创作出一篇优质的技术博客仍是需要耗心费力的一件事情，不过，找到方法论，发现优秀博客的共性，能够写出一篇合格的博文也并非难事，这就是这篇博文产生的原因。</p>\n</blockquote>\n<h2 id=\"关于技术博客的分类\"><a href=\"#关于技术博客的分类\" class=\"headerlink\" title=\"关于技术博客的分类\"></a>关于技术博客的分类</h2><p>作为开发们来说，最常见的工作状态不是解决问题，就是在产生问题的路上。在使用 google 时候第一个开头的词儿很大概率是 how to。在开发者的打开的浏览器上最常见到的就是官方文档，博客，Stack Overflow。</p>\n<p>在看过无数篇质量参差不齐的博客后，我觉得技术博客可以分成以下几类：</p>\n<ol>\n<li><p>细节型</p>\n<p>所谓细节型，就是说博客所包含的信息量相对比较少，或者讨论的范围比较在细节之处。比如环境配置，语法细节这些地方，比如 Pycharm 如何配置 anaconda，c++ 如何初始化二维数组这些问题。</p>\n<p>本身上来说，这些信息都是能够在官方文档，语法手册里面去找到的。信息量不大，较为琐碎，如果它能解决当前的问题，也挺好。但去写这些无疑问是浪费你的时间。</p>\n</li>\n<li><p>快速上手</p>\n<p>这一类的博客比起第一种类型包含更多的信息量，经过一系列的步骤，完成一个小 demo，对博客中讨论的对象有一点初步的认识。</p>\n</li>\n<li><p>问题情境</p>\n<p>在遇到一个具体的问题场景下，通过一些技术方案，或者多个工具的组合来解决一个具体问题。如果第二类的博客主题对象是某项技术，某个工具的话，那么第三种的情况更像是针对问题情境的技术解决方案。</p>\n<p>它们的确会有一些类似，比如某工具就是专门解决某问题的。不过我觉得以问题情境为导向可以更加开阔一些。</p>\n</li>\n</ol>\n<p>上面三种类型显然不能完全概况全部的情况，但我会认为 1，2 类型，通过阅读相关的技术文档都是可以被解决的。如果博客要有特殊的价值的话，多写第三类的文章会更好一点。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我第一次接触萌生写技术博客的念头，应该是在大三的时期。那时候刚刚从机械转到计算机。刚开始的时候有许多概念啊，代码啊看不太懂，于是就开始疯狂百度，那时候 CSDN 气氛还蛮好，上面有许多非常棒的文章都来自个人博客。现在比较好一点的应该是掘金和简书吧。</p>\n<p>总之，看到别人输出的内容之后，我感觉好像打开了一扇大门，有许多的想法和念头想要分享。去获得别人的反馈，然而作为一个菜鸡。当我开始写博客的时候却感觉什么地方都不对，又重新回去看别人是怎么写的。胡乱写了几篇之后，发现写好一篇技术博客好难。</p>\n<p>一直到现在，我仍然觉得创作出一篇优质的技术博客仍是需要耗心费力的一件事情，不过，找到方法论，发现优秀博客的共性，能够写出一篇合格的博文也并非难事，这就是这篇博文产生的原因。</p>\n</blockquote>\n<h2 id=\"关于技术博客的分类\"><a href=\"#关于技术博客的分类\" class=\"headerlink\" title=\"关于技术博客的分类\"></a>关于技术博客的分类</h2><p>作为开发们来说，最常见的工作状态不是解决问题，就是在产生问题的路上。在使用 google 时候第一个开头的词儿很大概率是 how to。在开发者的打开的浏览器上最常见到的就是官方文档，博客，Stack Overflow。</p>\n<p>在看过无数篇质量参差不齐的博客后，我觉得技术博客可以分成以下几类：</p>\n<ol>\n<li><p>细节型</p>\n<p>所谓细节型，就是说博客所包含的信息量相对比较少，或者讨论的范围比较在细节之处。比如环境配置，语法细节这些地方，比如 Pycharm 如何配置 anaconda，c++ 如何初始化二维数组这些问题。</p>\n<p>本身上来说，这些信息都是能够在官方文档，语法手册里面去找到的。信息量不大，较为琐碎，如果它能解决当前的问题，也挺好。但去写这些无疑问是浪费你的时间。</p>\n</li>\n<li><p>快速上手</p>\n<p>这一类的博客比起第一种类型包含更多的信息量，经过一系列的步骤，完成一个小 demo，对博客中讨论的对象有一点初步的认识。</p>\n</li>\n<li><p>问题情境</p>\n<p>在遇到一个具体的问题场景下，通过一些技术方案，或者多个工具的组合来解决一个具体问题。如果第二类的博客主题对象是某项技术，某个工具的话，那么第三种的情况更像是针对问题情境的技术解决方案。</p>\n<p>它们的确会有一些类似，比如某工具就是专门解决某问题的。不过我觉得以问题情境为导向可以更加开阔一些。</p>\n</li>\n</ol>\n<p>上面三种类型显然不能完全概况全部的情况，但我会认为 1，2 类型，通过阅读相关的技术文档都是可以被解决的。如果博客要有特殊的价值的话，多写第三类的文章会更好一点。</p>\n"},{"title":"Gitlab-Runer-Configuration","toc":true,"comments":0,"date":"2019-11-27T12:15:27.000Z","_content":"","source":"_drafts/gitlab-runer-configuration.md","raw":"---\ntitle: gitlab-runer-configuration\ntoc: true\ncomments: false\ndate: 2019-11-27 20:15:27\ntags:\n---\n","slug":"gitlab-runer-configuration","published":0,"updated":"2019-11-27T13:06:14.562Z","layout":"post","photos":[],"link":"","_id":"ck3mrzrbo000alon9l3npk54t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hexo-Config","date":"2019-11-26T09:51:46.000Z","_content":"","source":"_drafts/hexo-config.md","raw":"---\ntitle: hexo-config\ndate: 2019-11-26 17:51:46\ntags:\n---\n","slug":"hexo-config","published":0,"updated":"2019-11-27T12:15:54.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbr000elon9lfodai5m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"国内镜像源列表","_content":"\n> “Across the Great Wall, we can reach every corner in the world”\n\n[中科大源](https://mirrors.ustc.edu.cn/help/)\n\n[清华源](https://mirror.tuna.tsinghua.edu.cn/help/)\n\n[阿里源](https://developer.aliyun.com/mirror)","source":"_drafts/mirrors-of-china.md","raw":"---\ntitle: 国内镜像源列表\ntags:\n---\n\n> “Across the Great Wall, we can reach every corner in the world”\n\n[中科大源](https://mirrors.ustc.edu.cn/help/)\n\n[清华源](https://mirror.tuna.tsinghua.edu.cn/help/)\n\n[阿里源](https://developer.aliyun.com/mirror)","slug":"mirrors-of-china","published":0,"date":"2019-11-29T05:54:25.181Z","updated":"2019-11-29T06:00:37.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbt000flon94ho8wcd7","content":"<blockquote>\n<p>“Across the Great Wall, we can reach every corner in the world”</p>\n</blockquote>\n<p><a href=\"https://mirrors.ustc.edu.cn/help/\" target=\"_blank\" rel=\"noopener\">中科大源</a></p>\n<p><a href=\"https://mirror.tuna.tsinghua.edu.cn/help/\" target=\"_blank\" rel=\"noopener\">清华源</a></p>\n<p><a href=\"https://developer.aliyun.com/mirror\" target=\"_blank\" rel=\"noopener\">阿里源</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“Across the Great Wall, we can reach every corner in the world”</p>\n</blockquote>\n<p><a href=\"https://mirrors.ustc.edu.cn/help/\" target=\"_blank\" rel=\"noopener\">中科大源</a></p>\n<p><a href=\"https://mirror.tuna.tsinghua.edu.cn/help/\" target=\"_blank\" rel=\"noopener\">清华源</a></p>\n<p><a href=\"https://developer.aliyun.com/mirror\" target=\"_blank\" rel=\"noopener\">阿里源</a></p>\n"},{"title":"Postgres-Tutorial-Summary","_content":"\n> 本篇是针对 PostgreSQL tutorial 的总结\n>\n> [postgresqltutorial](http://www.postgresqltutorial.com/) 是一个非常好的入门文档，提供 `dvdrental` 数据库以及 E-R 图，可以尽情在上面操作与玩耍。\n\n~~~sql\n\t\t\t \n -- Json\n CREATE TABLE orders (\n   ID serial NOT NULL PRIMARY KEY,\n   info json NOT NULL\n);\n-- insert json data \nINSERT INTO orders (info)\nVALUES\n   (\n      '{ \"customer\": \"John Doe\", \"items\": {\"product\": \"Beer\",\"qty\": 6}}'\n   );\n-- insert multiple rows \nINSERT INTO orders (info)\nVALUES\n   (\n      '{ \"customer\": \"Lily Bush\", \"items\": {\"product\": \"Diaper\",\"qty\": 24}}'\n   ),\n   (\n      '{ \"customer\": \"Josh William\", \"items\": {\"product\": \"Toy Car\",\"qty\": 1}}'\n   ),\n   (\n      '{ \"customer\": \"Mary Clark\", \"items\": {\"product\": \"Toy Train\",\"qty\": 2}}'\n   );\n-- query json data\nSELECT info FROM orders;\n-- OPERATOR -> returns json object filed by key. \nSELECT info -> 'customer' FROM orders;\n-- The operator ->> returns JSON object field by text.\nSELECT info ->> 'customer' AS customer FROM orders;\n-- you can chain it with the operator ->> to retrieve a specific node\nSELECT info -> 'items' ->> 'product' AS product FROM orders ORDER BY product;\n-- Use JSON operator in WHERE clause\nSELECT info ->> 'customer' AS customer FROM orders WHERE info -> 'items' ->> 'product' = 'Diaper';\n-- find out who bought two products at a time\nSELECT info ->> 'customer' AS customer, info -> 'items' ->> 'product' AS product FROM orders \nWHERE CAST(info -> 'items' ->> 'qty' AS INTEGER) = 2\n-- Apply aggregate functions to JSON data\nSELECT min(CAST(info -> 'items' ->> 'qty' AS INTEGER)), \nmax(CAST(info -> 'items' ->> 'qty' AS INTEGER)),\nsum(CAST(info -> 'items' ->> 'qty' AS INTEGER)),\navg(CAST(info -> 'items' ->> 'qty' AS FLOAT))\nFROM orders;\n-- JSON functions\nSELECT json_each(info) FROM orders;\nSELECT json_object_keys(info->'items') FROM orders;\nSELECT json_typeof(info->'items') FROM orders;\n~~~\n\n","source":"_drafts/postgres-tutorial-summary.md","raw":"---\ntitle: postgres-tutorial-summary\ntags:\n---\n\n> 本篇是针对 PostgreSQL tutorial 的总结\n>\n> [postgresqltutorial](http://www.postgresqltutorial.com/) 是一个非常好的入门文档，提供 `dvdrental` 数据库以及 E-R 图，可以尽情在上面操作与玩耍。\n\n~~~sql\n\t\t\t \n -- Json\n CREATE TABLE orders (\n   ID serial NOT NULL PRIMARY KEY,\n   info json NOT NULL\n);\n-- insert json data \nINSERT INTO orders (info)\nVALUES\n   (\n      '{ \"customer\": \"John Doe\", \"items\": {\"product\": \"Beer\",\"qty\": 6}}'\n   );\n-- insert multiple rows \nINSERT INTO orders (info)\nVALUES\n   (\n      '{ \"customer\": \"Lily Bush\", \"items\": {\"product\": \"Diaper\",\"qty\": 24}}'\n   ),\n   (\n      '{ \"customer\": \"Josh William\", \"items\": {\"product\": \"Toy Car\",\"qty\": 1}}'\n   ),\n   (\n      '{ \"customer\": \"Mary Clark\", \"items\": {\"product\": \"Toy Train\",\"qty\": 2}}'\n   );\n-- query json data\nSELECT info FROM orders;\n-- OPERATOR -> returns json object filed by key. \nSELECT info -> 'customer' FROM orders;\n-- The operator ->> returns JSON object field by text.\nSELECT info ->> 'customer' AS customer FROM orders;\n-- you can chain it with the operator ->> to retrieve a specific node\nSELECT info -> 'items' ->> 'product' AS product FROM orders ORDER BY product;\n-- Use JSON operator in WHERE clause\nSELECT info ->> 'customer' AS customer FROM orders WHERE info -> 'items' ->> 'product' = 'Diaper';\n-- find out who bought two products at a time\nSELECT info ->> 'customer' AS customer, info -> 'items' ->> 'product' AS product FROM orders \nWHERE CAST(info -> 'items' ->> 'qty' AS INTEGER) = 2\n-- Apply aggregate functions to JSON data\nSELECT min(CAST(info -> 'items' ->> 'qty' AS INTEGER)), \nmax(CAST(info -> 'items' ->> 'qty' AS INTEGER)),\nsum(CAST(info -> 'items' ->> 'qty' AS INTEGER)),\navg(CAST(info -> 'items' ->> 'qty' AS FLOAT))\nFROM orders;\n-- JSON functions\nSELECT json_each(info) FROM orders;\nSELECT json_object_keys(info->'items') FROM orders;\nSELECT json_typeof(info->'items') FROM orders;\n~~~\n\n","slug":"postgres-tutorial-summary","published":0,"date":"2019-11-28T08:16:45.561Z","updated":"2019-11-29T02:55:50.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbu000ilon9yyoht7xi","content":"<blockquote>\n<p>本篇是针对 PostgreSQL tutorial 的总结</p>\n<p><a href=\"http://www.postgresqltutorial.com/\" target=\"_blank\" rel=\"noopener\">postgresqltutorial</a> 是一个非常好的入门文档，提供 <code>dvdrental</code> 数据库以及 E-R 图，可以尽情在上面操作与玩耍。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t </span><br><span class=\"line\"> <span class=\"comment\">-- Json</span></span><br><span class=\"line\"> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> orders (</span><br><span class=\"line\">   <span class=\"keyword\">ID</span> <span class=\"built_in\">serial</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span>,</span><br><span class=\"line\">   info <span class=\"keyword\">json</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- insert json data </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> orders (info)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"John Doe\", \"items\": &#123;\"product\": \"Beer\",\"qty\": 6&#125;&#125;'</span></span><br><span class=\"line\">   );</span><br><span class=\"line\"><span class=\"comment\">-- insert multiple rows </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> orders (info)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Lily Bush\", \"items\": &#123;\"product\": \"Diaper\",\"qty\": 24&#125;&#125;'</span></span><br><span class=\"line\">   ),</span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Josh William\", \"items\": &#123;\"product\": \"Toy Car\",\"qty\": 1&#125;&#125;'</span></span><br><span class=\"line\">   ),</span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Mary Clark\", \"items\": &#123;\"product\": \"Toy Train\",\"qty\": 2&#125;&#125;'</span></span><br><span class=\"line\">   );</span><br><span class=\"line\"><span class=\"comment\">-- query json data</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- OPERATOR -&gt; returns json object filed by key. </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- The operator -&gt;&gt; returns JSON object field by text.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- you can chain it with the operator -&gt;&gt; to retrieve a specific node</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> <span class=\"keyword\">AS</span> product <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> product;</span><br><span class=\"line\"><span class=\"comment\">-- Use JSON operator in WHERE clause</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> = <span class=\"string\">'Diaper'</span>;</span><br><span class=\"line\"><span class=\"comment\">-- find out who bought two products at a time</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer, info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> <span class=\"keyword\">AS</span> product <span class=\"keyword\">FROM</span> orders </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>) = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">-- Apply aggregate functions to JSON data</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">min</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)), </span><br><span class=\"line\"><span class=\"keyword\">max</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)),</span><br><span class=\"line\"><span class=\"keyword\">sum</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)),</span><br><span class=\"line\"><span class=\"keyword\">avg</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">FLOAT</span>))</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- JSON functions</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_each(info) <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_object_keys(info-&gt;<span class=\"string\">'items'</span>) <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_typeof(info-&gt;<span class=\"string\">'items'</span>) <span class=\"keyword\">FROM</span> orders;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇是针对 PostgreSQL tutorial 的总结</p>\n<p><a href=\"http://www.postgresqltutorial.com/\" target=\"_blank\" rel=\"noopener\">postgresqltutorial</a> 是一个非常好的入门文档，提供 <code>dvdrental</code> 数据库以及 E-R 图，可以尽情在上面操作与玩耍。</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t\t </span><br><span class=\"line\"> <span class=\"comment\">-- Json</span></span><br><span class=\"line\"> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> orders (</span><br><span class=\"line\">   <span class=\"keyword\">ID</span> <span class=\"built_in\">serial</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span>,</span><br><span class=\"line\">   info <span class=\"keyword\">json</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">-- insert json data </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> orders (info)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"John Doe\", \"items\": &#123;\"product\": \"Beer\",\"qty\": 6&#125;&#125;'</span></span><br><span class=\"line\">   );</span><br><span class=\"line\"><span class=\"comment\">-- insert multiple rows </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> orders (info)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Lily Bush\", \"items\": &#123;\"product\": \"Diaper\",\"qty\": 24&#125;&#125;'</span></span><br><span class=\"line\">   ),</span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Josh William\", \"items\": &#123;\"product\": \"Toy Car\",\"qty\": 1&#125;&#125;'</span></span><br><span class=\"line\">   ),</span><br><span class=\"line\">   (</span><br><span class=\"line\">      <span class=\"string\">'&#123; \"customer\": \"Mary Clark\", \"items\": &#123;\"product\": \"Toy Train\",\"qty\": 2&#125;&#125;'</span></span><br><span class=\"line\">   );</span><br><span class=\"line\"><span class=\"comment\">-- query json data</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- OPERATOR -&gt; returns json object filed by key. </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- The operator -&gt;&gt; returns JSON object field by text.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- you can chain it with the operator -&gt;&gt; to retrieve a specific node</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> <span class=\"keyword\">AS</span> product <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> product;</span><br><span class=\"line\"><span class=\"comment\">-- Use JSON operator in WHERE clause</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> = <span class=\"string\">'Diaper'</span>;</span><br><span class=\"line\"><span class=\"comment\">-- find out who bought two products at a time</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> info -&gt;&gt; <span class=\"string\">'customer'</span> <span class=\"keyword\">AS</span> customer, info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'product'</span> <span class=\"keyword\">AS</span> product <span class=\"keyword\">FROM</span> orders </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>) = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">-- Apply aggregate functions to JSON data</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">min</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)), </span><br><span class=\"line\"><span class=\"keyword\">max</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)),</span><br><span class=\"line\"><span class=\"keyword\">sum</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">INTEGER</span>)),</span><br><span class=\"line\"><span class=\"keyword\">avg</span>(<span class=\"keyword\">CAST</span>(info -&gt; <span class=\"string\">'items'</span> -&gt;&gt; <span class=\"string\">'qty'</span> <span class=\"keyword\">AS</span> <span class=\"built_in\">FLOAT</span>))</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"comment\">-- JSON functions</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_each(info) <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_object_keys(info-&gt;<span class=\"string\">'items'</span>) <span class=\"keyword\">FROM</span> orders;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> json_typeof(info-&gt;<span class=\"string\">'items'</span>) <span class=\"keyword\">FROM</span> orders;</span><br></pre></td></tr></table></figure>\n"},{"title":"Sql-Basic-Query-Collection","_content":"","source":"_drafts/sql-basic-query-collection.md","raw":"---\ntitle: sql-basic-query-collection\ntags:\n---\n","slug":"sql-basic-query-collection","published":0,"date":"2019-11-30T06:53:24.089Z","updated":"2019-11-30T06:53:24.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbv000jlon9g6qqdcub","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Using-Travis-Ci-Auto-Deploy-My-Blog","_content":"","source":"_drafts/using-travis-ci-auto-deploy-my-blog.md","raw":"---\ntitle: using-travis-ci-auto-deploy-my-blog\ntags:\n---\n","slug":"using-travis-ci-auto-deploy-my-blog","published":0,"date":"2019-11-28T03:23:33.826Z","updated":"2019-11-28T03:23:33.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrbw000llon911olsaar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"如何编写最佳的Dockerfile","toc":true,"comments":1,"date":"2019-12-01T08:29:15.000Z","_content":"\n\n> **译者按:** Dockerfile 的语法非常简单，然而如何加快镜像构建速度，如何减少 Docker 镜像的大小却不是那么直观，需要积累实践经验。这篇博客可以帮助你快速掌握编写 Dockerfile 的技巧。 \n>\n> - 原文: [How to write excellent Dockerfiles](https://rock-it.pl/how-to-write-excellent-dockerfiles/) \n> - 译者: [Fundebug](https://www.fundebug.com/) \n>\n> **本文采用意译，版权归原作者所有**\n\n我已经使用 Docker 有一段时间了，其中编写 Dockerfile 是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的 Dockerfile。\n\n### **目标:**\n\n- 更快的构建速度\n- 更小的 Docker 镜像大小\n- 更少的 Docker 镜像层\n- 充分利用镜像缓存\n- 增加 Dockerfile 可读性\n- 让 Docker 容器使用起来更简单\n\n### **总结**\n\n- 编写.dockerignore 文件\n- 容器只运行单个应用\n- 将多个 RUN 指令合并为一个\n- 基础镜像的标签不要用 latest\n- 每个 RUN 指令后删除多余文件\n- 选择合适的基础镜像(alpine 版本最好)\n- 设置 WORKDIR 和 CMD\n- 使用 ENTRYPOINT (可选)\n- 在 entrypoint 脚本中使用 exec\n- COPY 与 ADD 优先使用前者\n- 合理调整 COPY 与 RUN 的顺序\n- 设置默认的环境变量，映射端口和数据卷\n- 使用 LABEL 设置镜像元数据\n- 添加 HEALTHCHECK\n\n### **示例**\n\n示例 Dockerfile 犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用 Docker 运行一个 Node.js 应用，下面就是它的 Dockerfile(CMD 指令太复杂了，所以我简化了，它是错误的，仅供参考)。\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update\nRUN apt-get upgrade -y\nRUN apt-get install -y nodejs ssh mysql\nRUN cd /app && npm install\n\n# this should start three processes, mysql and ssh\n# in the background and node app in foreground\n# isn't it beautifully terrible? <3\nCMD mysql & sshd & npm start\n~~~\n\n构建镜像:\n\n`docker build -t wtf `  \n\n### **1. 编写.dockerignore 文件**\n\n构建镜像时，Docker 需要先准备context ，将所有需要的文件收集到进程中。默认的context包含 Dockerfile 目录中的所有文件，但是实际上，**我们并不需要.git 目录，node_modules 目录等内容**。 .dockerignore 的作用和语法类似于 .gitignore，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少 Docker 镜像的大小。示例如下: \n\n~~~\n.git/\nnode_modules/\ndist/\n~~~\n\n\n\n### **2. 容器只运行单个应用**\n\n从技术角度讲，你可以在 Docker 容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor 都运行在同一个 Docker 容器中。但是，这会让你非常痛苦:\n\n- 非常长的构建时间(修改前端之后，整个后端也需要重新构建)\n- 非常大的镜像大小\n- 多个应用的日志难以处理(不能直接使用 stdout，否则多个应用的日志会混合到一起)\n- 横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)\n- 僵尸进程问题 - 你需要选择合适的 init 进程\n\n因此，我建议大家为每个应用构建单独的 Docker 镜像，然后使用 [Docker Compose](https://docs.docker.com/compose/) 运行多个 Docker 容器。 \n\n现在，我从 Dockerfile 中删除一些不需要的安装包，另外，SSH 可以用[docker exec](https://docs.docker.com/engine/reference/commandline/exec/)替代。示例如下：\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update\nRUN apt-get upgrade -y\n\n# we should remove ssh and mysql, and use\n# separate container for database \nRUN apt-get install -y nodejs  # ssh mysql\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **3. 将多个 RUN 指令合并为一个**\n\nDocker 镜像是分层的，下面这些知识点非常重要:\n\n- Dockerfile 中的每个指令都会创建一个新的镜像层。\n- 镜像层将被缓存和复用\n- 当 Dockerfile 的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效\n- 某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效\n- 镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在 Docker 容器中不可见了)。\n\nDocker 镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。\n\n现在，我们**将所有的**[RUN](https://docs.docker.com/engine/reference/builder/#run)**指令合并为一个**。同时把apt-get upgrade删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update \\\n    && apt-get install -y nodejs \\\n    && cd /app \\\n    && npm install\n\nCMD npm start\n~~~\n\n记住一点，我们只能将变化频率一样的指令合并在一起。将 node.js 安装与 npm 模块安装放在一起的话，则每次修改源代码，都需要重新安装 node.js，这显然不合适。因此，正确的写法是这样的:\n\n~~~dockerfile\nFROM ubuntu\n\nRUN apt-get update && apt-get install -y nodejs \nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **4. 基础镜像的标签不要用 latest**\n\n当镜像没有指定标签时，将默认使用latest 标签。因此， FROM ubuntu 指令等同于FROM ubuntu:latest。当时，当镜像更新时，latest 标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签。 \n\n示例 Dockerfile 应该使用16.04作为标签。\n\n~~~dockerfile\nFROM ubuntu:16.04  # it's that easy!\n\nRUN apt-get update && apt-get install -y nodejs \nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **5. 每个 RUN 指令后删除多余文件**\n\n假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在/var/lib/apt/lists/目录中。但是，运行应用时 Docker 镜像中并不需要这些文件。我们最好将它们删除，因为它会使 Docker 镜像变大。\n\n示例 Dockerfile 中，我们可以删除/var/lib/apt/lists/目录中的文件(它们是由 apt-get update 生成的)。\n\n~~~dockerfile\nFROM ubuntu:16.04\n\nRUN apt-get update \\\n    && apt-get install -y nodejs \\\n    # added lines\n    && rm -rf /var/lib/apt/lists/*\n\nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **6. 选择合适的基础镜像(alpine 版本最好)**\n\n在示例中，我们选择了ubuntu作为基础镜像。但是我们只需要运行 node 程序，有必要使用一个通用的基础镜像吗？node镜像应该是更好的选择。\n\n~~~dockerfile\nFROM node\n\nADD . /app\n# we don't need to install node \n# anymore and use apt-get\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n更好的选择是 alpine 版本的node镜像。alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像。\n\n~~~dockerfile\nFROM node:7-alpine\n\nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n[apk](https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management)是 Alpine 的包管理工具。它与apt-get有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如no-cache和 --virtual选项，它们都可以帮助我们减少镜像的大小。 \n\n\n\n### **7. 设置 WORKDIR 和 CMD**\n\n[WORKDIR](https://docs.docker.com/engine/reference/builder/#workdir)指令可以设置默认目录，也就是运行RUN / CMD / ENTRYPOINT指令的地方。 \n\n[CMD](https://docs.docker.com/engine/reference/builder/#cmd)指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考[官方文档](https://docs.docker.com/engine/reference/builder/#cmd))。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\nADD . /app\nRUN npm install\n\nCMD [\"npm\", \"start\"]\n~~~\n\n\n\n### **8. 使用 ENTRYPOINT (可选)**\n\n[ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint)指令并不是必须的，因为它会增加复杂度。ENTRYPOINT是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的 Docker 镜像。entrypoint.sh 如下:\n\n~~~bash\n#!/usr/bin/env sh\n# $0 is a script name, \n# $1, $2, $3 etc are passed arguments\n# $1 is our command\nCMD=$1\n\ncase \"$CMD\" in\n  \"dev\" )\n    npm install\n    export NODE_ENV=development\n    exec npm run dev\n    ;;\n\n  \"start\" )\n    # we can modify files here, using ENV variables passed in \n    # \"docker create\" command. It can't be done during build process.\n    echo \"db: $DATABASE_ADDRESS\" >> /app/config.yml\n    export NODE_ENV=production\n    exec npm start\n    ;;\n\n   * )\n    # Run custom command. Thanks to this line we can still use \n    # \"docker run our_image /bin/bash\" and it will work\n    exec $CMD ${@:2}\n    ;;\nesac\n~~~\n\n示例 Dockerfile:\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\nADD . /app\nRUN npm install\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n可以使用如下命令运行该镜像:\n\n`docker run our-app dev`\n\n`docker run out-app start`\n\n`docker run -ti out-app /bin/bash` \n\n\n\n### **9. 在 entrypoint 脚本中使用 exec**\n\n在前文的 entrypoint 脚本中，我使用了exec命令运行 node 应用。不使用exec的话，我们则不能顺利地关闭容器，因为 SIGTERM 信号会被 bash 脚本进程吞没。exec命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。\n\n\n\n### **10. COPY 与 ADD 优先使用前者**\n\n[COPY](https://docs.docker.com/engine/reference/builder/#copy)指令非常简单，仅用于将文件拷贝到镜像中。[ADD](https://docs.docker.com/engine/reference/builder/#add)相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考[官方文档](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy))。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\n\nCOPY . /app\nRUN npm install\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n### **11. 合理调整 COPY 与 RUN 的顺序**\n\n我们应该**把变化最少的部分放在 Dockerfile 的前面**，这样可以充分利用镜像缓存。\n\n示例中，源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装 NPM 模块。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\n\nCOPY package.json /app\nRUN npm install\nCOPY . /app\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n### **12. 设置默认的环境变量，映射端口和数据卷**\n\n运行 Docker 容器时很可能需要一些环境变量。在 Dockerfile 设置默认的环境变量是一种很好的方式。另外，我们应该在 Dockerfile 中设置映射端口和数据卷。示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\n\n# env variables required during build\nENV PROJECT_DIR=/app\n\nWORKDIR $PROJECT_DIR\n\nCOPY package.json $PROJECT_DIR\nRUN npm install\nCOPY . $PROJECT_DIR\n\n# env variables that can change\n# volume and port settings\n# and defaults for our application\nENV MEDIA_DIR=/media \\\n    NODE_ENV=production \\\n    APP_PORT=3000\n\nVOLUME $MEDIA_DIR\nEXPOSE $APP_PORT\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n[ENV](https://docs.docker.com/engine/reference/builder/#env)指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用[ARG](https://docs.docker.com/engine/reference/builder/#arg)指令。\n\n### **13. 使用 LABEL 设置镜像元数据**\n\n使用[LABEL](https://docs.docker.com/engine/reference/builder/#label)指令，可以为镜像设置元数据，例如**镜像创建者**或者**镜像说明**。旧版的 Dockerfile 语法使用[MAINTAINER](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如[nvidia-docker](https://github.com/NVIDIA/nvidia-docker)需要用到`com.nvidia.volumes.needed`。\n\n示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\nLABEL maintainer \"jakub.skalecki@example.com\"\n...\n\n~~~\n\n\n\n### **14. 添加 HEALTHCHECK**\n\n运行容器时，可以指定--restart always选项。这样的话，容器崩溃时，Docker 守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用[HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck)指令可以让 Docker 周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回 0，否则返回 1。对 HEALTHCHECK 感兴趣的话，可以参考[这篇博客](https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/)。示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\nLABEL maintainer \"jakub.skalecki@example.com\"\n\nENV PROJECT_DIR=/app\nWORKDIR $PROJECT_DIR\n\nCOPY package.json $PROJECT_DIR\nRUN npm install\nCOPY . $PROJECT_DIR\n\nENV MEDIA_DIR=/media \\\n    NODE_ENV=production \\\n    APP_PORT=3000\n\nVOLUME $MEDIA_DIR\nEXPOSE $APP_PORT\nHEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n当请求失败时，`curl —fail` 命令返回非 0 状态。 \n\n### **对进一步了解的使用者**\n\n如果你想要了解更多，请参阅 [STOPSIGNAL](https://docs.docker.com/engine/reference/builder/#stopsignal), [ONBUILD](https://docs.docker.com/engine/reference/builder/#onbuild), 和 [SHELL](https://docs.docker.com/engine/reference/builder/#shell) 指令。还要提到在构建镜像中一个非常有用的指令 `--no-cache`  (特别是在 CI 服务器上)，以及` --squash` [here](https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental-only)).\n\n以上，Have fun :)\n\n\n\n\n","source":"_posts/how-to-write-excellent-dockerfile.md","raw":"---\ntitle: 如何编写最佳的Dockerfile\ntoc: true\ncomments: true\ntags:\n  - docker\ndate: 2019-12-01 16:29:15\n---\n\n\n> **译者按:** Dockerfile 的语法非常简单，然而如何加快镜像构建速度，如何减少 Docker 镜像的大小却不是那么直观，需要积累实践经验。这篇博客可以帮助你快速掌握编写 Dockerfile 的技巧。 \n>\n> - 原文: [How to write excellent Dockerfiles](https://rock-it.pl/how-to-write-excellent-dockerfiles/) \n> - 译者: [Fundebug](https://www.fundebug.com/) \n>\n> **本文采用意译，版权归原作者所有**\n\n我已经使用 Docker 有一段时间了，其中编写 Dockerfile 是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的 Dockerfile。\n\n### **目标:**\n\n- 更快的构建速度\n- 更小的 Docker 镜像大小\n- 更少的 Docker 镜像层\n- 充分利用镜像缓存\n- 增加 Dockerfile 可读性\n- 让 Docker 容器使用起来更简单\n\n### **总结**\n\n- 编写.dockerignore 文件\n- 容器只运行单个应用\n- 将多个 RUN 指令合并为一个\n- 基础镜像的标签不要用 latest\n- 每个 RUN 指令后删除多余文件\n- 选择合适的基础镜像(alpine 版本最好)\n- 设置 WORKDIR 和 CMD\n- 使用 ENTRYPOINT (可选)\n- 在 entrypoint 脚本中使用 exec\n- COPY 与 ADD 优先使用前者\n- 合理调整 COPY 与 RUN 的顺序\n- 设置默认的环境变量，映射端口和数据卷\n- 使用 LABEL 设置镜像元数据\n- 添加 HEALTHCHECK\n\n### **示例**\n\n示例 Dockerfile 犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用 Docker 运行一个 Node.js 应用，下面就是它的 Dockerfile(CMD 指令太复杂了，所以我简化了，它是错误的，仅供参考)。\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update\nRUN apt-get upgrade -y\nRUN apt-get install -y nodejs ssh mysql\nRUN cd /app && npm install\n\n# this should start three processes, mysql and ssh\n# in the background and node app in foreground\n# isn't it beautifully terrible? <3\nCMD mysql & sshd & npm start\n~~~\n\n构建镜像:\n\n`docker build -t wtf `  \n\n### **1. 编写.dockerignore 文件**\n\n构建镜像时，Docker 需要先准备context ，将所有需要的文件收集到进程中。默认的context包含 Dockerfile 目录中的所有文件，但是实际上，**我们并不需要.git 目录，node_modules 目录等内容**。 .dockerignore 的作用和语法类似于 .gitignore，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少 Docker 镜像的大小。示例如下: \n\n~~~\n.git/\nnode_modules/\ndist/\n~~~\n\n\n\n### **2. 容器只运行单个应用**\n\n从技术角度讲，你可以在 Docker 容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor 都运行在同一个 Docker 容器中。但是，这会让你非常痛苦:\n\n- 非常长的构建时间(修改前端之后，整个后端也需要重新构建)\n- 非常大的镜像大小\n- 多个应用的日志难以处理(不能直接使用 stdout，否则多个应用的日志会混合到一起)\n- 横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)\n- 僵尸进程问题 - 你需要选择合适的 init 进程\n\n因此，我建议大家为每个应用构建单独的 Docker 镜像，然后使用 [Docker Compose](https://docs.docker.com/compose/) 运行多个 Docker 容器。 \n\n现在，我从 Dockerfile 中删除一些不需要的安装包，另外，SSH 可以用[docker exec](https://docs.docker.com/engine/reference/commandline/exec/)替代。示例如下：\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update\nRUN apt-get upgrade -y\n\n# we should remove ssh and mysql, and use\n# separate container for database \nRUN apt-get install -y nodejs  # ssh mysql\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **3. 将多个 RUN 指令合并为一个**\n\nDocker 镜像是分层的，下面这些知识点非常重要:\n\n- Dockerfile 中的每个指令都会创建一个新的镜像层。\n- 镜像层将被缓存和复用\n- 当 Dockerfile 的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效\n- 某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效\n- 镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在 Docker 容器中不可见了)。\n\nDocker 镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。\n\n现在，我们**将所有的**[RUN](https://docs.docker.com/engine/reference/builder/#run)**指令合并为一个**。同时把apt-get upgrade删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)\n\n~~~dockerfile\nFROM ubuntu\n\nADD . /app\n\nRUN apt-get update \\\n    && apt-get install -y nodejs \\\n    && cd /app \\\n    && npm install\n\nCMD npm start\n~~~\n\n记住一点，我们只能将变化频率一样的指令合并在一起。将 node.js 安装与 npm 模块安装放在一起的话，则每次修改源代码，都需要重新安装 node.js，这显然不合适。因此，正确的写法是这样的:\n\n~~~dockerfile\nFROM ubuntu\n\nRUN apt-get update && apt-get install -y nodejs \nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **4. 基础镜像的标签不要用 latest**\n\n当镜像没有指定标签时，将默认使用latest 标签。因此， FROM ubuntu 指令等同于FROM ubuntu:latest。当时，当镜像更新时，latest 标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签。 \n\n示例 Dockerfile 应该使用16.04作为标签。\n\n~~~dockerfile\nFROM ubuntu:16.04  # it's that easy!\n\nRUN apt-get update && apt-get install -y nodejs \nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **5. 每个 RUN 指令后删除多余文件**\n\n假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在/var/lib/apt/lists/目录中。但是，运行应用时 Docker 镜像中并不需要这些文件。我们最好将它们删除，因为它会使 Docker 镜像变大。\n\n示例 Dockerfile 中，我们可以删除/var/lib/apt/lists/目录中的文件(它们是由 apt-get update 生成的)。\n\n~~~dockerfile\nFROM ubuntu:16.04\n\nRUN apt-get update \\\n    && apt-get install -y nodejs \\\n    # added lines\n    && rm -rf /var/lib/apt/lists/*\n\nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n\n\n### **6. 选择合适的基础镜像(alpine 版本最好)**\n\n在示例中，我们选择了ubuntu作为基础镜像。但是我们只需要运行 node 程序，有必要使用一个通用的基础镜像吗？node镜像应该是更好的选择。\n\n~~~dockerfile\nFROM node\n\nADD . /app\n# we don't need to install node \n# anymore and use apt-get\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n更好的选择是 alpine 版本的node镜像。alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像。\n\n~~~dockerfile\nFROM node:7-alpine\n\nADD . /app\nRUN cd /app && npm install\n\nCMD npm start\n~~~\n\n[apk](https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management)是 Alpine 的包管理工具。它与apt-get有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如no-cache和 --virtual选项，它们都可以帮助我们减少镜像的大小。 \n\n\n\n### **7. 设置 WORKDIR 和 CMD**\n\n[WORKDIR](https://docs.docker.com/engine/reference/builder/#workdir)指令可以设置默认目录，也就是运行RUN / CMD / ENTRYPOINT指令的地方。 \n\n[CMD](https://docs.docker.com/engine/reference/builder/#cmd)指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考[官方文档](https://docs.docker.com/engine/reference/builder/#cmd))。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\nADD . /app\nRUN npm install\n\nCMD [\"npm\", \"start\"]\n~~~\n\n\n\n### **8. 使用 ENTRYPOINT (可选)**\n\n[ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint)指令并不是必须的，因为它会增加复杂度。ENTRYPOINT是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的 Docker 镜像。entrypoint.sh 如下:\n\n~~~bash\n#!/usr/bin/env sh\n# $0 is a script name, \n# $1, $2, $3 etc are passed arguments\n# $1 is our command\nCMD=$1\n\ncase \"$CMD\" in\n  \"dev\" )\n    npm install\n    export NODE_ENV=development\n    exec npm run dev\n    ;;\n\n  \"start\" )\n    # we can modify files here, using ENV variables passed in \n    # \"docker create\" command. It can't be done during build process.\n    echo \"db: $DATABASE_ADDRESS\" >> /app/config.yml\n    export NODE_ENV=production\n    exec npm start\n    ;;\n\n   * )\n    # Run custom command. Thanks to this line we can still use \n    # \"docker run our_image /bin/bash\" and it will work\n    exec $CMD ${@:2}\n    ;;\nesac\n~~~\n\n示例 Dockerfile:\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\nADD . /app\nRUN npm install\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n可以使用如下命令运行该镜像:\n\n`docker run our-app dev`\n\n`docker run out-app start`\n\n`docker run -ti out-app /bin/bash` \n\n\n\n### **9. 在 entrypoint 脚本中使用 exec**\n\n在前文的 entrypoint 脚本中，我使用了exec命令运行 node 应用。不使用exec的话，我们则不能顺利地关闭容器，因为 SIGTERM 信号会被 bash 脚本进程吞没。exec命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。\n\n\n\n### **10. COPY 与 ADD 优先使用前者**\n\n[COPY](https://docs.docker.com/engine/reference/builder/#copy)指令非常简单，仅用于将文件拷贝到镜像中。[ADD](https://docs.docker.com/engine/reference/builder/#add)相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考[官方文档](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy))。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\n\nCOPY . /app\nRUN npm install\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n### **11. 合理调整 COPY 与 RUN 的顺序**\n\n我们应该**把变化最少的部分放在 Dockerfile 的前面**，这样可以充分利用镜像缓存。\n\n示例中，源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装 NPM 模块。\n\n~~~dockerfile\nFROM node:7-alpine\n\nWORKDIR /app\n\nCOPY package.json /app\nRUN npm install\nCOPY . /app\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n### **12. 设置默认的环境变量，映射端口和数据卷**\n\n运行 Docker 容器时很可能需要一些环境变量。在 Dockerfile 设置默认的环境变量是一种很好的方式。另外，我们应该在 Dockerfile 中设置映射端口和数据卷。示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\n\n# env variables required during build\nENV PROJECT_DIR=/app\n\nWORKDIR $PROJECT_DIR\n\nCOPY package.json $PROJECT_DIR\nRUN npm install\nCOPY . $PROJECT_DIR\n\n# env variables that can change\n# volume and port settings\n# and defaults for our application\nENV MEDIA_DIR=/media \\\n    NODE_ENV=production \\\n    APP_PORT=3000\n\nVOLUME $MEDIA_DIR\nEXPOSE $APP_PORT\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n\n\n[ENV](https://docs.docker.com/engine/reference/builder/#env)指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用[ARG](https://docs.docker.com/engine/reference/builder/#arg)指令。\n\n### **13. 使用 LABEL 设置镜像元数据**\n\n使用[LABEL](https://docs.docker.com/engine/reference/builder/#label)指令，可以为镜像设置元数据，例如**镜像创建者**或者**镜像说明**。旧版的 Dockerfile 语法使用[MAINTAINER](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如[nvidia-docker](https://github.com/NVIDIA/nvidia-docker)需要用到`com.nvidia.volumes.needed`。\n\n示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\nLABEL maintainer \"jakub.skalecki@example.com\"\n...\n\n~~~\n\n\n\n### **14. 添加 HEALTHCHECK**\n\n运行容器时，可以指定--restart always选项。这样的话，容器崩溃时，Docker 守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用[HEALTHCHECK](https://docs.docker.com/engine/reference/builder/#healthcheck)指令可以让 Docker 周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回 0，否则返回 1。对 HEALTHCHECK 感兴趣的话，可以参考[这篇博客](https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/)。示例如下:\n\n~~~dockerfile\nFROM node:7-alpine\nLABEL maintainer \"jakub.skalecki@example.com\"\n\nENV PROJECT_DIR=/app\nWORKDIR $PROJECT_DIR\n\nCOPY package.json $PROJECT_DIR\nRUN npm install\nCOPY . $PROJECT_DIR\n\nENV MEDIA_DIR=/media \\\n    NODE_ENV=production \\\n    APP_PORT=3000\n\nVOLUME $MEDIA_DIR\nEXPOSE $APP_PORT\nHEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1\n\nENTRYPOINT [\"./entrypoint.sh\"]\nCMD [\"start\"]\n~~~\n\n当请求失败时，`curl —fail` 命令返回非 0 状态。 \n\n### **对进一步了解的使用者**\n\n如果你想要了解更多，请参阅 [STOPSIGNAL](https://docs.docker.com/engine/reference/builder/#stopsignal), [ONBUILD](https://docs.docker.com/engine/reference/builder/#onbuild), 和 [SHELL](https://docs.docker.com/engine/reference/builder/#shell) 指令。还要提到在构建镜像中一个非常有用的指令 `--no-cache`  (特别是在 CI 服务器上)，以及` --squash` [here](https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental-only)).\n\n以上，Have fun :)\n\n\n\n\n","slug":"how-to-write-excellent-dockerfile","published":1,"updated":"2019-12-01T09:01:22.505Z","layout":"post","photos":[],"link":"","_id":"ck3mrzrc7000olon98wxddi5j","content":"<blockquote>\n<p><strong>译者按:</strong> Dockerfile 的语法非常简单，然而如何加快镜像构建速度，如何减少 Docker 镜像的大小却不是那么直观，需要积累实践经验。这篇博客可以帮助你快速掌握编写 Dockerfile 的技巧。 </p>\n<ul>\n<li>原文: <a href=\"https://rock-it.pl/how-to-write-excellent-dockerfiles/\" target=\"_blank\" rel=\"noopener\">How to write excellent Dockerfiles</a> </li>\n<li>译者: <a href=\"https://www.fundebug.com/\" target=\"_blank\" rel=\"noopener\">Fundebug</a> </li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n</blockquote>\n<p>我已经使用 Docker 有一段时间了，其中编写 Dockerfile 是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的 Dockerfile。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标:\"></a><strong>目标:</strong></h3><ul>\n<li>更快的构建速度</li>\n<li>更小的 Docker 镜像大小</li>\n<li>更少的 Docker 镜像层</li>\n<li>充分利用镜像缓存</li>\n<li>增加 Dockerfile 可读性</li>\n<li>让 Docker 容器使用起来更简单</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li>编写.dockerignore 文件</li>\n<li>容器只运行单个应用</li>\n<li>将多个 RUN 指令合并为一个</li>\n<li>基础镜像的标签不要用 latest</li>\n<li>每个 RUN 指令后删除多余文件</li>\n<li>选择合适的基础镜像(alpine 版本最好)</li>\n<li>设置 WORKDIR 和 CMD</li>\n<li>使用 ENTRYPOINT (可选)</li>\n<li>在 entrypoint 脚本中使用 exec</li>\n<li>COPY 与 ADD 优先使用前者</li>\n<li>合理调整 COPY 与 RUN 的顺序</li>\n<li>设置默认的环境变量，映射端口和数据卷</li>\n<li>使用 LABEL 设置镜像元数据</li>\n<li>添加 HEALTHCHECK</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a><strong>示例</strong></h3><p>示例 Dockerfile 犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用 Docker 运行一个 Node.js 应用，下面就是它的 Dockerfile(CMD 指令太复杂了，所以我简化了，它是错误的，仅供参考)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get upgrade -y</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get install -y nodejs ssh mysql</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># this should start three processes, mysql and ssh</span></span><br><span class=\"line\"><span class=\"comment\"># in the background and node app in foreground</span></span><br><span class=\"line\"><span class=\"comment\"># isn't it beautifully terrible? &lt;3</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> mysql &amp; sshd &amp; npm start</span></span><br></pre></td></tr></table></figure>\n<p>构建镜像:</p>\n<p><code>docker build -t wtf</code>  </p>\n<h3 id=\"1-编写-dockerignore-文件\"><a href=\"#1-编写-dockerignore-文件\" class=\"headerlink\" title=\"1. 编写.dockerignore 文件\"></a><strong>1. 编写.dockerignore 文件</strong></h3><p>构建镜像时，Docker 需要先准备context ，将所有需要的文件收集到进程中。默认的context包含 Dockerfile 目录中的所有文件，但是实际上，<strong>我们并不需要.git 目录，node_modules 目录等内容</strong>。 .dockerignore 的作用和语法类似于 .gitignore，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少 Docker 镜像的大小。示例如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.git/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">dist/</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-容器只运行单个应用\"><a href=\"#2-容器只运行单个应用\" class=\"headerlink\" title=\"2. 容器只运行单个应用\"></a><strong>2. 容器只运行单个应用</strong></h3><p>从技术角度讲，你可以在 Docker 容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor 都运行在同一个 Docker 容器中。但是，这会让你非常痛苦:</p>\n<ul>\n<li>非常长的构建时间(修改前端之后，整个后端也需要重新构建)</li>\n<li>非常大的镜像大小</li>\n<li>多个应用的日志难以处理(不能直接使用 stdout，否则多个应用的日志会混合到一起)</li>\n<li>横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)</li>\n<li>僵尸进程问题 - 你需要选择合适的 init 进程</li>\n</ul>\n<p>因此，我建议大家为每个应用构建单独的 Docker 镜像，然后使用 <a href=\"https://docs.docker.com/compose/\" target=\"_blank\" rel=\"noopener\">Docker Compose</a> 运行多个 Docker 容器。 </p>\n<p>现在，我从 Dockerfile 中删除一些不需要的安装包，另外，SSH 可以用<a href=\"https://docs.docker.com/engine/reference/commandline/exec/\" target=\"_blank\" rel=\"noopener\">docker exec</a>替代。示例如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get upgrade -y</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># we should remove ssh and mysql, and use</span></span><br><span class=\"line\"><span class=\"comment\"># separate container for database </span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get install -y nodejs  <span class=\"comment\"># ssh mysql</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将多个-RUN-指令合并为一个\"><a href=\"#3-将多个-RUN-指令合并为一个\" class=\"headerlink\" title=\"3. 将多个 RUN 指令合并为一个\"></a><strong>3. 将多个 RUN 指令合并为一个</strong></h3><p>Docker 镜像是分层的，下面这些知识点非常重要:</p>\n<ul>\n<li>Dockerfile 中的每个指令都会创建一个新的镜像层。</li>\n<li>镜像层将被缓存和复用</li>\n<li>当 Dockerfile 的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li>\n<li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li>\n<li>镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在 Docker 容器中不可见了)。</li>\n</ul>\n<p>Docker 镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。</p>\n<p>现在，我们<strong>将所有的</strong><a href=\"https://docs.docker.com/engine/reference/builder/#run\" target=\"_blank\" rel=\"noopener\">RUN</a><strong>指令合并为一个</strong>。同时把apt-get upgrade删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; apt-get install -y nodejs \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; <span class=\"built_in\">cd</span> /app \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p>记住一点，我们只能将变化频率一样的指令合并在一起。将 node.js 安装与 npm 模块安装放在一起的话，则每次修改源代码，都需要重新安装 node.js，这显然不合适。因此，正确的写法是这样的:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y nodejs </span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-基础镜像的标签不要用-latest\"><a href=\"#4-基础镜像的标签不要用-latest\" class=\"headerlink\" title=\"4. 基础镜像的标签不要用 latest\"></a><strong>4. 基础镜像的标签不要用 latest</strong></h3><p>当镜像没有指定标签时，将默认使用latest 标签。因此， FROM ubuntu 指令等同于FROM ubuntu:latest。当时，当镜像更新时，latest 标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签。 </p>\n<p>示例 Dockerfile 应该使用16.04作为标签。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">16.04</span>  <span class=\"comment\"># it's that easy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y nodejs </span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-每个-RUN-指令后删除多余文件\"><a href=\"#5-每个-RUN-指令后删除多余文件\" class=\"headerlink\" title=\"5. 每个 RUN 指令后删除多余文件\"></a><strong>5. 每个 RUN 指令后删除多余文件</strong></h3><p>假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在/var/lib/apt/lists/目录中。但是，运行应用时 Docker 镜像中并不需要这些文件。我们最好将它们删除，因为它会使 Docker 镜像变大。</p>\n<p>示例 Dockerfile 中，我们可以删除/var/lib/apt/lists/目录中的文件(它们是由 apt-get update 生成的)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">16.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; apt-get install -y nodejs \\</span></span><br><span class=\"line\"><span class=\"bash\">    <span class=\"comment\"># added lines</span></span></span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-选择合适的基础镜像-alpine-版本最好\"><a href=\"#6-选择合适的基础镜像-alpine-版本最好\" class=\"headerlink\" title=\"6. 选择合适的基础镜像(alpine 版本最好)\"></a><strong>6. 选择合适的基础镜像(alpine 版本最好)</strong></h3><p>在示例中，我们选择了ubuntu作为基础镜像。但是我们只需要运行 node 程序，有必要使用一个通用的基础镜像吗？node镜像应该是更好的选择。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"comment\"># we don't need to install node </span></span><br><span class=\"line\"><span class=\"comment\"># anymore and use apt-get</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p>更好的选择是 alpine 版本的node镜像。alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management\" target=\"_blank\" rel=\"noopener\">apk</a>是 Alpine 的包管理工具。它与apt-get有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如no-cache和 –virtual选项，它们都可以帮助我们减少镜像的大小。 </p>\n<h3 id=\"7-设置-WORKDIR-和-CMD\"><a href=\"#7-设置-WORKDIR-和-CMD\" class=\"headerlink\" title=\"7. 设置 WORKDIR 和 CMD\"></a><strong>7. 设置 WORKDIR 和 CMD</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#workdir\" target=\"_blank\" rel=\"noopener\">WORKDIR</a>指令可以设置默认目录，也就是运行RUN / CMD / ENTRYPOINT指令的地方。 </p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#cmd\" target=\"_blank\" rel=\"noopener\">CMD</a>指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考<a href=\"https://docs.docker.com/engine/reference/builder/#cmd\" target=\"_blank\" rel=\"noopener\">官方文档</a>)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"npm\"</span>, <span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-使用-ENTRYPOINT-可选\"><a href=\"#8-使用-ENTRYPOINT-可选\" class=\"headerlink\" title=\"8. 使用 ENTRYPOINT (可选)\"></a><strong>8. 使用 ENTRYPOINT (可选)</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#entrypoint\" target=\"_blank\" rel=\"noopener\">ENTRYPOINT</a>指令并不是必须的，因为它会增加复杂度。ENTRYPOINT是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的 Docker 镜像。entrypoint.sh 如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env sh</span></span><br><span class=\"line\"><span class=\"comment\"># $0 is a script name, </span></span><br><span class=\"line\"><span class=\"comment\"># $1, $2, $3 etc are passed arguments</span></span><br><span class=\"line\"><span class=\"comment\"># $1 is our command</span></span><br><span class=\"line\">CMD=<span class=\"variable\">$1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$CMD</span>\"</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">  <span class=\"string\">\"dev\"</span> )</span><br><span class=\"line\">    npm install</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_ENV=development</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> npm run dev</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">\"start\"</span> )</span><br><span class=\"line\">    <span class=\"comment\"># we can modify files here, using ENV variables passed in </span></span><br><span class=\"line\">    <span class=\"comment\"># \"docker create\" command. It can't be done during build process.</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"db: <span class=\"variable\">$DATABASE_ADDRESS</span>\"</span> &gt;&gt; /app/config.yml</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_ENV=production</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> npm start</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">   * )</span><br><span class=\"line\">    <span class=\"comment\"># Run custom command. Thanks to this line we can still use </span></span><br><span class=\"line\">    <span class=\"comment\"># \"docker run our_image /bin/bash\" and it will work</span></span><br><span class=\"line\">    <span class=\"built_in\">exec</span> <span class=\"variable\">$CMD</span> <span class=\"variable\">$&#123;@:2&#125;</span></span><br><span class=\"line\">    ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n<p>示例 Dockerfile:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>可以使用如下命令运行该镜像:</p>\n<p><code>docker run our-app dev</code></p>\n<p><code>docker run out-app start</code></p>\n<p><code>docker run -ti out-app /bin/bash</code> </p>\n<h3 id=\"9-在-entrypoint-脚本中使用-exec\"><a href=\"#9-在-entrypoint-脚本中使用-exec\" class=\"headerlink\" title=\"9. 在 entrypoint 脚本中使用 exec\"></a><strong>9. 在 entrypoint 脚本中使用 exec</strong></h3><p>在前文的 entrypoint 脚本中，我使用了exec命令运行 node 应用。不使用exec的话，我们则不能顺利地关闭容器，因为 SIGTERM 信号会被 bash 脚本进程吞没。exec命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。</p>\n<h3 id=\"10-COPY-与-ADD-优先使用前者\"><a href=\"#10-COPY-与-ADD-优先使用前者\" class=\"headerlink\" title=\"10. COPY 与 ADD 优先使用前者\"></a><strong>10. COPY 与 ADD 优先使用前者</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#copy\" target=\"_blank\" rel=\"noopener\">COPY</a>指令非常简单，仅用于将文件拷贝到镜像中。<a href=\"https://docs.docker.com/engine/reference/builder/#add\" target=\"_blank\" rel=\"noopener\">ADD</a>相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考<a href=\"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy\" target=\"_blank\" rel=\"noopener\">官方文档</a>)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-合理调整-COPY-与-RUN-的顺序\"><a href=\"#11-合理调整-COPY-与-RUN-的顺序\" class=\"headerlink\" title=\"11. 合理调整 COPY 与 RUN 的顺序\"></a><strong>11. 合理调整 COPY 与 RUN 的顺序</strong></h3><p>我们应该<strong>把变化最少的部分放在 Dockerfile 的前面</strong>，这样可以充分利用镜像缓存。</p>\n<p>示例中，源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装 NPM 模块。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"12-设置默认的环境变量，映射端口和数据卷\"><a href=\"#12-设置默认的环境变量，映射端口和数据卷\" class=\"headerlink\" title=\"12. 设置默认的环境变量，映射端口和数据卷\"></a><strong>12. 设置默认的环境变量，映射端口和数据卷</strong></h3><p>运行 Docker 容器时很可能需要一些环境变量。在 Dockerfile 设置默认的环境变量是一种很好的方式。另外，我们应该在 Dockerfile 中设置映射端口和数据卷。示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># env variables required during build</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PROJECT_DIR=/app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># env variables that can change</span></span><br><span class=\"line\"><span class=\"comment\"># volume and port settings</span></span><br><span class=\"line\"><span class=\"comment\"># and defaults for our application</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MEDIA_DIR=/media \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    APP_PORT=<span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> <span class=\"variable\">$MEDIA_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> $APP_PORT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#env\" target=\"_blank\" rel=\"noopener\">ENV</a>指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用<a href=\"https://docs.docker.com/engine/reference/builder/#arg\" target=\"_blank\" rel=\"noopener\">ARG</a>指令。</p>\n<h3 id=\"13-使用-LABEL-设置镜像元数据\"><a href=\"#13-使用-LABEL-设置镜像元数据\" class=\"headerlink\" title=\"13. 使用 LABEL 设置镜像元数据\"></a><strong>13. 使用 LABEL 设置镜像元数据</strong></h3><p>使用<a href=\"https://docs.docker.com/engine/reference/builder/#label\" target=\"_blank\" rel=\"noopener\">LABEL</a>指令，可以为镜像设置元数据，例如<strong>镜像创建者</strong>或者<strong>镜像说明</strong>。旧版的 Dockerfile 语法使用<a href=\"https://docs.docker.com/engine/reference/builder/#maintainer-deprecated\" target=\"_blank\" rel=\"noopener\">MAINTAINER</a>指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如<a href=\"https://github.com/NVIDIA/nvidia-docker\" target=\"_blank\" rel=\"noopener\">nvidia-docker</a>需要用到<code>com.nvidia.volumes.needed</code>。</p>\n<p>示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"bash\"> maintainer <span class=\"string\">\"jakub.skalecki@example.com\"</span></span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-添加-HEALTHCHECK\"><a href=\"#14-添加-HEALTHCHECK\" class=\"headerlink\" title=\"14. 添加 HEALTHCHECK\"></a><strong>14. 添加 HEALTHCHECK</strong></h3><p>运行容器时，可以指定–restart always选项。这样的话，容器崩溃时，Docker 守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用<a href=\"https://docs.docker.com/engine/reference/builder/#healthcheck\" target=\"_blank\" rel=\"noopener\">HEALTHCHECK</a>指令可以让 Docker 周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回 0，否则返回 1。对 HEALTHCHECK 感兴趣的话，可以参考<a href=\"https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>。示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"bash\"> maintainer <span class=\"string\">\"jakub.skalecki@example.com\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PROJECT_DIR=/app</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MEDIA_DIR=/media \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    APP_PORT=<span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> <span class=\"variable\">$MEDIA_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> $APP_PORT</span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"bash\"> CMD curl --fail http://localhost:<span class=\"variable\">$APP_PORT</span> || <span class=\"built_in\">exit</span> 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>当请求失败时，<code>curl —fail</code> 命令返回非 0 状态。 </p>\n<h3 id=\"对进一步了解的使用者\"><a href=\"#对进一步了解的使用者\" class=\"headerlink\" title=\"对进一步了解的使用者\"></a><strong>对进一步了解的使用者</strong></h3><p>如果你想要了解更多，请参阅 <a href=\"https://docs.docker.com/engine/reference/builder/#stopsignal\" target=\"_blank\" rel=\"noopener\">STOPSIGNAL</a>, <a href=\"https://docs.docker.com/engine/reference/builder/#onbuild\" target=\"_blank\" rel=\"noopener\">ONBUILD</a>, 和 <a href=\"https://docs.docker.com/engine/reference/builder/#shell\" target=\"_blank\" rel=\"noopener\">SHELL</a> 指令。还要提到在构建镜像中一个非常有用的指令 <code>--no-cache</code>  (特别是在 CI 服务器上)，以及<code>--squash</code> <a href=\"https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental-only\" target=\"_blank\" rel=\"noopener\">here</a>).</p>\n<p>以上，Have fun :)</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>译者按:</strong> Dockerfile 的语法非常简单，然而如何加快镜像构建速度，如何减少 Docker 镜像的大小却不是那么直观，需要积累实践经验。这篇博客可以帮助你快速掌握编写 Dockerfile 的技巧。 </p>\n<ul>\n<li>原文: <a href=\"https://rock-it.pl/how-to-write-excellent-dockerfiles/\" target=\"_blank\" rel=\"noopener\">How to write excellent Dockerfiles</a> </li>\n<li>译者: <a href=\"https://www.fundebug.com/\" target=\"_blank\" rel=\"noopener\">Fundebug</a> </li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n</blockquote>\n<p>我已经使用 Docker 有一段时间了，其中编写 Dockerfile 是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的 Dockerfile。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标:\"></a><strong>目标:</strong></h3><ul>\n<li>更快的构建速度</li>\n<li>更小的 Docker 镜像大小</li>\n<li>更少的 Docker 镜像层</li>\n<li>充分利用镜像缓存</li>\n<li>增加 Dockerfile 可读性</li>\n<li>让 Docker 容器使用起来更简单</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li>编写.dockerignore 文件</li>\n<li>容器只运行单个应用</li>\n<li>将多个 RUN 指令合并为一个</li>\n<li>基础镜像的标签不要用 latest</li>\n<li>每个 RUN 指令后删除多余文件</li>\n<li>选择合适的基础镜像(alpine 版本最好)</li>\n<li>设置 WORKDIR 和 CMD</li>\n<li>使用 ENTRYPOINT (可选)</li>\n<li>在 entrypoint 脚本中使用 exec</li>\n<li>COPY 与 ADD 优先使用前者</li>\n<li>合理调整 COPY 与 RUN 的顺序</li>\n<li>设置默认的环境变量，映射端口和数据卷</li>\n<li>使用 LABEL 设置镜像元数据</li>\n<li>添加 HEALTHCHECK</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a><strong>示例</strong></h3><p>示例 Dockerfile 犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用 Docker 运行一个 Node.js 应用，下面就是它的 Dockerfile(CMD 指令太复杂了，所以我简化了，它是错误的，仅供参考)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get upgrade -y</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get install -y nodejs ssh mysql</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># this should start three processes, mysql and ssh</span></span><br><span class=\"line\"><span class=\"comment\"># in the background and node app in foreground</span></span><br><span class=\"line\"><span class=\"comment\"># isn't it beautifully terrible? &lt;3</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> mysql &amp; sshd &amp; npm start</span></span><br></pre></td></tr></table></figure>\n<p>构建镜像:</p>\n<p><code>docker build -t wtf</code>  </p>\n<h3 id=\"1-编写-dockerignore-文件\"><a href=\"#1-编写-dockerignore-文件\" class=\"headerlink\" title=\"1. 编写.dockerignore 文件\"></a><strong>1. 编写.dockerignore 文件</strong></h3><p>构建镜像时，Docker 需要先准备context ，将所有需要的文件收集到进程中。默认的context包含 Dockerfile 目录中的所有文件，但是实际上，<strong>我们并不需要.git 目录，node_modules 目录等内容</strong>。 .dockerignore 的作用和语法类似于 .gitignore，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少 Docker 镜像的大小。示例如下: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.git/</span><br><span class=\"line\">node_modules/</span><br><span class=\"line\">dist/</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-容器只运行单个应用\"><a href=\"#2-容器只运行单个应用\" class=\"headerlink\" title=\"2. 容器只运行单个应用\"></a><strong>2. 容器只运行单个应用</strong></h3><p>从技术角度讲，你可以在 Docker 容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor 都运行在同一个 Docker 容器中。但是，这会让你非常痛苦:</p>\n<ul>\n<li>非常长的构建时间(修改前端之后，整个后端也需要重新构建)</li>\n<li>非常大的镜像大小</li>\n<li>多个应用的日志难以处理(不能直接使用 stdout，否则多个应用的日志会混合到一起)</li>\n<li>横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)</li>\n<li>僵尸进程问题 - 你需要选择合适的 init 进程</li>\n</ul>\n<p>因此，我建议大家为每个应用构建单独的 Docker 镜像，然后使用 <a href=\"https://docs.docker.com/compose/\" target=\"_blank\" rel=\"noopener\">Docker Compose</a> 运行多个 Docker 容器。 </p>\n<p>现在，我从 Dockerfile 中删除一些不需要的安装包，另外，SSH 可以用<a href=\"https://docs.docker.com/engine/reference/commandline/exec/\" target=\"_blank\" rel=\"noopener\">docker exec</a>替代。示例如下：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get upgrade -y</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># we should remove ssh and mysql, and use</span></span><br><span class=\"line\"><span class=\"comment\"># separate container for database </span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get install -y nodejs  <span class=\"comment\"># ssh mysql</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-将多个-RUN-指令合并为一个\"><a href=\"#3-将多个-RUN-指令合并为一个\" class=\"headerlink\" title=\"3. 将多个 RUN 指令合并为一个\"></a><strong>3. 将多个 RUN 指令合并为一个</strong></h3><p>Docker 镜像是分层的，下面这些知识点非常重要:</p>\n<ul>\n<li>Dockerfile 中的每个指令都会创建一个新的镜像层。</li>\n<li>镜像层将被缓存和复用</li>\n<li>当 Dockerfile 的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li>\n<li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li>\n<li>镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在 Docker 容器中不可见了)。</li>\n</ul>\n<p>Docker 镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。</p>\n<p>现在，我们<strong>将所有的</strong><a href=\"https://docs.docker.com/engine/reference/builder/#run\" target=\"_blank\" rel=\"noopener\">RUN</a><strong>指令合并为一个</strong>。同时把apt-get upgrade删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; apt-get install -y nodejs \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; <span class=\"built_in\">cd</span> /app \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p>记住一点，我们只能将变化频率一样的指令合并在一起。将 node.js 安装与 npm 模块安装放在一起的话，则每次修改源代码，都需要重新安装 node.js，这显然不合适。因此，正确的写法是这样的:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y nodejs </span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-基础镜像的标签不要用-latest\"><a href=\"#4-基础镜像的标签不要用-latest\" class=\"headerlink\" title=\"4. 基础镜像的标签不要用 latest\"></a><strong>4. 基础镜像的标签不要用 latest</strong></h3><p>当镜像没有指定标签时，将默认使用latest 标签。因此， FROM ubuntu 指令等同于FROM ubuntu:latest。当时，当镜像更新时，latest 标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签。 </p>\n<p>示例 Dockerfile 应该使用16.04作为标签。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">16.04</span>  <span class=\"comment\"># it's that easy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y nodejs </span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-每个-RUN-指令后删除多余文件\"><a href=\"#5-每个-RUN-指令后删除多余文件\" class=\"headerlink\" title=\"5. 每个 RUN 指令后删除多余文件\"></a><strong>5. 每个 RUN 指令后删除多余文件</strong></h3><p>假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在/var/lib/apt/lists/目录中。但是，运行应用时 Docker 镜像中并不需要这些文件。我们最好将它们删除，因为它会使 Docker 镜像变大。</p>\n<p>示例 Dockerfile 中，我们可以删除/var/lib/apt/lists/目录中的文件(它们是由 apt-get update 生成的)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">16.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; apt-get install -y nodejs \\</span></span><br><span class=\"line\"><span class=\"bash\">    <span class=\"comment\"># added lines</span></span></span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-选择合适的基础镜像-alpine-版本最好\"><a href=\"#6-选择合适的基础镜像-alpine-版本最好\" class=\"headerlink\" title=\"6. 选择合适的基础镜像(alpine 版本最好)\"></a><strong>6. 选择合适的基础镜像(alpine 版本最好)</strong></h3><p>在示例中，我们选择了ubuntu作为基础镜像。但是我们只需要运行 node 程序，有必要使用一个通用的基础镜像吗？node镜像应该是更好的选择。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"comment\"># we don't need to install node </span></span><br><span class=\"line\"><span class=\"comment\"># anymore and use apt-get</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p>更好的选择是 alpine 版本的node镜像。alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /app &amp;&amp; npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> npm start</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management\" target=\"_blank\" rel=\"noopener\">apk</a>是 Alpine 的包管理工具。它与apt-get有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如no-cache和 –virtual选项，它们都可以帮助我们减少镜像的大小。 </p>\n<h3 id=\"7-设置-WORKDIR-和-CMD\"><a href=\"#7-设置-WORKDIR-和-CMD\" class=\"headerlink\" title=\"7. 设置 WORKDIR 和 CMD\"></a><strong>7. 设置 WORKDIR 和 CMD</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#workdir\" target=\"_blank\" rel=\"noopener\">WORKDIR</a>指令可以设置默认目录，也就是运行RUN / CMD / ENTRYPOINT指令的地方。 </p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#cmd\" target=\"_blank\" rel=\"noopener\">CMD</a>指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考<a href=\"https://docs.docker.com/engine/reference/builder/#cmd\" target=\"_blank\" rel=\"noopener\">官方文档</a>)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"npm\"</span>, <span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"8-使用-ENTRYPOINT-可选\"><a href=\"#8-使用-ENTRYPOINT-可选\" class=\"headerlink\" title=\"8. 使用 ENTRYPOINT (可选)\"></a><strong>8. 使用 ENTRYPOINT (可选)</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#entrypoint\" target=\"_blank\" rel=\"noopener\">ENTRYPOINT</a>指令并不是必须的，因为它会增加复杂度。ENTRYPOINT是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的 Docker 镜像。entrypoint.sh 如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env sh</span></span><br><span class=\"line\"><span class=\"comment\"># $0 is a script name, </span></span><br><span class=\"line\"><span class=\"comment\"># $1, $2, $3 etc are passed arguments</span></span><br><span class=\"line\"><span class=\"comment\"># $1 is our command</span></span><br><span class=\"line\">CMD=<span class=\"variable\">$1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$CMD</span>\"</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">  <span class=\"string\">\"dev\"</span> )</span><br><span class=\"line\">    npm install</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_ENV=development</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> npm run dev</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">\"start\"</span> )</span><br><span class=\"line\">    <span class=\"comment\"># we can modify files here, using ENV variables passed in </span></span><br><span class=\"line\">    <span class=\"comment\"># \"docker create\" command. It can't be done during build process.</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">\"db: <span class=\"variable\">$DATABASE_ADDRESS</span>\"</span> &gt;&gt; /app/config.yml</span><br><span class=\"line\">    <span class=\"built_in\">export</span> NODE_ENV=production</span><br><span class=\"line\">    <span class=\"built_in\">exec</span> npm start</span><br><span class=\"line\">    ;;</span><br><span class=\"line\"></span><br><span class=\"line\">   * )</span><br><span class=\"line\">    <span class=\"comment\"># Run custom command. Thanks to this line we can still use </span></span><br><span class=\"line\">    <span class=\"comment\"># \"docker run our_image /bin/bash\" and it will work</span></span><br><span class=\"line\">    <span class=\"built_in\">exec</span> <span class=\"variable\">$CMD</span> <span class=\"variable\">$&#123;@:2&#125;</span></span><br><span class=\"line\">    ;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n<p>示例 Dockerfile:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>可以使用如下命令运行该镜像:</p>\n<p><code>docker run our-app dev</code></p>\n<p><code>docker run out-app start</code></p>\n<p><code>docker run -ti out-app /bin/bash</code> </p>\n<h3 id=\"9-在-entrypoint-脚本中使用-exec\"><a href=\"#9-在-entrypoint-脚本中使用-exec\" class=\"headerlink\" title=\"9. 在 entrypoint 脚本中使用 exec\"></a><strong>9. 在 entrypoint 脚本中使用 exec</strong></h3><p>在前文的 entrypoint 脚本中，我使用了exec命令运行 node 应用。不使用exec的话，我们则不能顺利地关闭容器，因为 SIGTERM 信号会被 bash 脚本进程吞没。exec命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。</p>\n<h3 id=\"10-COPY-与-ADD-优先使用前者\"><a href=\"#10-COPY-与-ADD-优先使用前者\" class=\"headerlink\" title=\"10. COPY 与 ADD 优先使用前者\"></a><strong>10. COPY 与 ADD 优先使用前者</strong></h3><p><a href=\"https://docs.docker.com/engine/reference/builder/#copy\" target=\"_blank\" rel=\"noopener\">COPY</a>指令非常简单，仅用于将文件拷贝到镜像中。<a href=\"https://docs.docker.com/engine/reference/builder/#add\" target=\"_blank\" rel=\"noopener\">ADD</a>相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考<a href=\"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy\" target=\"_blank\" rel=\"noopener\">官方文档</a>)。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-合理调整-COPY-与-RUN-的顺序\"><a href=\"#11-合理调整-COPY-与-RUN-的顺序\" class=\"headerlink\" title=\"11. 合理调整 COPY 与 RUN 的顺序\"></a><strong>11. 合理调整 COPY 与 RUN 的顺序</strong></h3><p>我们应该<strong>把变化最少的部分放在 Dockerfile 的前面</strong>，这样可以充分利用镜像缓存。</p>\n<p>示例中，源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装 NPM 模块。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"12-设置默认的环境变量，映射端口和数据卷\"><a href=\"#12-设置默认的环境变量，映射端口和数据卷\" class=\"headerlink\" title=\"12. 设置默认的环境变量，映射端口和数据卷\"></a><strong>12. 设置默认的环境变量，映射端口和数据卷</strong></h3><p>运行 Docker 容器时很可能需要一些环境变量。在 Dockerfile 设置默认的环境变量是一种很好的方式。另外，我们应该在 Dockerfile 中设置映射端口和数据卷。示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># env variables required during build</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PROJECT_DIR=/app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># env variables that can change</span></span><br><span class=\"line\"><span class=\"comment\"># volume and port settings</span></span><br><span class=\"line\"><span class=\"comment\"># and defaults for our application</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MEDIA_DIR=/media \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    APP_PORT=<span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> <span class=\"variable\">$MEDIA_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> $APP_PORT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://docs.docker.com/engine/reference/builder/#env\" target=\"_blank\" rel=\"noopener\">ENV</a>指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用<a href=\"https://docs.docker.com/engine/reference/builder/#arg\" target=\"_blank\" rel=\"noopener\">ARG</a>指令。</p>\n<h3 id=\"13-使用-LABEL-设置镜像元数据\"><a href=\"#13-使用-LABEL-设置镜像元数据\" class=\"headerlink\" title=\"13. 使用 LABEL 设置镜像元数据\"></a><strong>13. 使用 LABEL 设置镜像元数据</strong></h3><p>使用<a href=\"https://docs.docker.com/engine/reference/builder/#label\" target=\"_blank\" rel=\"noopener\">LABEL</a>指令，可以为镜像设置元数据，例如<strong>镜像创建者</strong>或者<strong>镜像说明</strong>。旧版的 Dockerfile 语法使用<a href=\"https://docs.docker.com/engine/reference/builder/#maintainer-deprecated\" target=\"_blank\" rel=\"noopener\">MAINTAINER</a>指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如<a href=\"https://github.com/NVIDIA/nvidia-docker\" target=\"_blank\" rel=\"noopener\">nvidia-docker</a>需要用到<code>com.nvidia.volumes.needed</code>。</p>\n<p>示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"bash\"> maintainer <span class=\"string\">\"jakub.skalecki@example.com\"</span></span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-添加-HEALTHCHECK\"><a href=\"#14-添加-HEALTHCHECK\" class=\"headerlink\" title=\"14. 添加 HEALTHCHECK\"></a><strong>14. 添加 HEALTHCHECK</strong></h3><p>运行容器时，可以指定–restart always选项。这样的话，容器崩溃时，Docker 守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用<a href=\"https://docs.docker.com/engine/reference/builder/#healthcheck\" target=\"_blank\" rel=\"noopener\">HEALTHCHECK</a>指令可以让 Docker 周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回 0，否则返回 1。对 HEALTHCHECK 感兴趣的话，可以参考<a href=\"https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>。示例如下:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">7</span>-alpine</span><br><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"bash\"> maintainer <span class=\"string\">\"jakub.skalecki@example.com\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> PROJECT_DIR=/app</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> package.json <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> npm install</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . <span class=\"variable\">$PROJECT_DIR</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MEDIA_DIR=/media \\</span><br><span class=\"line\">    NODE_ENV=production \\</span><br><span class=\"line\">    APP_PORT=<span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> <span class=\"variable\">$MEDIA_DIR</span></span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> $APP_PORT</span><br><span class=\"line\"><span class=\"keyword\">HEALTHCHECK</span><span class=\"bash\"> CMD curl --fail http://localhost:<span class=\"variable\">$APP_PORT</span> || <span class=\"built_in\">exit</span> 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"./entrypoint.sh\"</span>]</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"start\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p>当请求失败时，<code>curl —fail</code> 命令返回非 0 状态。 </p>\n<h3 id=\"对进一步了解的使用者\"><a href=\"#对进一步了解的使用者\" class=\"headerlink\" title=\"对进一步了解的使用者\"></a><strong>对进一步了解的使用者</strong></h3><p>如果你想要了解更多，请参阅 <a href=\"https://docs.docker.com/engine/reference/builder/#stopsignal\" target=\"_blank\" rel=\"noopener\">STOPSIGNAL</a>, <a href=\"https://docs.docker.com/engine/reference/builder/#onbuild\" target=\"_blank\" rel=\"noopener\">ONBUILD</a>, 和 <a href=\"https://docs.docker.com/engine/reference/builder/#shell\" target=\"_blank\" rel=\"noopener\">SHELL</a> 指令。还要提到在构建镜像中一个非常有用的指令 <code>--no-cache</code>  (特别是在 CI 服务器上)，以及<code>--squash</code> <a href=\"https://docs.docker.com/engine/reference/commandline/build/#squash-an-images-layers---squash-experimental-only\" target=\"_blank\" rel=\"noopener\">here</a>).</p>\n<p>以上，Have fun :)</p>\n"},{"title":"HTTP 1.1 状态码分类及解释","date":"2019-11-26T11:34:49.000Z","_content":"\n> HTTP 协议中状态码繁多，本文介绍 HPPT/1.1 协议中各种状态码\n\n[Hypertext Transfer Protocol -- HTTP/1.1](https://tools.ietf.org/html/rfc2616#section-4)\n\n```html\nStatus-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n```\n\n## 状态码分类\n\n这些状态码被分为五大类：\n\n- 100-199 用于指定客户端应相应的某些动作。\n\n- 200-299 用于表示请求成功。\n\n- 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。\n\n- 400-499 用于指出客户端的错误。\n\n- 500-599 用于支持服务器错误。\n\nHttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。\n\n## 状态码详解\n\n- 100 (Continue/继续)\n\n  如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。\n\n- 101 (Switching Protocols/转换协议)\n\n- 101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。\n\n- 200 (OK/正常)\n\n  200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。\n\n- 201 (Created/已创建)\n\n- 201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。\n\n- 202 (Accepted/接受)\n\n- 202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。\n\n- 203 (Non-Authoritative Information/非官方信息)\n\n  状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。\n\n- 204 (No Content/无内容)\n\n  在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：\n\n  ~~~java\n  int pageVersion =Integer.parseInt(request.getParameter(\"pageVersion\"));\n\n  if (pageVersion >;= currentVersion) {\n\n    response.setStatus(response.SC_NO_CONTENT);\n\n  } else {\n\n  ​    // Create regular page\n\n  }\n  ~~~\n  \n  但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。\n\n- 205 (Reset Content/重置内容)\n\n  重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。\n\n- 206 (Partial Content/局部内容)\n\n  206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。\n\n- 300 (Multiple Choices/多重选择)\n\n  300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。\n\n- 301 (Moved Permanently)\n\n  301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。\n\n- 302 (Found/找到)\n\n  与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。\n\n  > Notice\n  > 代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。\n  >\n  > 状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(\"Location\", url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。\n  >\n  > 如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。\n  >\n\n  > 核心技巧\n  >\n  > 如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。\n  >\n  > 这个状态码有时可以与301交换使用。例如，如果你错误的访问了http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。\n  >\n\n- 303 (See Other/参见其他信息)\n\n  这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。\n\n- 304 (Not Modified/为修正)\n\n  当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。\n\n- 305 (Use Proxy/使用代理)\n\n  305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。\n\n- 307 (Temporary Redirect/临时重定向)\n\n  浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。\n\n  > 注意\n  >\n  > 在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。\n\n- 400 (Bad Request/错误请求)\n\n  400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。\n\n- 401 (Unauthorized/未授权)\n\n  401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”\n\n- 403 (Forbidden/禁止)\n\n  403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。\n\n- 404 (Not Found/未找到)\n\n  404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(\"message\")。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。\n  \n  > 核心警告\n  >\n  > 默认情况下，IE5忽略服务端生成的错误提示页面。\n\n- 405 (Method Not Allowed/方法未允许)\n\n  405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。\n\n- 406 (Not Acceptable/无法访问)\n\n  406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。\n\n- 407 (Proxy Authentication Required/代理服务器认证要求)\n\n  407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。\n\n- 408 (Request Timeout/请求超时)\n\n  408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。\n\n- 409 (Conflict/冲突)\n\n  该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。\n\n- 410 (Gone/已经不存在)\n\n  410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。\n\n- 411 (Length Required/需要数据长度)\n\n  411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。\n\n- 412 (Precondition Failed/先决条件错误)\n\n  412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。\n\n- 413 (Request Entity Too Large/请求实体过大)\n\n  413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。\n\n- 414 (Request URI Too Long/请求URI过长)\n\n  414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入 HTTP 1.1的。\n\n- 415 (Unsupported Media Type/不支持的媒体格式)\n\n  415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。\n\n- 416 (Requested Range Not Satisfiable/请求范围无法满足)\n\n  416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。\n\n  > 注意\n  >\n  > 在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。\n  >\n  > \n\n- 417 (Expectation Failed/期望失败)\n\n  如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。\n\n- 500 (Internal Server Error/内部服务器错误)\n\n  500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n\n- 501 (Not Implemented/未实现)\n\n  501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。\n\n- 502 (Bad Gateway/错误的网关)\n\n  502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。\n\n- 503 (Service Unavailable/服务无法获得)\n\n  状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。\n\n- 504 (Gateway Timeout/网关超时)\n\n  该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。\n\n- 505 (HTTP Version Not Supported/不支持的 HTTP 版本)\n\n  505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。","source":"_posts/http-status-code.md","raw":"---\ntitle: HTTP 1.1 状态码分类及解释\ndate: 2019-11-26 19:34:49\ntags: \n- http\n---\n\n> HTTP 协议中状态码繁多，本文介绍 HPPT/1.1 协议中各种状态码\n\n[Hypertext Transfer Protocol -- HTTP/1.1](https://tools.ietf.org/html/rfc2616#section-4)\n\n```html\nStatus-Code    =\n            \"100\"  ; Section 10.1.1: Continue\n          | \"101\"  ; Section 10.1.2: Switching Protocols\n          | \"200\"  ; Section 10.2.1: OK\n          | \"201\"  ; Section 10.2.2: Created\n          | \"202\"  ; Section 10.2.3: Accepted\n          | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n          | \"204\"  ; Section 10.2.5: No Content\n          | \"205\"  ; Section 10.2.6: Reset Content\n          | \"206\"  ; Section 10.2.7: Partial Content\n          | \"300\"  ; Section 10.3.1: Multiple Choices\n          | \"301\"  ; Section 10.3.2: Moved Permanently\n          | \"302\"  ; Section 10.3.3: Found\n          | \"303\"  ; Section 10.3.4: See Other\n          | \"304\"  ; Section 10.3.5: Not Modified\n          | \"305\"  ; Section 10.3.6: Use Proxy\n          | \"307\"  ; Section 10.3.8: Temporary Redirect\n          | \"400\"  ; Section 10.4.1: Bad Request\n          | \"401\"  ; Section 10.4.2: Unauthorized\n          | \"402\"  ; Section 10.4.3: Payment Required\n          | \"403\"  ; Section 10.4.4: Forbidden\n          | \"404\"  ; Section 10.4.5: Not Found\n          | \"405\"  ; Section 10.4.6: Method Not Allowed\n          | \"406\"  ; Section 10.4.7: Not Acceptable\n          | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n          | \"408\"  ; Section 10.4.9: Request Time-out\n          | \"409\"  ; Section 10.4.10: Conflict\n          | \"410\"  ; Section 10.4.11: Gone\n          | \"411\"  ; Section 10.4.12: Length Required\n          | \"412\"  ; Section 10.4.13: Precondition Failed\n          | \"413\"  ; Section 10.4.14: Request Entity Too Large\n          | \"414\"  ; Section 10.4.15: Request-URI Too Large\n          | \"415\"  ; Section 10.4.16: Unsupported Media Type\n          | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n          | \"417\"  ; Section 10.4.18: Expectation Failed\n          | \"500\"  ; Section 10.5.1: Internal Server Error\n          | \"501\"  ; Section 10.5.2: Not Implemented\n          | \"502\"  ; Section 10.5.3: Bad Gateway\n          | \"503\"  ; Section 10.5.4: Service Unavailable\n          | \"504\"  ; Section 10.5.5: Gateway Time-out\n          | \"505\"  ; Section 10.5.6: HTTP Version not supported\n          | extension-code\n```\n\n## 状态码分类\n\n这些状态码被分为五大类：\n\n- 100-199 用于指定客户端应相应的某些动作。\n\n- 200-299 用于表示请求成功。\n\n- 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。\n\n- 400-499 用于指出客户端的错误。\n\n- 500-599 用于支持服务器错误。\n\nHttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。\n\n## 状态码详解\n\n- 100 (Continue/继续)\n\n  如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。\n\n- 101 (Switching Protocols/转换协议)\n\n- 101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。\n\n- 200 (OK/正常)\n\n  200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。\n\n- 201 (Created/已创建)\n\n- 201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。\n\n- 202 (Accepted/接受)\n\n- 202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。\n\n- 203 (Non-Authoritative Information/非官方信息)\n\n  状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。\n\n- 204 (No Content/无内容)\n\n  在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：\n\n  ~~~java\n  int pageVersion =Integer.parseInt(request.getParameter(\"pageVersion\"));\n\n  if (pageVersion >;= currentVersion) {\n\n    response.setStatus(response.SC_NO_CONTENT);\n\n  } else {\n\n  ​    // Create regular page\n\n  }\n  ~~~\n  \n  但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。\n\n- 205 (Reset Content/重置内容)\n\n  重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。\n\n- 206 (Partial Content/局部内容)\n\n  206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。\n\n- 300 (Multiple Choices/多重选择)\n\n  300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。\n\n- 301 (Moved Permanently)\n\n  301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。\n\n- 302 (Found/找到)\n\n  与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。\n\n  > Notice\n  > 代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。\n  >\n  > 状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(\"Location\", url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。\n  >\n  > 如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。\n  >\n\n  > 核心技巧\n  >\n  > 如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。\n  >\n  > 这个状态码有时可以与301交换使用。例如，如果你错误的访问了http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。\n  >\n\n- 303 (See Other/参见其他信息)\n\n  这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。\n\n- 304 (Not Modified/为修正)\n\n  当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。\n\n- 305 (Use Proxy/使用代理)\n\n  305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。\n\n- 307 (Temporary Redirect/临时重定向)\n\n  浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。\n\n  > 注意\n  >\n  > 在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。\n\n- 400 (Bad Request/错误请求)\n\n  400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。\n\n- 401 (Unauthorized/未授权)\n\n  401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”\n\n- 403 (Forbidden/禁止)\n\n  403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。\n\n- 404 (Not Found/未找到)\n\n  404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(\"message\")。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。\n  \n  > 核心警告\n  >\n  > 默认情况下，IE5忽略服务端生成的错误提示页面。\n\n- 405 (Method Not Allowed/方法未允许)\n\n  405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。\n\n- 406 (Not Acceptable/无法访问)\n\n  406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。\n\n- 407 (Proxy Authentication Required/代理服务器认证要求)\n\n  407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。\n\n- 408 (Request Timeout/请求超时)\n\n  408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。\n\n- 409 (Conflict/冲突)\n\n  该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。\n\n- 410 (Gone/已经不存在)\n\n  410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。\n\n- 411 (Length Required/需要数据长度)\n\n  411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。\n\n- 412 (Precondition Failed/先决条件错误)\n\n  412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。\n\n- 413 (Request Entity Too Large/请求实体过大)\n\n  413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。\n\n- 414 (Request URI Too Long/请求URI过长)\n\n  414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入 HTTP 1.1的。\n\n- 415 (Unsupported Media Type/不支持的媒体格式)\n\n  415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。\n\n- 416 (Requested Range Not Satisfiable/请求范围无法满足)\n\n  416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。\n\n  > 注意\n  >\n  > 在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。\n  >\n  > \n\n- 417 (Expectation Failed/期望失败)\n\n  如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。\n\n- 500 (Internal Server Error/内部服务器错误)\n\n  500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\n\n- 501 (Not Implemented/未实现)\n\n  501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。\n\n- 502 (Bad Gateway/错误的网关)\n\n  502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。\n\n- 503 (Service Unavailable/服务无法获得)\n\n  状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。\n\n- 504 (Gateway Timeout/网关超时)\n\n  该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。\n\n- 505 (HTTP Version Not Supported/不支持的 HTTP 版本)\n\n  505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。","slug":"http-status-code","published":1,"updated":"2019-11-28T12:16:21.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrcp000rlon9ighrnxn9","content":"<blockquote>\n<p>HTTP 协议中状态码繁多，本文介绍 HPPT/1.1 协议中各种状态码</p>\n</blockquote>\n<p><a href=\"https://tools.ietf.org/html/rfc2616#section-4\" target=\"_blank\" rel=\"noopener\">Hypertext Transfer Protocol – HTTP/1.1</a></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status-Code    =</span><br><span class=\"line\">            \"100\"  ; Section 10.1.1: Continue</span><br><span class=\"line\">          | \"101\"  ; Section 10.1.2: Switching Protocols</span><br><span class=\"line\">          | \"200\"  ; Section 10.2.1: OK</span><br><span class=\"line\">          | \"201\"  ; Section 10.2.2: Created</span><br><span class=\"line\">          | \"202\"  ; Section 10.2.3: Accepted</span><br><span class=\"line\">          | \"203\"  ; Section 10.2.4: Non-Authoritative Information</span><br><span class=\"line\">          | \"204\"  ; Section 10.2.5: No Content</span><br><span class=\"line\">          | \"205\"  ; Section 10.2.6: Reset Content</span><br><span class=\"line\">          | \"206\"  ; Section 10.2.7: Partial Content</span><br><span class=\"line\">          | \"300\"  ; Section 10.3.1: Multiple Choices</span><br><span class=\"line\">          | \"301\"  ; Section 10.3.2: Moved Permanently</span><br><span class=\"line\">          | \"302\"  ; Section 10.3.3: Found</span><br><span class=\"line\">          | \"303\"  ; Section 10.3.4: See Other</span><br><span class=\"line\">          | \"304\"  ; Section 10.3.5: Not Modified</span><br><span class=\"line\">          | \"305\"  ; Section 10.3.6: Use Proxy</span><br><span class=\"line\">          | \"307\"  ; Section 10.3.8: Temporary Redirect</span><br><span class=\"line\">          | \"400\"  ; Section 10.4.1: Bad Request</span><br><span class=\"line\">          | \"401\"  ; Section 10.4.2: Unauthorized</span><br><span class=\"line\">          | \"402\"  ; Section 10.4.3: Payment Required</span><br><span class=\"line\">          | \"403\"  ; Section 10.4.4: Forbidden</span><br><span class=\"line\">          | \"404\"  ; Section 10.4.5: Not Found</span><br><span class=\"line\">          | \"405\"  ; Section 10.4.6: Method Not Allowed</span><br><span class=\"line\">          | \"406\"  ; Section 10.4.7: Not Acceptable</span><br><span class=\"line\">          | \"407\"  ; Section 10.4.8: Proxy Authentication Required</span><br><span class=\"line\">          | \"408\"  ; Section 10.4.9: Request Time-out</span><br><span class=\"line\">          | \"409\"  ; Section 10.4.10: Conflict</span><br><span class=\"line\">          | \"410\"  ; Section 10.4.11: Gone</span><br><span class=\"line\">          | \"411\"  ; Section 10.4.12: Length Required</span><br><span class=\"line\">          | \"412\"  ; Section 10.4.13: Precondition Failed</span><br><span class=\"line\">          | \"413\"  ; Section 10.4.14: Request Entity Too Large</span><br><span class=\"line\">          | \"414\"  ; Section 10.4.15: Request-URI Too Large</span><br><span class=\"line\">          | \"415\"  ; Section 10.4.16: Unsupported Media Type</span><br><span class=\"line\">          | \"416\"  ; Section 10.4.17: Requested range not satisfiable</span><br><span class=\"line\">          | \"417\"  ; Section 10.4.18: Expectation Failed</span><br><span class=\"line\">          | \"500\"  ; Section 10.5.1: Internal Server Error</span><br><span class=\"line\">          | \"501\"  ; Section 10.5.2: Not Implemented</span><br><span class=\"line\">          | \"502\"  ; Section 10.5.3: Bad Gateway</span><br><span class=\"line\">          | \"503\"  ; Section 10.5.4: Service Unavailable</span><br><span class=\"line\">          | \"504\"  ; Section 10.5.5: Gateway Time-out</span><br><span class=\"line\">          | \"505\"  ; Section 10.5.6: HTTP Version not supported</span><br><span class=\"line\">          | extension-code</span><br></pre></td></tr></table></figure>\n<h2 id=\"状态码分类\"><a href=\"#状态码分类\" class=\"headerlink\" title=\"状态码分类\"></a>状态码分类</h2><p>这些状态码被分为五大类：</p>\n<ul>\n<li><p>100-199 用于指定客户端应相应的某些动作。</p>\n</li>\n<li><p>200-299 用于表示请求成功。</p>\n</li>\n<li><p>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</p>\n</li>\n<li><p>400-499 用于指出客户端的错误。</p>\n</li>\n<li><p>500-599 用于支持服务器错误。</p>\n</li>\n</ul>\n<p>HttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。</p>\n<h2 id=\"状态码详解\"><a href=\"#状态码详解\" class=\"headerlink\" title=\"状态码详解\"></a>状态码详解</h2><ul>\n<li><p>100 (Continue/继续)</p>\n<p>如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>101 (Switching Protocols/转换协议)</p>\n</li>\n<li><p>101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>200 (OK/正常)</p>\n<p>200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。</p>\n</li>\n<li><p>201 (Created/已创建)</p>\n</li>\n<li><p>201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。</p>\n</li>\n<li><p>202 (Accepted/接受)</p>\n</li>\n<li><p>202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。</p>\n</li>\n<li><p>203 (Non-Authoritative Information/非官方信息)</p>\n<p>状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>204 (No Content/无内容)</p>\n<p>在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pageVersion =Integer.parseInt(request.getParameter(<span class=\"string\">\"pageVersion\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pageVersion &gt;;= currentVersion) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  response.setStatus(response.SC_NO_CONTENT);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    <span class=\"comment\">// Create regular page</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。</p>\n<ul>\n<li><p>205 (Reset Content/重置内容)</p>\n<p>重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>206 (Partial Content/局部内容)</p>\n<p>206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>300 (Multiple Choices/多重选择)</p>\n<p>300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。</p>\n</li>\n<li><p>301 (Moved Permanently)</p>\n<p>301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。</p>\n</li>\n<li><p>302 (Found/找到)</p>\n<p>与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。</p>\n<blockquote>\n<p>Notice<br>代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。</p>\n<p>状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(“Location”, url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。</p>\n<p>如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。</p>\n</blockquote>\n<blockquote>\n<p>核心技巧</p>\n<p>如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。</p>\n<p>这个状态码有时可以与301交换使用。例如，如果你错误的访问了<a href=\"http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。\" target=\"_blank\" rel=\"noopener\">http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。</a></p>\n</blockquote>\n</li>\n<li><p>303 (See Other/参见其他信息)</p>\n<p>这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>304 (Not Modified/为修正)</p>\n<p>当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。</p>\n</li>\n<li><p>305 (Use Proxy/使用代理)</p>\n<p>305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>307 (Temporary Redirect/临时重定向)</p>\n<p>浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。</p>\n<blockquote>\n<p>注意</p>\n<p>在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。</p>\n</blockquote>\n</li>\n<li><p>400 (Bad Request/错误请求)</p>\n<p>400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。</p>\n</li>\n<li><p>401 (Unauthorized/未授权)</p>\n<p>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”</p>\n</li>\n<li><p>403 (Forbidden/禁止)</p>\n<p>403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。</p>\n</li>\n<li><p>404 (Not Found/未找到)</p>\n<p>404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(“message”)。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。</p>\n<blockquote>\n<p>核心警告</p>\n<p>默认情况下，IE5忽略服务端生成的错误提示页面。</p>\n</blockquote>\n</li>\n<li><p>405 (Method Not Allowed/方法未允许)</p>\n<p>405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>406 (Not Acceptable/无法访问)</p>\n<p>406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>407 (Proxy Authentication Required/代理服务器认证要求)</p>\n<p>407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>408 (Request Timeout/请求超时)</p>\n<p>408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>409 (Conflict/冲突)</p>\n<p>该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>410 (Gone/已经不存在)</p>\n<p>410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>411 (Length Required/需要数据长度)</p>\n<p>411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>412 (Precondition Failed/先决条件错误)</p>\n<p>412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>413 (Request Entity Too Large/请求实体过大)</p>\n<p>413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>414 (Request URI Too Long/请求URI过长)</p>\n<p>414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL–<a href=\"http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入\" target=\"_blank\" rel=\"noopener\">http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入</a> HTTP 1.1的。</p>\n</li>\n<li><p>415 (Unsupported Media Type/不支持的媒体格式)</p>\n<p>415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>416 (Requested Range Not Satisfiable/请求范围无法满足)</p>\n<p>416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。</p>\n<blockquote>\n<p>注意</p>\n<p>在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。</p>\n</blockquote>\n</li>\n<li><p>417 (Expectation Failed/期望失败)</p>\n<p>如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>500 (Internal Server Error/内部服务器错误)</p>\n<p>500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</p>\n</li>\n<li><p>501 (Not Implemented/未实现)</p>\n<p>501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。</p>\n</li>\n<li><p>502 (Bad Gateway/错误的网关)</p>\n<p>502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。</p>\n</li>\n<li><p>503 (Service Unavailable/服务无法获得)</p>\n<p>状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。</p>\n</li>\n<li><p>504 (Gateway Timeout/网关超时)</p>\n<p>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>505 (HTTP Version Not Supported/不支持的 HTTP 版本)</p>\n<p>505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>HTTP 协议中状态码繁多，本文介绍 HPPT/1.1 协议中各种状态码</p>\n</blockquote>\n<p><a href=\"https://tools.ietf.org/html/rfc2616#section-4\" target=\"_blank\" rel=\"noopener\">Hypertext Transfer Protocol – HTTP/1.1</a></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status-Code    =</span><br><span class=\"line\">            \"100\"  ; Section 10.1.1: Continue</span><br><span class=\"line\">          | \"101\"  ; Section 10.1.2: Switching Protocols</span><br><span class=\"line\">          | \"200\"  ; Section 10.2.1: OK</span><br><span class=\"line\">          | \"201\"  ; Section 10.2.2: Created</span><br><span class=\"line\">          | \"202\"  ; Section 10.2.3: Accepted</span><br><span class=\"line\">          | \"203\"  ; Section 10.2.4: Non-Authoritative Information</span><br><span class=\"line\">          | \"204\"  ; Section 10.2.5: No Content</span><br><span class=\"line\">          | \"205\"  ; Section 10.2.6: Reset Content</span><br><span class=\"line\">          | \"206\"  ; Section 10.2.7: Partial Content</span><br><span class=\"line\">          | \"300\"  ; Section 10.3.1: Multiple Choices</span><br><span class=\"line\">          | \"301\"  ; Section 10.3.2: Moved Permanently</span><br><span class=\"line\">          | \"302\"  ; Section 10.3.3: Found</span><br><span class=\"line\">          | \"303\"  ; Section 10.3.4: See Other</span><br><span class=\"line\">          | \"304\"  ; Section 10.3.5: Not Modified</span><br><span class=\"line\">          | \"305\"  ; Section 10.3.6: Use Proxy</span><br><span class=\"line\">          | \"307\"  ; Section 10.3.8: Temporary Redirect</span><br><span class=\"line\">          | \"400\"  ; Section 10.4.1: Bad Request</span><br><span class=\"line\">          | \"401\"  ; Section 10.4.2: Unauthorized</span><br><span class=\"line\">          | \"402\"  ; Section 10.4.3: Payment Required</span><br><span class=\"line\">          | \"403\"  ; Section 10.4.4: Forbidden</span><br><span class=\"line\">          | \"404\"  ; Section 10.4.5: Not Found</span><br><span class=\"line\">          | \"405\"  ; Section 10.4.6: Method Not Allowed</span><br><span class=\"line\">          | \"406\"  ; Section 10.4.7: Not Acceptable</span><br><span class=\"line\">          | \"407\"  ; Section 10.4.8: Proxy Authentication Required</span><br><span class=\"line\">          | \"408\"  ; Section 10.4.9: Request Time-out</span><br><span class=\"line\">          | \"409\"  ; Section 10.4.10: Conflict</span><br><span class=\"line\">          | \"410\"  ; Section 10.4.11: Gone</span><br><span class=\"line\">          | \"411\"  ; Section 10.4.12: Length Required</span><br><span class=\"line\">          | \"412\"  ; Section 10.4.13: Precondition Failed</span><br><span class=\"line\">          | \"413\"  ; Section 10.4.14: Request Entity Too Large</span><br><span class=\"line\">          | \"414\"  ; Section 10.4.15: Request-URI Too Large</span><br><span class=\"line\">          | \"415\"  ; Section 10.4.16: Unsupported Media Type</span><br><span class=\"line\">          | \"416\"  ; Section 10.4.17: Requested range not satisfiable</span><br><span class=\"line\">          | \"417\"  ; Section 10.4.18: Expectation Failed</span><br><span class=\"line\">          | \"500\"  ; Section 10.5.1: Internal Server Error</span><br><span class=\"line\">          | \"501\"  ; Section 10.5.2: Not Implemented</span><br><span class=\"line\">          | \"502\"  ; Section 10.5.3: Bad Gateway</span><br><span class=\"line\">          | \"503\"  ; Section 10.5.4: Service Unavailable</span><br><span class=\"line\">          | \"504\"  ; Section 10.5.5: Gateway Time-out</span><br><span class=\"line\">          | \"505\"  ; Section 10.5.6: HTTP Version not supported</span><br><span class=\"line\">          | extension-code</span><br></pre></td></tr></table></figure>\n<h2 id=\"状态码分类\"><a href=\"#状态码分类\" class=\"headerlink\" title=\"状态码分类\"></a>状态码分类</h2><p>这些状态码被分为五大类：</p>\n<ul>\n<li><p>100-199 用于指定客户端应相应的某些动作。</p>\n</li>\n<li><p>200-299 用于表示请求成功。</p>\n</li>\n<li><p>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</p>\n</li>\n<li><p>400-499 用于指出客户端的错误。</p>\n</li>\n<li><p>500-599 用于支持服务器错误。</p>\n</li>\n</ul>\n<p>HttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。</p>\n<h2 id=\"状态码详解\"><a href=\"#状态码详解\" class=\"headerlink\" title=\"状态码详解\"></a>状态码详解</h2><ul>\n<li><p>100 (Continue/继续)</p>\n<p>如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>101 (Switching Protocols/转换协议)</p>\n</li>\n<li><p>101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>200 (OK/正常)</p>\n<p>200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。</p>\n</li>\n<li><p>201 (Created/已创建)</p>\n</li>\n<li><p>201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。</p>\n</li>\n<li><p>202 (Accepted/接受)</p>\n</li>\n<li><p>202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。</p>\n</li>\n<li><p>203 (Non-Authoritative Information/非官方信息)</p>\n<p>状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>204 (No Content/无内容)</p>\n<p>在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> pageVersion =Integer.parseInt(request.getParameter(<span class=\"string\">\"pageVersion\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pageVersion &gt;;= currentVersion) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  response.setStatus(response.SC_NO_CONTENT);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    <span class=\"comment\">// Create regular page</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。</p>\n<ul>\n<li><p>205 (Reset Content/重置内容)</p>\n<p>重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>206 (Partial Content/局部内容)</p>\n<p>206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。</p>\n</li>\n<li><p>300 (Multiple Choices/多重选择)</p>\n<p>300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。</p>\n</li>\n<li><p>301 (Moved Permanently)</p>\n<p>301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。</p>\n</li>\n<li><p>302 (Found/找到)</p>\n<p>与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。</p>\n<blockquote>\n<p>Notice<br>代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。</p>\n<p>状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(“Location”, url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。</p>\n<p>如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。</p>\n</blockquote>\n<blockquote>\n<p>核心技巧</p>\n<p>如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。</p>\n<p>这个状态码有时可以与301交换使用。例如，如果你错误的访问了<a href=\"http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。\" target=\"_blank\" rel=\"noopener\">http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。</a></p>\n</blockquote>\n</li>\n<li><p>303 (See Other/参见其他信息)</p>\n<p>这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>304 (Not Modified/为修正)</p>\n<p>当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。</p>\n</li>\n<li><p>305 (Use Proxy/使用代理)</p>\n<p>305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>307 (Temporary Redirect/临时重定向)</p>\n<p>浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。</p>\n<blockquote>\n<p>注意</p>\n<p>在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。</p>\n</blockquote>\n</li>\n<li><p>400 (Bad Request/错误请求)</p>\n<p>400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。</p>\n</li>\n<li><p>401 (Unauthorized/未授权)</p>\n<p>401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”</p>\n</li>\n<li><p>403 (Forbidden/禁止)</p>\n<p>403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。</p>\n</li>\n<li><p>404 (Not Found/未找到)</p>\n<p>404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(“message”)。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。</p>\n<blockquote>\n<p>核心警告</p>\n<p>默认情况下，IE5忽略服务端生成的错误提示页面。</p>\n</blockquote>\n</li>\n<li><p>405 (Method Not Allowed/方法未允许)</p>\n<p>405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>406 (Not Acceptable/无法访问)</p>\n<p>406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>407 (Proxy Authentication Required/代理服务器认证要求)</p>\n<p>407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>408 (Request Timeout/请求超时)</p>\n<p>408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>409 (Conflict/冲突)</p>\n<p>该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>410 (Gone/已经不存在)</p>\n<p>410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。</p>\n</li>\n<li><p>411 (Length Required/需要数据长度)</p>\n<p>411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>412 (Precondition Failed/先决条件错误)</p>\n<p>412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>413 (Request Entity Too Large/请求实体过大)</p>\n<p>413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>414 (Request URI Too Long/请求URI过长)</p>\n<p>414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL–<a href=\"http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入\" target=\"_blank\" rel=\"noopener\">http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入</a> HTTP 1.1的。</p>\n</li>\n<li><p>415 (Unsupported Media Type/不支持的媒体格式)</p>\n<p>415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>416 (Requested Range Not Satisfiable/请求范围无法满足)</p>\n<p>416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。</p>\n<blockquote>\n<p>注意</p>\n<p>在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。</p>\n</blockquote>\n</li>\n<li><p>417 (Expectation Failed/期望失败)</p>\n<p>如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>500 (Internal Server Error/内部服务器错误)</p>\n<p>500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。</p>\n</li>\n<li><p>501 (Not Implemented/未实现)</p>\n<p>501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。</p>\n</li>\n<li><p>502 (Bad Gateway/错误的网关)</p>\n<p>502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。</p>\n</li>\n<li><p>503 (Service Unavailable/服务无法获得)</p>\n<p>状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。</p>\n</li>\n<li><p>504 (Gateway Timeout/网关超时)</p>\n<p>该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。</p>\n</li>\n<li><p>505 (HTTP Version Not Supported/不支持的 HTTP 版本)</p>\n<p>505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。</p>\n</li>\n</ul>\n"},{"title":"Jenkins Testlink Plugin 源码笔记","date":"2019-11-27T12:16:23.000Z","_content":"\n\n## 需求\n\nTestlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。\n\njenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。\n\n## 思路\n\n首先查到官方 Testlink-plugin 的 repo https://github.com/jenkinsci/testlink-plugin\n\npull 到本地查看一下项目结构\n\n~~~bash\n├── pom.xml \t\t\t\t\t\t\n├── src\t\t\t\t\t\t\t\t\t\n│   ├── main\n│   │   ├── java\n│   │   ├── resources\n│   │   └── webapp\n│   └── test\n│       ├── java\n│       └── resources\n\n~~~\n\n其中主要代码存放在 src/main/hudson/plugins/testlink 下：\n\n~~~bash\n├── AbstractTestLinkBuilder.java\n├── AbstractTestLinkProjectAction.java\n├── GraphHelper.java\n├── Report.java\n├── TestLinkBuildAction.java\n├── TestLinkBuilder.java\n├── TestLinkBuilderDescriptor.java\n├── TestLinkInstallation.java\n├── TestLinkJunitWrapper.java\n├── TestLinkProjectAction.java\n├── TestLinkResult.java\n├── TestLinkSite.java\n├── result\n│   ├── AbstractJUnitResultSeeker.java\n│   ├── AbstractTAPFileNameResultSeeker.java\n│   ├── AbstractTestNGResultSeeker.java\n│   ├── JUnitCaseClassNameResultSeeker.java\n│   ├── JUnitCaseNameResultSeeker.java\n│   ├── JUnitMethodNameResultSeeker.java\n│   ├── JUnitSuiteNameResultSeeker.java\n│   ├── ResultSeeker.java\n│   ├── ResultSeekerDescriptor.java\n│   ├── ResultSeekerException.java\n│   ├── TAPFileNameMultiTestPointsResultSeeker.java\n│   ├── TAPFileNameResultSeeker.java\n│   ├── TestCaseWrapper.java\n│   ├── TestNGClassNameResultSeeker.java\n│   ├── TestNGMethodNameDataProviderNameResultSeeker.java\n│   ├── TestNGMethodNameResultSeeker.java\n│   └── TestNGSuiteNameResultSeeker.java\n└── util\n    ├── ExecutionOrderComparator.java\n    └── TestLinkHelper.java\n\n\n~~~\n\n现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java\n\n定位到 `perfrom()` 函数\n\n~~~java\npublic boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n\t// function body\t\t\n}\n~~~\n\n可以看到入参列表：\n\n`AbstractBuild<?, ?> build` \n\n`Launcher`\n\n`BuildListener `\n\n接下来看函数体内容：\n\n~~~java\n// TestLink installation\nlistener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());\nfinal TestLinkInstallation installation = DESCRIPTOR\n.getInstallationByTestLinkName(this.testLinkName);\nif (installation == null) {\nthrow new AbortException(Messages.TestLinkBuilder_InvalidTLAPI());\n}\n\n~~~\n\nTestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:\n\n包括 `name`, `url`, `devKey`, `testlinkJavaAPIProperties`\n\n接下来是初始化其他的东西\n\n~~~java\nTestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);\n\nfinal TestLinkSite testLinkSite;\nfinal TestCaseWrapper[] automatedTestCases;\nfinal String testLinkUrl = installation.getUrl();\nfinal String testLinkDevKey = installation.getDevKey();\nTestPlan testPlan;\nlistener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));\n...\ntestLinkSite = this.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);\n~~~\n\n`TestlinkSite` 成员里有 `TestlinkAPI`, 可以通过传入 configuration 里面所设置的参数对 `Testlink` 进行操作。\n\n~~~java\nfinal String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getCustomFields());\n// Array of automated test cases\nTestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);\n\n// Retrieve custom fields in test plan\nfinal String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getTestPlanCustomFields());\ntestPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);\n\n// Transforms test cases into test case wrappers\nautomatedTestCases = this.transform(testCases);\n~~~\n\n获取 `CustomFields` ， 通过`TestlinkSite` 拿到对应的 `(List)Testcase`，转换为`(List)TestlinkWrapper `,  针对其进行了一层封装，具体细节看 `result/TestcaseWrapper.java`. \n\n~~~java\nfor(TestCaseWrapper tcw : automatedTestCases) {\n  testLinkSite.getReport().addTestCase(tcw);\n  if(LOGGER.isLoggable(Level.FINE)) {\n    LOGGER.log(Level.FINE, \"TestLink automated test case ID [\" + tcw.getId() + \"], name [\" +tcw.getName()+ \"]\");\n  }\n}\n~~~\n\n`TestSite`中有成员 `Report`，用来存储基本的 Testcase，以及 TestStatus 这些信息\n\n~~~java\nif(getResultSeekers() != null) {\n  for (ResultSeeker resultSeeker : getResultSeekers()) {\n    LOGGER.log(Level.INFO, \"Seeking test results. Using: \" + resultSeeker.getDescriptor().getDisplayName());\n    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);\n  }\n}\n~~~\n\n`ResultSeeker` 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。\n\n~~~java\nfinal Report report = testLinkSite.getReport();\nreport.tally();\n...\nfinal TestLinkResult result = new TestLinkResult(report);\nfinal TestLinkBuildAction buildAction = new TestLinkBuildAction(result);\nbuild.addAction(buildAction);\n~~~\n\n最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。\n\n执行逻辑结束。\n\n## 后记\n\n在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。\n\n在阅读源码的时候，获得了以下几个小的知识点\n\n- 从入口到各个模块的调用，是阅读源码的脉络\n- 不要一开始纠结于细节。大致了解各个功能模块的作用就行\n- 良好的抽象能力是关键技能","source":"_posts/DevOps/jenkins-testlink-plugin-source-code-note.md","raw":"---\ntitle: Jenkins Testlink Plugin 源码笔记\ndate: 2019-11-27 20:16:23\ntags:\n  - jenkins\n  - testlink\n  - plugin\ncategories:\n  - DevOps\n---\n\n\n## 需求\n\nTestlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。\n\njenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。\n\n## 思路\n\n首先查到官方 Testlink-plugin 的 repo https://github.com/jenkinsci/testlink-plugin\n\npull 到本地查看一下项目结构\n\n~~~bash\n├── pom.xml \t\t\t\t\t\t\n├── src\t\t\t\t\t\t\t\t\t\n│   ├── main\n│   │   ├── java\n│   │   ├── resources\n│   │   └── webapp\n│   └── test\n│       ├── java\n│       └── resources\n\n~~~\n\n其中主要代码存放在 src/main/hudson/plugins/testlink 下：\n\n~~~bash\n├── AbstractTestLinkBuilder.java\n├── AbstractTestLinkProjectAction.java\n├── GraphHelper.java\n├── Report.java\n├── TestLinkBuildAction.java\n├── TestLinkBuilder.java\n├── TestLinkBuilderDescriptor.java\n├── TestLinkInstallation.java\n├── TestLinkJunitWrapper.java\n├── TestLinkProjectAction.java\n├── TestLinkResult.java\n├── TestLinkSite.java\n├── result\n│   ├── AbstractJUnitResultSeeker.java\n│   ├── AbstractTAPFileNameResultSeeker.java\n│   ├── AbstractTestNGResultSeeker.java\n│   ├── JUnitCaseClassNameResultSeeker.java\n│   ├── JUnitCaseNameResultSeeker.java\n│   ├── JUnitMethodNameResultSeeker.java\n│   ├── JUnitSuiteNameResultSeeker.java\n│   ├── ResultSeeker.java\n│   ├── ResultSeekerDescriptor.java\n│   ├── ResultSeekerException.java\n│   ├── TAPFileNameMultiTestPointsResultSeeker.java\n│   ├── TAPFileNameResultSeeker.java\n│   ├── TestCaseWrapper.java\n│   ├── TestNGClassNameResultSeeker.java\n│   ├── TestNGMethodNameDataProviderNameResultSeeker.java\n│   ├── TestNGMethodNameResultSeeker.java\n│   └── TestNGSuiteNameResultSeeker.java\n└── util\n    ├── ExecutionOrderComparator.java\n    └── TestLinkHelper.java\n\n\n~~~\n\n现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java\n\n定位到 `perfrom()` 函数\n\n~~~java\npublic boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n\t// function body\t\t\n}\n~~~\n\n可以看到入参列表：\n\n`AbstractBuild<?, ?> build` \n\n`Launcher`\n\n`BuildListener `\n\n接下来看函数体内容：\n\n~~~java\n// TestLink installation\nlistener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());\nfinal TestLinkInstallation installation = DESCRIPTOR\n.getInstallationByTestLinkName(this.testLinkName);\nif (installation == null) {\nthrow new AbortException(Messages.TestLinkBuilder_InvalidTLAPI());\n}\n\n~~~\n\nTestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:\n\n包括 `name`, `url`, `devKey`, `testlinkJavaAPIProperties`\n\n接下来是初始化其他的东西\n\n~~~java\nTestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);\n\nfinal TestLinkSite testLinkSite;\nfinal TestCaseWrapper[] automatedTestCases;\nfinal String testLinkUrl = installation.getUrl();\nfinal String testLinkDevKey = installation.getDevKey();\nTestPlan testPlan;\nlistener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));\n...\ntestLinkSite = this.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);\n~~~\n\n`TestlinkSite` 成员里有 `TestlinkAPI`, 可以通过传入 configuration 里面所设置的参数对 `Testlink` 进行操作。\n\n~~~java\nfinal String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getCustomFields());\n// Array of automated test cases\nTestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);\n\n// Retrieve custom fields in test plan\nfinal String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getTestPlanCustomFields());\ntestPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);\n\n// Transforms test cases into test case wrappers\nautomatedTestCases = this.transform(testCases);\n~~~\n\n获取 `CustomFields` ， 通过`TestlinkSite` 拿到对应的 `(List)Testcase`，转换为`(List)TestlinkWrapper `,  针对其进行了一层封装，具体细节看 `result/TestcaseWrapper.java`. \n\n~~~java\nfor(TestCaseWrapper tcw : automatedTestCases) {\n  testLinkSite.getReport().addTestCase(tcw);\n  if(LOGGER.isLoggable(Level.FINE)) {\n    LOGGER.log(Level.FINE, \"TestLink automated test case ID [\" + tcw.getId() + \"], name [\" +tcw.getName()+ \"]\");\n  }\n}\n~~~\n\n`TestSite`中有成员 `Report`，用来存储基本的 Testcase，以及 TestStatus 这些信息\n\n~~~java\nif(getResultSeekers() != null) {\n  for (ResultSeeker resultSeeker : getResultSeekers()) {\n    LOGGER.log(Level.INFO, \"Seeking test results. Using: \" + resultSeeker.getDescriptor().getDisplayName());\n    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);\n  }\n}\n~~~\n\n`ResultSeeker` 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。\n\n~~~java\nfinal Report report = testLinkSite.getReport();\nreport.tally();\n...\nfinal TestLinkResult result = new TestLinkResult(report);\nfinal TestLinkBuildAction buildAction = new TestLinkBuildAction(result);\nbuild.addAction(buildAction);\n~~~\n\n最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。\n\n执行逻辑结束。\n\n## 后记\n\n在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。\n\n在阅读源码的时候，获得了以下几个小的知识点\n\n- 从入口到各个模块的调用，是阅读源码的脉络\n- 不要一开始纠结于细节。大致了解各个功能模块的作用就行\n- 良好的抽象能力是关键技能","slug":"DevOps/jenkins-testlink-plugin-source-code-note","published":1,"updated":"2019-11-28T12:19:06.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrcq000slon9wrw5afl6","content":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>Testlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。</p>\n<p>jenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查到官方 Testlink-plugin 的 repo <a href=\"https://github.com/jenkinsci/testlink-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/testlink-plugin</a></p>\n<p>pull 到本地查看一下项目结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml \t\t\t\t\t\t</span><br><span class=\"line\">├── src\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java</span><br><span class=\"line\">│   │   ├── resources</span><br><span class=\"line\">│   │   └── webapp</span><br><span class=\"line\">│   └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│       ├── java</span><br><span class=\"line\">│       └── resources</span><br></pre></td></tr></table></figure>\n<p>其中主要代码存放在 src/main/hudson/plugins/testlink 下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── AbstractTestLinkBuilder.java</span><br><span class=\"line\">├── AbstractTestLinkProjectAction.java</span><br><span class=\"line\">├── GraphHelper.java</span><br><span class=\"line\">├── Report.java</span><br><span class=\"line\">├── TestLinkBuildAction.java</span><br><span class=\"line\">├── TestLinkBuilder.java</span><br><span class=\"line\">├── TestLinkBuilderDescriptor.java</span><br><span class=\"line\">├── TestLinkInstallation.java</span><br><span class=\"line\">├── TestLinkJunitWrapper.java</span><br><span class=\"line\">├── TestLinkProjectAction.java</span><br><span class=\"line\">├── TestLinkResult.java</span><br><span class=\"line\">├── TestLinkSite.java</span><br><span class=\"line\">├── result</span><br><span class=\"line\">│   ├── AbstractJUnitResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTestNGResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitMethodNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitSuiteNameResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeekerDescriptor.java</span><br><span class=\"line\">│   ├── ResultSeekerException.java</span><br><span class=\"line\">│   ├── TAPFileNameMultiTestPointsResultSeeker.java</span><br><span class=\"line\">│   ├── TAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestCaseWrapper.java</span><br><span class=\"line\">│   ├── TestNGClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameDataProviderNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameResultSeeker.java</span><br><span class=\"line\">│   └── TestNGSuiteNameResultSeeker.java</span><br><span class=\"line\">└── util</span><br><span class=\"line\">    ├── ExecutionOrderComparator.java</span><br><span class=\"line\">    └── TestLinkHelper.java</span><br></pre></td></tr></table></figure>\n<p>现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java</p>\n<p>定位到 <code>perfrom()</code> 函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">perform</span><span class=\"params\">(AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// function body\t\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入参列表：</p>\n<p><code>AbstractBuild&lt;?, ?&gt; build</code> </p>\n<p><code>Launcher</code></p>\n<p><code>BuildListener</code></p>\n<p>接下来看函数体内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestLink installation</span></span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkInstallation installation = DESCRIPTOR</span><br><span class=\"line\">.getInstallationByTestLinkName(<span class=\"keyword\">this</span>.testLinkName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installation == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AbortException(Messages.TestLinkBuilder_InvalidTLAPI());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:</p>\n<p>包括 <code>name</code>, <code>url</code>, <code>devKey</code>, <code>testlinkJavaAPIProperties</code></p>\n<p>接下来是初始化其他的东西</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkSite testLinkSite;</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestCaseWrapper[] automatedTestCases;</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkUrl = installation.getUrl();</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkDevKey = installation.getDevKey();</span><br><span class=\"line\">TestPlan testPlan;</span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));</span><br><span class=\"line\">...</span><br><span class=\"line\">testLinkSite = <span class=\"keyword\">this</span>.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);</span><br></pre></td></tr></table></figure>\n<p><code>TestlinkSite</code> 成员里有 <code>TestlinkAPI</code>, 可以通过传入 configuration 里面所设置的参数对 <code>Testlink</code> 进行操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getCustomFields());</span><br><span class=\"line\"><span class=\"comment\">// Array of automated test cases</span></span><br><span class=\"line\">TestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve custom fields in test plan</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getTestPlanCustomFields());</span><br><span class=\"line\">testPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Transforms test cases into test case wrappers</span></span><br><span class=\"line\">automatedTestCases = <span class=\"keyword\">this</span>.transform(testCases);</span><br></pre></td></tr></table></figure>\n<p>获取 <code>CustomFields</code> ， 通过<code>TestlinkSite</code> 拿到对应的 <code>(List)Testcase</code>，转换为<code>(List)TestlinkWrapper</code>,  针对其进行了一层封装，具体细节看 <code>result/TestcaseWrapper.java</code>. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(TestCaseWrapper tcw : automatedTestCases) &#123;</span><br><span class=\"line\">  testLinkSite.getReport().addTestCase(tcw);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.FINE, <span class=\"string\">\"TestLink automated test case ID [\"</span> + tcw.getId() + <span class=\"string\">\"], name [\"</span> +tcw.getName()+ <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TestSite</code>中有成员 <code>Report</code>，用来存储基本的 Testcase，以及 TestStatus 这些信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getResultSeekers() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ResultSeeker resultSeeker : getResultSeekers()) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.INFO, <span class=\"string\">\"Seeking test results. Using: \"</span> + resultSeeker.getDescriptor().getDisplayName());</span><br><span class=\"line\">    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ResultSeeker</code> 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Report report = testLinkSite.getReport();</span><br><span class=\"line\">report.tally();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkResult result = <span class=\"keyword\">new</span> TestLinkResult(report);</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkBuildAction buildAction = <span class=\"keyword\">new</span> TestLinkBuildAction(result);</span><br><span class=\"line\">build.addAction(buildAction);</span><br></pre></td></tr></table></figure>\n<p>最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。</p>\n<p>执行逻辑结束。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。</p>\n<p>在阅读源码的时候，获得了以下几个小的知识点</p>\n<ul>\n<li>从入口到各个模块的调用，是阅读源码的脉络</li>\n<li>不要一开始纠结于细节。大致了解各个功能模块的作用就行</li>\n<li>良好的抽象能力是关键技能</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>Testlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。</p>\n<p>jenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查到官方 Testlink-plugin 的 repo <a href=\"https://github.com/jenkinsci/testlink-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/testlink-plugin</a></p>\n<p>pull 到本地查看一下项目结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml \t\t\t\t\t\t</span><br><span class=\"line\">├── src\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java</span><br><span class=\"line\">│   │   ├── resources</span><br><span class=\"line\">│   │   └── webapp</span><br><span class=\"line\">│   └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│       ├── java</span><br><span class=\"line\">│       └── resources</span><br></pre></td></tr></table></figure>\n<p>其中主要代码存放在 src/main/hudson/plugins/testlink 下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── AbstractTestLinkBuilder.java</span><br><span class=\"line\">├── AbstractTestLinkProjectAction.java</span><br><span class=\"line\">├── GraphHelper.java</span><br><span class=\"line\">├── Report.java</span><br><span class=\"line\">├── TestLinkBuildAction.java</span><br><span class=\"line\">├── TestLinkBuilder.java</span><br><span class=\"line\">├── TestLinkBuilderDescriptor.java</span><br><span class=\"line\">├── TestLinkInstallation.java</span><br><span class=\"line\">├── TestLinkJunitWrapper.java</span><br><span class=\"line\">├── TestLinkProjectAction.java</span><br><span class=\"line\">├── TestLinkResult.java</span><br><span class=\"line\">├── TestLinkSite.java</span><br><span class=\"line\">├── result</span><br><span class=\"line\">│   ├── AbstractJUnitResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTestNGResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitMethodNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitSuiteNameResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeekerDescriptor.java</span><br><span class=\"line\">│   ├── ResultSeekerException.java</span><br><span class=\"line\">│   ├── TAPFileNameMultiTestPointsResultSeeker.java</span><br><span class=\"line\">│   ├── TAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestCaseWrapper.java</span><br><span class=\"line\">│   ├── TestNGClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameDataProviderNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameResultSeeker.java</span><br><span class=\"line\">│   └── TestNGSuiteNameResultSeeker.java</span><br><span class=\"line\">└── util</span><br><span class=\"line\">    ├── ExecutionOrderComparator.java</span><br><span class=\"line\">    └── TestLinkHelper.java</span><br></pre></td></tr></table></figure>\n<p>现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java</p>\n<p>定位到 <code>perfrom()</code> 函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">perform</span><span class=\"params\">(AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// function body\t\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入参列表：</p>\n<p><code>AbstractBuild&lt;?, ?&gt; build</code> </p>\n<p><code>Launcher</code></p>\n<p><code>BuildListener</code></p>\n<p>接下来看函数体内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestLink installation</span></span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkInstallation installation = DESCRIPTOR</span><br><span class=\"line\">.getInstallationByTestLinkName(<span class=\"keyword\">this</span>.testLinkName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installation == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AbortException(Messages.TestLinkBuilder_InvalidTLAPI());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:</p>\n<p>包括 <code>name</code>, <code>url</code>, <code>devKey</code>, <code>testlinkJavaAPIProperties</code></p>\n<p>接下来是初始化其他的东西</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkSite testLinkSite;</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestCaseWrapper[] automatedTestCases;</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkUrl = installation.getUrl();</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkDevKey = installation.getDevKey();</span><br><span class=\"line\">TestPlan testPlan;</span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));</span><br><span class=\"line\">...</span><br><span class=\"line\">testLinkSite = <span class=\"keyword\">this</span>.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);</span><br></pre></td></tr></table></figure>\n<p><code>TestlinkSite</code> 成员里有 <code>TestlinkAPI</code>, 可以通过传入 configuration 里面所设置的参数对 <code>Testlink</code> 进行操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getCustomFields());</span><br><span class=\"line\"><span class=\"comment\">// Array of automated test cases</span></span><br><span class=\"line\">TestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve custom fields in test plan</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getTestPlanCustomFields());</span><br><span class=\"line\">testPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Transforms test cases into test case wrappers</span></span><br><span class=\"line\">automatedTestCases = <span class=\"keyword\">this</span>.transform(testCases);</span><br></pre></td></tr></table></figure>\n<p>获取 <code>CustomFields</code> ， 通过<code>TestlinkSite</code> 拿到对应的 <code>(List)Testcase</code>，转换为<code>(List)TestlinkWrapper</code>,  针对其进行了一层封装，具体细节看 <code>result/TestcaseWrapper.java</code>. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(TestCaseWrapper tcw : automatedTestCases) &#123;</span><br><span class=\"line\">  testLinkSite.getReport().addTestCase(tcw);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.FINE, <span class=\"string\">\"TestLink automated test case ID [\"</span> + tcw.getId() + <span class=\"string\">\"], name [\"</span> +tcw.getName()+ <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TestSite</code>中有成员 <code>Report</code>，用来存储基本的 Testcase，以及 TestStatus 这些信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getResultSeekers() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ResultSeeker resultSeeker : getResultSeekers()) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.INFO, <span class=\"string\">\"Seeking test results. Using: \"</span> + resultSeeker.getDescriptor().getDisplayName());</span><br><span class=\"line\">    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ResultSeeker</code> 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Report report = testLinkSite.getReport();</span><br><span class=\"line\">report.tally();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkResult result = <span class=\"keyword\">new</span> TestLinkResult(report);</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkBuildAction buildAction = <span class=\"keyword\">new</span> TestLinkBuildAction(result);</span><br><span class=\"line\">build.addAction(buildAction);</span><br></pre></td></tr></table></figure>\n<p>最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。</p>\n<p>执行逻辑结束。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。</p>\n<p>在阅读源码的时候，获得了以下几个小的知识点</p>\n<ul>\n<li>从入口到各个模块的调用，是阅读源码的脉络</li>\n<li>不要一开始纠结于细节。大致了解各个功能模块的作用就行</li>\n<li>良好的抽象能力是关键技能</li>\n</ul>\n"},{"title":"VSCode插件开发入门","_content":"\n\n\n# VSCode 插件开发\n\n## 核心组件\n\n- Electron\n- Monaco Editor\n- Language Server Protocol\n- Debug Adapter Protocol\n\n### Electorn (formerly Atom Shell)\n\n- 基于 Node.js（作为后端）和 Chromium（作为前端)\n\n- 使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序\n\n-   使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …\n\n[Github传送门](https://github.com/electron/electron)\n\n### Monaca Editor\n\n- 基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …\n\n- 支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera\n\n- 使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools\n\n[GitHub传送门](https://github.com/Microsoft/monaco-editor )\n\n### Language Server Protocol (LSP)\n\n- 它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。\n\n- 支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs\n\n[GitHub传送门](https://github.com/Microsoft/language-server-protocol)\n\n### Debug Adapter Protocol (DAP)\n\n- DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。\n\n- 支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim \n\n[GitHub传送门](https://github.com/Microsoft/debug-adapter-protocol)\n\n## 插件开发流程\n\n### 开发环境\n\n- Visual Studio Code\n\n- Node.js\n\n  `npm -v` 查看是否安装成功\n\n- Yeoman and VS Code Extension generator:\n\n  `npm install -g yo generator-code`\n\n### 插件类型\n\n- Themes\n\n- Snippets\n\n- Formatters\n\n- Linters\n\n- Debuggers\n\n- Programming Languages\n\n- Keymaps\n\n- SCM Provides\n\n- Extensions Packs\n\n- Others\n\n### 如何搭建工程\n\n1. `yo code`\n2. 选择你搭建项目的类型\n3. 是否导入相关资源\n4. 选择名字\n\n\n\n### e.g. Color Thems\n\n### e.g. Code Snippet\n\n## VSCode 界面功能拓展\n\n- Workbench\n- Editor area\n\n### Workbench\n\n![image-20190331110014505](https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg)\n\n### Editor Area\n\n- Codelens\n- Decoration\n- Gutter\n- Hover\n- Context Menu\n\n### e.g. Translator Extension\n\n\n\n","source":"_posts/Tools/vscode-plugin-dev-intro.md","raw":"---\ntitle: VSCode插件开发入门\ntags:\n  - vscode\n  - plugin\ncategories:\n  - Tools\n---\n\n\n\n# VSCode 插件开发\n\n## 核心组件\n\n- Electron\n- Monaco Editor\n- Language Server Protocol\n- Debug Adapter Protocol\n\n### Electorn (formerly Atom Shell)\n\n- 基于 Node.js（作为后端）和 Chromium（作为前端)\n\n- 使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序\n\n-   使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …\n\n[Github传送门](https://github.com/electron/electron)\n\n### Monaca Editor\n\n- 基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …\n\n- 支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera\n\n- 使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools\n\n[GitHub传送门](https://github.com/Microsoft/monaco-editor )\n\n### Language Server Protocol (LSP)\n\n- 它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。\n\n- 支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs\n\n[GitHub传送门](https://github.com/Microsoft/language-server-protocol)\n\n### Debug Adapter Protocol (DAP)\n\n- DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。\n\n- 支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim \n\n[GitHub传送门](https://github.com/Microsoft/debug-adapter-protocol)\n\n## 插件开发流程\n\n### 开发环境\n\n- Visual Studio Code\n\n- Node.js\n\n  `npm -v` 查看是否安装成功\n\n- Yeoman and VS Code Extension generator:\n\n  `npm install -g yo generator-code`\n\n### 插件类型\n\n- Themes\n\n- Snippets\n\n- Formatters\n\n- Linters\n\n- Debuggers\n\n- Programming Languages\n\n- Keymaps\n\n- SCM Provides\n\n- Extensions Packs\n\n- Others\n\n### 如何搭建工程\n\n1. `yo code`\n2. 选择你搭建项目的类型\n3. 是否导入相关资源\n4. 选择名字\n\n\n\n### e.g. Color Thems\n\n### e.g. Code Snippet\n\n## VSCode 界面功能拓展\n\n- Workbench\n- Editor area\n\n### Workbench\n\n![image-20190331110014505](https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg)\n\n### Editor Area\n\n- Codelens\n- Decoration\n- Gutter\n- Hover\n- Context Menu\n\n### e.g. Translator Extension\n\n\n\n","slug":"Tools/vscode-plugin-dev-intro","published":1,"date":"2019-11-11T07:59:20.463Z","updated":"2019-11-11T07:59:20.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrcs000ulon9l11ikalk","content":"<h1 id=\"VSCode-插件开发\"><a href=\"#VSCode-插件开发\" class=\"headerlink\" title=\"VSCode 插件开发\"></a>VSCode 插件开发</h1><h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><ul>\n<li>Electron</li>\n<li>Monaco Editor</li>\n<li>Language Server Protocol</li>\n<li>Debug Adapter Protocol</li>\n</ul>\n<h3 id=\"Electorn-formerly-Atom-Shell\"><a href=\"#Electorn-formerly-Atom-Shell\" class=\"headerlink\" title=\"Electorn (formerly Atom Shell)\"></a>Electorn (formerly Atom Shell)</h3><ul>\n<li><p>基于 Node.js（作为后端）和 Chromium（作为前端)</p>\n</li>\n<li><p>使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序</p>\n</li>\n<li><p>使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/electron/electron\" target=\"_blank\" rel=\"noopener\">Github传送门</a></p>\n<h3 id=\"Monaca-Editor\"><a href=\"#Monaca-Editor\" class=\"headerlink\" title=\"Monaca Editor\"></a>Monaca Editor</h3><ul>\n<li><p>基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …</p>\n</li>\n<li><p>支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera</p>\n</li>\n<li><p>使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/monaco-editor\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Language-Server-Protocol-LSP\"><a href=\"#Language-Server-Protocol-LSP\" class=\"headerlink\" title=\"Language Server Protocol (LSP)\"></a>Language Server Protocol (LSP)</h3><ul>\n<li><p>它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。</p>\n</li>\n<li><p>支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/language-server-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Debug-Adapter-Protocol-DAP\"><a href=\"#Debug-Adapter-Protocol-DAP\" class=\"headerlink\" title=\"Debug Adapter Protocol (DAP)\"></a>Debug Adapter Protocol (DAP)</h3><ul>\n<li><p>DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。</p>\n</li>\n<li><p>支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim </p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/debug-adapter-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h2 id=\"插件开发流程\"><a href=\"#插件开发流程\" class=\"headerlink\" title=\"插件开发流程\"></a>插件开发流程</h2><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><ul>\n<li><p>Visual Studio Code</p>\n</li>\n<li><p>Node.js</p>\n<p><code>npm -v</code> 查看是否安装成功</p>\n</li>\n<li><p>Yeoman and VS Code Extension generator:</p>\n<p><code>npm install -g yo generator-code</code></p>\n</li>\n</ul>\n<h3 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"插件类型\"></a>插件类型</h3><ul>\n<li><p>Themes</p>\n</li>\n<li><p>Snippets</p>\n</li>\n<li><p>Formatters</p>\n</li>\n<li><p>Linters</p>\n</li>\n<li><p>Debuggers</p>\n</li>\n<li><p>Programming Languages</p>\n</li>\n<li><p>Keymaps</p>\n</li>\n<li><p>SCM Provides</p>\n</li>\n<li><p>Extensions Packs</p>\n</li>\n<li><p>Others</p>\n</li>\n</ul>\n<h3 id=\"如何搭建工程\"><a href=\"#如何搭建工程\" class=\"headerlink\" title=\"如何搭建工程\"></a>如何搭建工程</h3><ol>\n<li><code>yo code</code></li>\n<li>选择你搭建项目的类型</li>\n<li>是否导入相关资源</li>\n<li>选择名字</li>\n</ol>\n<h3 id=\"e-g-Color-Thems\"><a href=\"#e-g-Color-Thems\" class=\"headerlink\" title=\"e.g. Color Thems\"></a>e.g. Color Thems</h3><h3 id=\"e-g-Code-Snippet\"><a href=\"#e-g-Code-Snippet\" class=\"headerlink\" title=\"e.g. Code Snippet\"></a>e.g. Code Snippet</h3><h2 id=\"VSCode-界面功能拓展\"><a href=\"#VSCode-界面功能拓展\" class=\"headerlink\" title=\"VSCode 界面功能拓展\"></a>VSCode 界面功能拓展</h2><ul>\n<li>Workbench</li>\n<li>Editor area</li>\n</ul>\n<h3 id=\"Workbench\"><a href=\"#Workbench\" class=\"headerlink\" title=\"Workbench\"></a>Workbench</h3><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg\" alt=\"image-20190331110014505\"></p>\n<h3 id=\"Editor-Area\"><a href=\"#Editor-Area\" class=\"headerlink\" title=\"Editor Area\"></a>Editor Area</h3><ul>\n<li>Codelens</li>\n<li>Decoration</li>\n<li>Gutter</li>\n<li>Hover</li>\n<li>Context Menu</li>\n</ul>\n<h3 id=\"e-g-Translator-Extension\"><a href=\"#e-g-Translator-Extension\" class=\"headerlink\" title=\"e.g. Translator Extension\"></a>e.g. Translator Extension</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"VSCode-插件开发\"><a href=\"#VSCode-插件开发\" class=\"headerlink\" title=\"VSCode 插件开发\"></a>VSCode 插件开发</h1><h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><ul>\n<li>Electron</li>\n<li>Monaco Editor</li>\n<li>Language Server Protocol</li>\n<li>Debug Adapter Protocol</li>\n</ul>\n<h3 id=\"Electorn-formerly-Atom-Shell\"><a href=\"#Electorn-formerly-Atom-Shell\" class=\"headerlink\" title=\"Electorn (formerly Atom Shell)\"></a>Electorn (formerly Atom Shell)</h3><ul>\n<li><p>基于 Node.js（作为后端）和 Chromium（作为前端)</p>\n</li>\n<li><p>使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序</p>\n</li>\n<li><p>使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/electron/electron\" target=\"_blank\" rel=\"noopener\">Github传送门</a></p>\n<h3 id=\"Monaca-Editor\"><a href=\"#Monaca-Editor\" class=\"headerlink\" title=\"Monaca Editor\"></a>Monaca Editor</h3><ul>\n<li><p>基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …</p>\n</li>\n<li><p>支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera</p>\n</li>\n<li><p>使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/monaco-editor\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Language-Server-Protocol-LSP\"><a href=\"#Language-Server-Protocol-LSP\" class=\"headerlink\" title=\"Language Server Protocol (LSP)\"></a>Language Server Protocol (LSP)</h3><ul>\n<li><p>它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。</p>\n</li>\n<li><p>支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/language-server-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Debug-Adapter-Protocol-DAP\"><a href=\"#Debug-Adapter-Protocol-DAP\" class=\"headerlink\" title=\"Debug Adapter Protocol (DAP)\"></a>Debug Adapter Protocol (DAP)</h3><ul>\n<li><p>DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。</p>\n</li>\n<li><p>支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim </p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/debug-adapter-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h2 id=\"插件开发流程\"><a href=\"#插件开发流程\" class=\"headerlink\" title=\"插件开发流程\"></a>插件开发流程</h2><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><ul>\n<li><p>Visual Studio Code</p>\n</li>\n<li><p>Node.js</p>\n<p><code>npm -v</code> 查看是否安装成功</p>\n</li>\n<li><p>Yeoman and VS Code Extension generator:</p>\n<p><code>npm install -g yo generator-code</code></p>\n</li>\n</ul>\n<h3 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"插件类型\"></a>插件类型</h3><ul>\n<li><p>Themes</p>\n</li>\n<li><p>Snippets</p>\n</li>\n<li><p>Formatters</p>\n</li>\n<li><p>Linters</p>\n</li>\n<li><p>Debuggers</p>\n</li>\n<li><p>Programming Languages</p>\n</li>\n<li><p>Keymaps</p>\n</li>\n<li><p>SCM Provides</p>\n</li>\n<li><p>Extensions Packs</p>\n</li>\n<li><p>Others</p>\n</li>\n</ul>\n<h3 id=\"如何搭建工程\"><a href=\"#如何搭建工程\" class=\"headerlink\" title=\"如何搭建工程\"></a>如何搭建工程</h3><ol>\n<li><code>yo code</code></li>\n<li>选择你搭建项目的类型</li>\n<li>是否导入相关资源</li>\n<li>选择名字</li>\n</ol>\n<h3 id=\"e-g-Color-Thems\"><a href=\"#e-g-Color-Thems\" class=\"headerlink\" title=\"e.g. Color Thems\"></a>e.g. Color Thems</h3><h3 id=\"e-g-Code-Snippet\"><a href=\"#e-g-Code-Snippet\" class=\"headerlink\" title=\"e.g. Code Snippet\"></a>e.g. Code Snippet</h3><h2 id=\"VSCode-界面功能拓展\"><a href=\"#VSCode-界面功能拓展\" class=\"headerlink\" title=\"VSCode 界面功能拓展\"></a>VSCode 界面功能拓展</h2><ul>\n<li>Workbench</li>\n<li>Editor area</li>\n</ul>\n<h3 id=\"Workbench\"><a href=\"#Workbench\" class=\"headerlink\" title=\"Workbench\"></a>Workbench</h3><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg\" alt=\"image-20190331110014505\"></p>\n<h3 id=\"Editor-Area\"><a href=\"#Editor-Area\" class=\"headerlink\" title=\"Editor Area\"></a>Editor Area</h3><ul>\n<li>Codelens</li>\n<li>Decoration</li>\n<li>Gutter</li>\n<li>Hover</li>\n<li>Context Menu</li>\n</ul>\n<h3 id=\"e-g-Translator-Extension\"><a href=\"#e-g-Translator-Extension\" class=\"headerlink\" title=\"e.g. Translator Extension\"></a>e.g. Translator Extension</h3>"},{"title":"Git 基础","_content":"\n## 版本控制\n\n### 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n### 为什么要版本控制\n\n有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n### 本地版本控制系统\n\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n![本地版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png)\n\n### 集中化的版本控制系统\n\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 \n\n集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n![集中化的版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png)\n\n这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：\n\n- **单点故障：** 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n- **必须联网才能工作：** 受网络状况、带宽影响。\n\n### 分布式版本控制系统\n\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。\n\n这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n\n![分布式版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png)\n\n分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n## 认识 Git\n\n### Git 简史\n\nLinux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 \n\n### Git 与其他版本管理系统的主要区别\n\n Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。\n\n下面我们主要说一个关于 Git 其他版本管理系统的主要差别：**对待数据的方式**。\n\n**Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。**\n\n大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统**将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。**\n\n具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"/>\n</br>\n</div>\n\n**我们怎样才能得到一个文件的最终版本呢？**\n\n很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。\n\n**这种方式有什么问题呢？**\n\n比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"/>\n</br>\n</div>\n\n\n### Git 的三种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n1. **已提交（committed）**：数据已经安全的保存在本地数据库中。\n2. **已修改（modified）**：已修改表示修改了文件，但还没保存到数据库中。\n3. **已暂存（staged）**：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：**Git 仓库(.git directoty) **、**工作目录(Working Directory)** 以及 **暂存区域(Staging Area)** 。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"/>\n</div>\n\n**基本的 Git 工作流程如下：**\n\n1. 在工作目录中修改文件。\n2. 暂存文件，将文件的快照放入暂存区域。\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n## Git 使用快速入门\n\n### 获取 Git 仓库\n\n有两种取得 Git 项目仓库的方法。\n\n1. 在现有目录中初始化仓库: 进入项目目录运行  `git init`  命令,该命令将创建一个名为 `.git` 的子目录。\n2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url]` directoryname \n\n### 记录每次更新到仓库\n\n1. **检测当前文件状态** : `git status`\n2. **提出更改（把它们添加到暂存区**）：`git add filename ` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）\n3. **忽略文件**：`.gitignore` 文件\n4. **提交更新:** `git commit -m \"代码提交信息\"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）\n5. **跳过使用暂存区域更新的方式** : `git commit -a -m \"代码提交信息\"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。\n6. **移除文件** ：`git rm filename`  （从暂存区域移除，然后提交。）\n7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)\n\n### 推送改动到远程仓库\n\n- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git` \n- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)\n\n  如此你就能够将你的改动推送到所添加的服务器上去了。\n\n### 远程仓库的移除与重命名\n\n- 将 test 重命名位 test1：`git remote rename test test1`\n- 移除远程仓库 test1:`git remote rm test1`\n\n### 查看提交历史\n\n在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。\n\n**可以添加一些参数来查看自己希望看到的内容：**\n\n只看某个人的提交记录：\n\n```shell\ngit log --author=bob\n```\n\n### 撤销操作\n\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：\n\n```console\ngit commit --amend\n```\n\n取消暂存的文件\n\n```console\ngit reset filename\n```\n\n撤消对文件的修改:\n\n```\ngit checkout -- filename\n```\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n\n```\ngit fetch origin\ngit reset --hard origin/master\n```\n\n\n\n### 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n\n创建一个名字叫做 test 的分支\n\n```console\ngit branch test\n```\n\n切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n\n```console\ngit checkout test\n```\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"/>\n</div>\n\n你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n\n```console\ngit checkout -b feature_x\n```\n\n切换到主分支\n\n```\ngit checkout master\n```\n\n合并分支(可能会有冲突)\n\n```java\n git merge test\n```\n\n把新建的分支删掉\n\n```\ngit branch -d feature_x\n```\n\n将分支推送到远端仓库（推送成功后其他人可见）：\n\n```\ngit push origin \n```\n\n\n\n## 推荐阅读\n\n- [Git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n- [图解Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n- [猴子都能懂得Git入门](https://backlog.com/git-tutorial/cn/intro/intro1_1.html)\n- [Pro Git](https://git-scm.com/book/en/v2)\n","source":"_posts/Tools/introduce-git.md","raw":"---\ntitle: Git 基础\ncategories:\n  - Tools\ntags:\n  - tools\n---\n\n## 版本控制\n\n### 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n### 为什么要版本控制\n\n有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n### 本地版本控制系统\n\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n![本地版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png)\n\n### 集中化的版本控制系统\n\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 \n\n集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n![集中化的版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png)\n\n这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：\n\n- **单点故障：** 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n- **必须联网才能工作：** 受网络状况、带宽影响。\n\n### 分布式版本控制系统\n\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。\n\n这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n\n![分布式版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png)\n\n分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n## 认识 Git\n\n### Git 简史\n\nLinux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 \n\n### Git 与其他版本管理系统的主要区别\n\n Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。\n\n下面我们主要说一个关于 Git 其他版本管理系统的主要差别：**对待数据的方式**。\n\n**Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。**\n\n大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统**将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。**\n\n具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"/>\n</br>\n</div>\n\n**我们怎样才能得到一个文件的最终版本呢？**\n\n很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。\n\n**这种方式有什么问题呢？**\n\n比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"/>\n</br>\n</div>\n\n\n### Git 的三种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n1. **已提交（committed）**：数据已经安全的保存在本地数据库中。\n2. **已修改（modified）**：已修改表示修改了文件，但还没保存到数据库中。\n3. **已暂存（staged）**：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：**Git 仓库(.git directoty) **、**工作目录(Working Directory)** 以及 **暂存区域(Staging Area)** 。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"/>\n</div>\n\n**基本的 Git 工作流程如下：**\n\n1. 在工作目录中修改文件。\n2. 暂存文件，将文件的快照放入暂存区域。\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n## Git 使用快速入门\n\n### 获取 Git 仓库\n\n有两种取得 Git 项目仓库的方法。\n\n1. 在现有目录中初始化仓库: 进入项目目录运行  `git init`  命令,该命令将创建一个名为 `.git` 的子目录。\n2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url]` directoryname \n\n### 记录每次更新到仓库\n\n1. **检测当前文件状态** : `git status`\n2. **提出更改（把它们添加到暂存区**）：`git add filename ` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）\n3. **忽略文件**：`.gitignore` 文件\n4. **提交更新:** `git commit -m \"代码提交信息\"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）\n5. **跳过使用暂存区域更新的方式** : `git commit -a -m \"代码提交信息\"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。\n6. **移除文件** ：`git rm filename`  （从暂存区域移除，然后提交。）\n7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)\n\n### 推送改动到远程仓库\n\n- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git` \n- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)\n\n  如此你就能够将你的改动推送到所添加的服务器上去了。\n\n### 远程仓库的移除与重命名\n\n- 将 test 重命名位 test1：`git remote rename test test1`\n- 移除远程仓库 test1:`git remote rm test1`\n\n### 查看提交历史\n\n在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。\n\n**可以添加一些参数来查看自己希望看到的内容：**\n\n只看某个人的提交记录：\n\n```shell\ngit log --author=bob\n```\n\n### 撤销操作\n\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：\n\n```console\ngit commit --amend\n```\n\n取消暂存的文件\n\n```console\ngit reset filename\n```\n\n撤消对文件的修改:\n\n```\ngit checkout -- filename\n```\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n\n```\ngit fetch origin\ngit reset --hard origin/master\n```\n\n\n\n### 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n\n创建一个名字叫做 test 的分支\n\n```console\ngit branch test\n```\n\n切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n\n```console\ngit checkout test\n```\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"/>\n</div>\n\n你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n\n```console\ngit checkout -b feature_x\n```\n\n切换到主分支\n\n```\ngit checkout master\n```\n\n合并分支(可能会有冲突)\n\n```java\n git merge test\n```\n\n把新建的分支删掉\n\n```\ngit branch -d feature_x\n```\n\n将分支推送到远端仓库（推送成功后其他人可见）：\n\n```\ngit push origin \n```\n\n\n\n## 推荐阅读\n\n- [Git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n- [图解Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n- [猴子都能懂得Git入门](https://backlog.com/git-tutorial/cn/intro/intro1_1.html)\n- [Pro Git](https://git-scm.com/book/en/v2)\n","slug":"Tools/introduce-git","published":1,"date":"2019-11-11T07:59:20.459Z","updated":"2019-11-27T14:03:23.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrcw0019lon925joueud","content":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><h3 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>\n<h3 id=\"为什么要版本控制\"><a href=\"#为什么要版本控制\" class=\"headerlink\" title=\"为什么要版本控制\"></a>为什么要版本控制</h3><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>\n<h3 id=\"本地版本控制系统\"><a href=\"#本地版本控制系统\" class=\"headerlink\" title=\"本地版本控制系统\"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>\n<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png\" alt=\"本地版本控制系统\"></p>\n<h3 id=\"集中化的版本控制系统\"><a href=\"#集中化的版本控制系统\" class=\"headerlink\" title=\"集中化的版本控制系统\"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 </p>\n<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png\" alt=\"集中化的版本控制系统\"></p>\n<p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>\n<ul>\n<li><strong>单点故障：</strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</li>\n<li><strong>必须联网才能工作：</strong> 受网络状况、带宽影响。</li>\n</ul>\n<h3 id=\"分布式版本控制系统\"><a href=\"#分布式版本控制系统\" class=\"headerlink\" title=\"分布式版本控制系统\"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p>\n<p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png\" alt=\"分布式版本控制系统\"></p>\n<p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>\n<p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。</p>\n<h2 id=\"认识-Git\"><a href=\"#认识-Git\" class=\"headerlink\" title=\"认识 Git\"></a>认识 Git</h2><h3 id=\"Git-简史\"><a href=\"#Git-简史\" class=\"headerlink\" title=\"Git 简史\"></a>Git 简史</h3><p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 </p>\n<h3 id=\"Git-与其他版本管理系统的主要区别\"><a href=\"#Git-与其他版本管理系统的主要区别\" class=\"headerlink\" title=\"Git 与其他版本管理系统的主要区别\"></a>Git 与其他版本管理系统的主要区别</h3><p> Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p>\n<p>下面我们主要说一个关于 Git 其他版本管理系统的主要差别：<strong>对待数据的方式</strong>。</p>\n<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>\n<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>\n<p>具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"><br><br><br></div>\n\n<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>\n<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>\n<p><strong>这种方式有什么问题呢？</strong></p>\n<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>\n<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"><br><br><br></div>\n\n\n<h3 id=\"Git-的三种状态\"><a href=\"#Git-的三种状态\" class=\"headerlink\" title=\"Git 的三种状态\"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>\n<ol>\n<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>\n<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>\n<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>\n</ol>\n<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) </strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"><br></div>\n\n<p><strong>基本的 Git 工作流程如下：</strong></p>\n<ol>\n<li>在工作目录中修改文件。</li>\n<li>暂存文件，将文件的快照放入暂存区域。</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>\n</ol>\n<h2 id=\"Git-使用快速入门\"><a href=\"#Git-使用快速入门\" class=\"headerlink\" title=\"Git 使用快速入门\"></a>Git 使用快速入门</h2><h3 id=\"获取-Git-仓库\"><a href=\"#获取-Git-仓库\" class=\"headerlink\" title=\"获取 Git 仓库\"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>\n<ol>\n<li>在现有目录中初始化仓库: 进入项目目录运行  <code>git init</code>  命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>\n<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname </li>\n</ol>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><ol>\n<li><strong>检测当前文件状态</strong> : <code>git status</code></li>\n<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>\n<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>\n<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>\n<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>\n<li><strong>移除文件</strong> ：<code>git rm filename</code>  （从暂存区域移除，然后提交。）</li>\n<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>\n</ol>\n<h3 id=\"推送改动到远程仓库\"><a href=\"#推送改动到远程仓库\" class=\"headerlink\" title=\"推送改动到远程仓库\"></a>推送改动到远程仓库</h3><ul>\n<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code> </li>\n<li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>\n<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库的移除与重命名\"><a href=\"#远程仓库的移除与重命名\" class=\"headerlink\" title=\"远程仓库的移除与重命名\"></a>远程仓库的移除与重命名</h3><ul>\n<li>将 test 重命名位 test1：<code>git remote rename test test1</code></li>\n<li>移除远程仓库 test1:<code>git remote rm test1</code></li>\n</ul>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>\n<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>\n<p>只看某个人的提交记录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --author=bob</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>取消暂存的文件</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset filename</span><br></pre></td></tr></table></figure>\n<p>撤消对文件的修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>\n<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>\n<p>创建一个名字叫做 test 的分支</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch test</span><br></pre></td></tr></table></figure>\n<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout test</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"><br></div>\n\n<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature_x</span><br></pre></td></tr></table></figure>\n<p>切换到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>合并分支(可能会有冲突)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n<p>把新建的分支删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature_x</span><br></pre></td></tr></table></figure>\n<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git - 简明指南</a></li>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"https://backlog.com/git-tutorial/cn/intro/intro1_1.html\" target=\"_blank\" rel=\"noopener\">猴子都能懂得Git入门</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><h3 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>\n<h3 id=\"为什么要版本控制\"><a href=\"#为什么要版本控制\" class=\"headerlink\" title=\"为什么要版本控制\"></a>为什么要版本控制</h3><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>\n<h3 id=\"本地版本控制系统\"><a href=\"#本地版本控制系统\" class=\"headerlink\" title=\"本地版本控制系统\"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>\n<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png\" alt=\"本地版本控制系统\"></p>\n<h3 id=\"集中化的版本控制系统\"><a href=\"#集中化的版本控制系统\" class=\"headerlink\" title=\"集中化的版本控制系统\"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 </p>\n<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png\" alt=\"集中化的版本控制系统\"></p>\n<p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>\n<ul>\n<li><strong>单点故障：</strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</li>\n<li><strong>必须联网才能工作：</strong> 受网络状况、带宽影响。</li>\n</ul>\n<h3 id=\"分布式版本控制系统\"><a href=\"#分布式版本控制系统\" class=\"headerlink\" title=\"分布式版本控制系统\"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p>\n<p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png\" alt=\"分布式版本控制系统\"></p>\n<p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>\n<p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。</p>\n<h2 id=\"认识-Git\"><a href=\"#认识-Git\" class=\"headerlink\" title=\"认识 Git\"></a>认识 Git</h2><h3 id=\"Git-简史\"><a href=\"#Git-简史\" class=\"headerlink\" title=\"Git 简史\"></a>Git 简史</h3><p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 </p>\n<h3 id=\"Git-与其他版本管理系统的主要区别\"><a href=\"#Git-与其他版本管理系统的主要区别\" class=\"headerlink\" title=\"Git 与其他版本管理系统的主要区别\"></a>Git 与其他版本管理系统的主要区别</h3><p> Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p>\n<p>下面我们主要说一个关于 Git 其他版本管理系统的主要差别：<strong>对待数据的方式</strong>。</p>\n<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>\n<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>\n<p>具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"><br><br><br></div>\n\n<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>\n<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>\n<p><strong>这种方式有什么问题呢？</strong></p>\n<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>\n<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"><br><br><br></div>\n\n\n<h3 id=\"Git-的三种状态\"><a href=\"#Git-的三种状态\" class=\"headerlink\" title=\"Git 的三种状态\"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>\n<ol>\n<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>\n<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>\n<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>\n</ol>\n<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) </strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"><br></div>\n\n<p><strong>基本的 Git 工作流程如下：</strong></p>\n<ol>\n<li>在工作目录中修改文件。</li>\n<li>暂存文件，将文件的快照放入暂存区域。</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>\n</ol>\n<h2 id=\"Git-使用快速入门\"><a href=\"#Git-使用快速入门\" class=\"headerlink\" title=\"Git 使用快速入门\"></a>Git 使用快速入门</h2><h3 id=\"获取-Git-仓库\"><a href=\"#获取-Git-仓库\" class=\"headerlink\" title=\"获取 Git 仓库\"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>\n<ol>\n<li>在现有目录中初始化仓库: 进入项目目录运行  <code>git init</code>  命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>\n<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname </li>\n</ol>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><ol>\n<li><strong>检测当前文件状态</strong> : <code>git status</code></li>\n<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>\n<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>\n<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>\n<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>\n<li><strong>移除文件</strong> ：<code>git rm filename</code>  （从暂存区域移除，然后提交。）</li>\n<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>\n</ol>\n<h3 id=\"推送改动到远程仓库\"><a href=\"#推送改动到远程仓库\" class=\"headerlink\" title=\"推送改动到远程仓库\"></a>推送改动到远程仓库</h3><ul>\n<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code> </li>\n<li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>\n<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库的移除与重命名\"><a href=\"#远程仓库的移除与重命名\" class=\"headerlink\" title=\"远程仓库的移除与重命名\"></a>远程仓库的移除与重命名</h3><ul>\n<li>将 test 重命名位 test1：<code>git remote rename test test1</code></li>\n<li>移除远程仓库 test1:<code>git remote rm test1</code></li>\n</ul>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>\n<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>\n<p>只看某个人的提交记录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --author=bob</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>取消暂存的文件</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset filename</span><br></pre></td></tr></table></figure>\n<p>撤消对文件的修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>\n<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>\n<p>创建一个名字叫做 test 的分支</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch test</span><br></pre></td></tr></table></figure>\n<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout test</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"><br></div>\n\n<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature_x</span><br></pre></td></tr></table></figure>\n<p>切换到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>合并分支(可能会有冲突)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n<p>把新建的分支删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature_x</span><br></pre></td></tr></table></figure>\n<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git - 简明指南</a></li>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"https://backlog.com/git-tutorial/cn/intro/intro1_1.html\" target=\"_blank\" rel=\"noopener\">猴子都能懂得Git入门</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n</ul>\n"},{"title":"【剑指Offer】二维数组中的查找","_content":"\n## 题目描述\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n## 算法分析\n\n我们可以观察二维数组（m，n）中的4个顶点。\n\n左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。\n\n考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        int row = array.size();\n        int col = array[0].size();\n        \n        int i, j;\n        // 起始点在左下角\n        for(i = row - 1, j = 0; i >= 0 && j < col;) {\n            if(target == array[i][j])\n                return true;\n            if(target < array[i][j]){\n                i--;\n                continue;\n            }\n            if(target > array[i][j]){\n                j++;\n                continue;\n            }\n        }\n        \n        // 或者起始点在右上角\n//    for(i = 0, j = col - 1; i < row && j >= 0;) {\n//        if(target == array[i][j])\n//            return true;\n//        if(target < array[i][j]){\n//            j--;\n//            continue;\n//        }\n//        if(target > array[i][j]){\n//\n//            i++;\n//            continue;\n//        }\n//    }\n        \n        return false;\n    }\n\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/find-in-two-dimensional-array.md","raw":"---\ntitle: 【剑指offer】二维数组中的查找\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - array\n---\n\n## 题目描述\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n## 算法分析\n\n我们可以观察二维数组（m，n）中的4个顶点。\n\n左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。\n\n考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        int row = array.size();\n        int col = array[0].size();\n        \n        int i, j;\n        // 起始点在左下角\n        for(i = row - 1, j = 0; i >= 0 && j < col;) {\n            if(target == array[i][j])\n                return true;\n            if(target < array[i][j]){\n                i--;\n                continue;\n            }\n            if(target > array[i][j]){\n                j++;\n                continue;\n            }\n        }\n        \n        // 或者起始点在右上角\n//    for(i = 0, j = col - 1; i < row && j >= 0;) {\n//        if(target == array[i][j])\n//            return true;\n//        if(target < array[i][j]){\n//            j--;\n//            continue;\n//        }\n//        if(target > array[i][j]){\n//\n//            i++;\n//            continue;\n//        }\n//    }\n        \n        return false;\n    }\n\n};\n~~~\n\n","slug":"Algorithm/ForOffer/find-in-two-dimensional-array","published":1,"date":"2019-11-11T07:59:20.429Z","updated":"2019-11-11T07:59:20.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrd5001dlon9bsi1vtfa","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我们可以观察二维数组（m，n）中的4个顶点。</p>\n<p>左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。</p>\n<p>考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"built_in\">array</span>.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = <span class=\"built_in\">array</span>[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"comment\">// 起始点在左下角</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = row - <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; col;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target == <span class=\"built_in\">array</span>[i][j])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &gt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 或者起始点在右上角</span></span><br><span class=\"line\"><span class=\"comment\">//    for(i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target == array[i][j])</span></span><br><span class=\"line\"><span class=\"comment\">//            return true;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &lt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            j--;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &gt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            i++;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我们可以观察二维数组（m，n）中的4个顶点。</p>\n<p>左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。</p>\n<p>考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"built_in\">array</span>.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = <span class=\"built_in\">array</span>[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"comment\">// 起始点在左下角</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = row - <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; col;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target == <span class=\"built_in\">array</span>[i][j])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &gt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 或者起始点在右上角</span></span><br><span class=\"line\"><span class=\"comment\">//    for(i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target == array[i][j])</span></span><br><span class=\"line\"><span class=\"comment\">//            return true;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &lt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            j--;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &gt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            i++;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"求有向图全部拓扑序列","_content":"> **All Topological Sorts**，在前一章中[Topological Sorting](https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/)，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。\n\n## 问题描述\n\n因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。\n\n那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，\n\n## 算法思路\n\n1. 初始化所有顶点为未访问状态；\n2. 依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；\n3. 在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。\n\n## 代码实现\n\n~~~cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    int V;    // No. of vertices\n\n    // Pointer to an array containing adjacency list\n    list<int> *adj;\n\n    // Vector to store indegree of vertices\n    vector<int> indegree;\n\n    // A function used by alltopologicalSort\n    void alltopologicalSortUtil(vector<int>& res,\n                                bool visited[]);\n\npublic:\n    Graph(int V);   // Constructor\n\n    // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // Prints all Topological Sorts\n    void alltopologicalSort();\n};\n\n//  Constructor of graph\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    // Initialising all indegree with 0\n    for (int i = 0; i < V; i++)\n        indegree.push_back(0);\n}\n\n//  Utility function to add edge\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v's list.\n\n    // increasing inner degree of w by 1\n    indegree[w]++;\n}\n\n//  Main recursive function to print all possible\n//  topological sorts\nvoid Graph::alltopologicalSortUtil(vector<int>& res,\n                                   bool visited[])\n{\n    // To indicate whether all topological are found\n    // or not\n    bool flag = false; \n\n    for (int i = 0; i < V; i++)\n    {\n        //  If indegree is 0 and not yet visited then\n        //  only choose that vertex\n        if (indegree[i] == 0 && !visited[i])\n        {\n            //  reducing indegree of adjacent vertices\n            list<int>:: iterator j;\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]--;\n\n            //  including in result\n            res.push_back(i);\n            visited[i] = true;\n            alltopologicalSortUtil(res, visited);\n\n            // resetting visited, res and indegree for\n            // backtracking\n            visited[i] = false;\n            res.erase(res.end() - 1);\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]++;\n\n            flag = true;\n        }\n    }\n\n    //  We reach here if all vertices are visited.\n    //  So we print the solution here\n    if (!flag)\n    {\n        for (int i = 0; i < res.size(); i++)\n            cout << res[i] << \" \";\n        cout << endl;\n    }\n}\n\n//  The function does all Topological Sort.\n//  It uses recursive alltopologicalSortUtil()\nvoid Graph::alltopologicalSort()\n{\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    vector<int> res;\n    alltopologicalSortUtil(res, visited);\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"All Topological sorts\\\\n\";\n\n    g.alltopologicalSort();\n\n    return 0;\n}\n~~~\n\n","source":"_posts/Algorithm/Data-Structure/topological-sort-all.md","raw":"---\ntitle: 求有向图全部拓扑序列\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - graph\n  - topological-sort\n---\n> **All Topological Sorts**，在前一章中[Topological Sorting](https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/)，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。\n\n## 问题描述\n\n因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。\n\n那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，\n\n## 算法思路\n\n1. 初始化所有顶点为未访问状态；\n2. 依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；\n3. 在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。\n\n## 代码实现\n\n~~~cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    int V;    // No. of vertices\n\n    // Pointer to an array containing adjacency list\n    list<int> *adj;\n\n    // Vector to store indegree of vertices\n    vector<int> indegree;\n\n    // A function used by alltopologicalSort\n    void alltopologicalSortUtil(vector<int>& res,\n                                bool visited[]);\n\npublic:\n    Graph(int V);   // Constructor\n\n    // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // Prints all Topological Sorts\n    void alltopologicalSort();\n};\n\n//  Constructor of graph\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    // Initialising all indegree with 0\n    for (int i = 0; i < V; i++)\n        indegree.push_back(0);\n}\n\n//  Utility function to add edge\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v's list.\n\n    // increasing inner degree of w by 1\n    indegree[w]++;\n}\n\n//  Main recursive function to print all possible\n//  topological sorts\nvoid Graph::alltopologicalSortUtil(vector<int>& res,\n                                   bool visited[])\n{\n    // To indicate whether all topological are found\n    // or not\n    bool flag = false; \n\n    for (int i = 0; i < V; i++)\n    {\n        //  If indegree is 0 and not yet visited then\n        //  only choose that vertex\n        if (indegree[i] == 0 && !visited[i])\n        {\n            //  reducing indegree of adjacent vertices\n            list<int>:: iterator j;\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]--;\n\n            //  including in result\n            res.push_back(i);\n            visited[i] = true;\n            alltopologicalSortUtil(res, visited);\n\n            // resetting visited, res and indegree for\n            // backtracking\n            visited[i] = false;\n            res.erase(res.end() - 1);\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]++;\n\n            flag = true;\n        }\n    }\n\n    //  We reach here if all vertices are visited.\n    //  So we print the solution here\n    if (!flag)\n    {\n        for (int i = 0; i < res.size(); i++)\n            cout << res[i] << \" \";\n        cout << endl;\n    }\n}\n\n//  The function does all Topological Sort.\n//  It uses recursive alltopologicalSortUtil()\nvoid Graph::alltopologicalSort()\n{\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    vector<int> res;\n    alltopologicalSortUtil(res, visited);\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"All Topological sorts\\\\n\";\n\n    g.alltopologicalSort();\n\n    return 0;\n}\n~~~\n\n","slug":"Algorithm/Data-Structure/topological-sort-all","published":1,"date":"2019-11-11T07:59:20.428Z","updated":"2019-11-29T02:58:59.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrd9001elon9f8tlmiaf","content":"<blockquote>\n<p><strong>All Topological Sorts</strong>，在前一章中<a href=\"https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/\" target=\"_blank\" rel=\"noopener\">Topological Sorting</a>，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。</p>\n<p>那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>初始化所有顶点为未访问状态；</li>\n<li>依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；</li>\n<li>在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Vector to store indegree of vertices</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; indegree;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by alltopologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSortUtil</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">bool</span> visited[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prints all Topological Sorts</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Constructor of graph</span></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialising all indegree with 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        indegree.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Utility function to add edge</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v's list.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increasing inner degree of w by 1</span></span><br><span class=\"line\">    indegree[w]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Main recursive function to print all possible</span></span><br><span class=\"line\"><span class=\"comment\">//  topological sorts</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSortUtil(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span><br><span class=\"line\">                                   <span class=\"keyword\">bool</span> visited[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// To indicate whether all topological are found</span></span><br><span class=\"line\">    <span class=\"comment\">// or not</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  If indegree is 0 and not yet visited then</span></span><br><span class=\"line\">        <span class=\"comment\">//  only choose that vertex</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span> &amp;&amp; !visited[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  reducing indegree of adjacent vertices</span></span><br><span class=\"line\">            <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;:: iterator j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//  including in result</span></span><br><span class=\"line\">            res.push_back(i);</span><br><span class=\"line\">            visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            alltopologicalSortUtil(res, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// resetting visited, res and indegree for</span></span><br><span class=\"line\">            <span class=\"comment\">// backtracking</span></span><br><span class=\"line\">            visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            res.erase(res.end() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  We reach here if all vertices are visited.</span></span><br><span class=\"line\">    <span class=\"comment\">//  So we print the solution here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res.size(); i++)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  The function does all Topological Sort.</span></span><br><span class=\"line\"><span class=\"comment\">//  It uses recursive alltopologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    alltopologicalSortUtil(res, visited);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"All Topological sorts\\\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    g.alltopologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>All Topological Sorts</strong>，在前一章中<a href=\"https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/\" target=\"_blank\" rel=\"noopener\">Topological Sorting</a>，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。</p>\n<p>那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>初始化所有顶点为未访问状态；</li>\n<li>依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；</li>\n<li>在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Vector to store indegree of vertices</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; indegree;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by alltopologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSortUtil</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">bool</span> visited[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prints all Topological Sorts</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Constructor of graph</span></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialising all indegree with 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        indegree.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Utility function to add edge</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v's list.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increasing inner degree of w by 1</span></span><br><span class=\"line\">    indegree[w]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Main recursive function to print all possible</span></span><br><span class=\"line\"><span class=\"comment\">//  topological sorts</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSortUtil(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span><br><span class=\"line\">                                   <span class=\"keyword\">bool</span> visited[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// To indicate whether all topological are found</span></span><br><span class=\"line\">    <span class=\"comment\">// or not</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  If indegree is 0 and not yet visited then</span></span><br><span class=\"line\">        <span class=\"comment\">//  only choose that vertex</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span> &amp;&amp; !visited[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  reducing indegree of adjacent vertices</span></span><br><span class=\"line\">            <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;:: iterator j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//  including in result</span></span><br><span class=\"line\">            res.push_back(i);</span><br><span class=\"line\">            visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            alltopologicalSortUtil(res, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// resetting visited, res and indegree for</span></span><br><span class=\"line\">            <span class=\"comment\">// backtracking</span></span><br><span class=\"line\">            visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            res.erase(res.end() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  We reach here if all vertices are visited.</span></span><br><span class=\"line\">    <span class=\"comment\">//  So we print the solution here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res.size(); i++)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  The function does all Topological Sort.</span></span><br><span class=\"line\"><span class=\"comment\">//  It uses recursive alltopologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    alltopologicalSortUtil(res, visited);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"All Topological sorts\\\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    g.alltopologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"判断是否为二叉搜索树（BST）","_content":"\n\n\n## 问题描述\n\n实现一个函数，判断一棵二叉树是否为二叉搜索树。\n\n\n\n## 算法思路\n\n- 二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。\n- 上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。\n- 基于left < current < right的特性，可以递归用大小值比较进行判断\n\n\n\n## 代码实现\n\n~~~cpp\n/* \n题目描述 \n \n请实现一个函数，检查一棵二叉树是否为二叉搜索树。 \n给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 \n*/  \n  \n#include <iostream>  \n#include <cstdlib>  \n#include <vector>  \n#include <queue>  \n  \nusing namespace std;  \n  \n/*二叉树节点数据结构*/  \nstruct TreeNode {  \n    int val;  \n    struct TreeNode *left;  \n    struct TreeNode *right;  \n    TreeNode(int x) :  \n        val(x), left(NULL), right(NULL) {  \n    }  \n};  \n  \nconst int flag = INT_MAX;  \nTreeNode *generateTree(vector<int> &nums)  \n{  \n    if (nums.empty())  \n        return NULL;  \n  \n    TreeNode *root = new TreeNode(nums[0]);  \n    queue<TreeNode *> que;  \n    que.push(root);  \n    //求出所给元素个数，对应二叉查找树节点个数  \n    int size = nums.size();  \n    for (int i = 1; i < size; i += 2)  \n    {  \n        //处理队首节点的左右子树  \n        TreeNode *tmp = que.front();  \n        TreeNode *left = NULL, *right = NULL;  \n        //定义非空左子树  \n        if (nums[i] != flag)  \n        {  \n            left = new TreeNode(nums[i]);  \n            que.push(left);  \n        }  \n  \n        //定义非空右子树  \n        if (i + 1 < size && nums[i + 1] != flag)  \n        {  \n            right = new TreeNode(nums[i + 1]);  \n            que.push(right);  \n        }  \n  \n        tmp->left = left;  \n        tmp->right = right;  \n        //弹出当前处理的节点  \n        que.pop();  \n    }  \n    return root;  \n}  \n  \nclass Checker {  \npublic:  \n  \n    /*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/  \n    void inOrder(TreeNode *root,vector<int> &v)  \n    {  \n        if (root == NULL)  \n            return;  \n        inOrder(root->left, v);  \n        v.push_back(root->val);  \n        inOrder(root->right, v);  \n    }  \n  \n    bool checkBST1(TreeNode* root)  \n    {  \n        vector<int> ret;  \n        inOrder(root, ret);  \n        for (auto i = ret.begin()+1; i != ret.end(); ++i)  \n        {  \n            if (*i < *(i - 1))  \n                return false;  \n        }  \n        return true;  \n    }  \n  \n    /*方法二、省掉线性空间，保存遍历的最后一个节点*/  \n    int lastVal = INT_MIN;  \n    bool checkBST2(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n  \n        /*递归检查左子树*/  \n        if (!checkBST2(root->left))  \n            return false;  \n  \n        /*比较当前节点，并更新已遍历节点最后的值*/  \n        if (root->val <= lastVal)  \n            return false;  \n        lastVal = root->val;  \n  \n        /*递归检查右子树*/  \n        if (!checkBST2(root->right))  \n            return false;  \n        return true;  \n    }  \n  \n    /*方法三，最大最小值法*/  \n    bool checkBST3(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n        return checkBST3(root, INT_MAX, INT_MIN);  \n    }  \n    bool checkBST3(TreeNode *root, int maxVal, int minVal)  \n    {  \n        if (!root)  \n            return true;  \n        if (root->val < minVal || root->val >= maxVal)  \n            return false;  \n        if (!checkBST3(root->left, root->val, minVal) || !checkBST3(root->right, maxVal, root->val))  \n            return false;  \n        return true;  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v = { 7, 6, flag, 4, flag, 2, 5, 8, 3, flag, flag, flag, flag, flag, flag };  \n    TreeNode *root = generateTree(v);  \n  \n    Checker c;  \n    bool ret = c.checkBST1(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST2(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST3(root);  \n  \n    cout << ret << endl;  \n  \n    system(\"pause\");  \n    return 0;  \n}  \n~~~\n\n","source":"_posts/Algorithm/Data-Structure/isBST.md","raw":"---\ntitle: 判断是否为二叉搜索树（BST）\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - tree\n---\n\n\n\n## 问题描述\n\n实现一个函数，判断一棵二叉树是否为二叉搜索树。\n\n\n\n## 算法思路\n\n- 二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。\n- 上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。\n- 基于left < current < right的特性，可以递归用大小值比较进行判断\n\n\n\n## 代码实现\n\n~~~cpp\n/* \n题目描述 \n \n请实现一个函数，检查一棵二叉树是否为二叉搜索树。 \n给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 \n*/  \n  \n#include <iostream>  \n#include <cstdlib>  \n#include <vector>  \n#include <queue>  \n  \nusing namespace std;  \n  \n/*二叉树节点数据结构*/  \nstruct TreeNode {  \n    int val;  \n    struct TreeNode *left;  \n    struct TreeNode *right;  \n    TreeNode(int x) :  \n        val(x), left(NULL), right(NULL) {  \n    }  \n};  \n  \nconst int flag = INT_MAX;  \nTreeNode *generateTree(vector<int> &nums)  \n{  \n    if (nums.empty())  \n        return NULL;  \n  \n    TreeNode *root = new TreeNode(nums[0]);  \n    queue<TreeNode *> que;  \n    que.push(root);  \n    //求出所给元素个数，对应二叉查找树节点个数  \n    int size = nums.size();  \n    for (int i = 1; i < size; i += 2)  \n    {  \n        //处理队首节点的左右子树  \n        TreeNode *tmp = que.front();  \n        TreeNode *left = NULL, *right = NULL;  \n        //定义非空左子树  \n        if (nums[i] != flag)  \n        {  \n            left = new TreeNode(nums[i]);  \n            que.push(left);  \n        }  \n  \n        //定义非空右子树  \n        if (i + 1 < size && nums[i + 1] != flag)  \n        {  \n            right = new TreeNode(nums[i + 1]);  \n            que.push(right);  \n        }  \n  \n        tmp->left = left;  \n        tmp->right = right;  \n        //弹出当前处理的节点  \n        que.pop();  \n    }  \n    return root;  \n}  \n  \nclass Checker {  \npublic:  \n  \n    /*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/  \n    void inOrder(TreeNode *root,vector<int> &v)  \n    {  \n        if (root == NULL)  \n            return;  \n        inOrder(root->left, v);  \n        v.push_back(root->val);  \n        inOrder(root->right, v);  \n    }  \n  \n    bool checkBST1(TreeNode* root)  \n    {  \n        vector<int> ret;  \n        inOrder(root, ret);  \n        for (auto i = ret.begin()+1; i != ret.end(); ++i)  \n        {  \n            if (*i < *(i - 1))  \n                return false;  \n        }  \n        return true;  \n    }  \n  \n    /*方法二、省掉线性空间，保存遍历的最后一个节点*/  \n    int lastVal = INT_MIN;  \n    bool checkBST2(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n  \n        /*递归检查左子树*/  \n        if (!checkBST2(root->left))  \n            return false;  \n  \n        /*比较当前节点，并更新已遍历节点最后的值*/  \n        if (root->val <= lastVal)  \n            return false;  \n        lastVal = root->val;  \n  \n        /*递归检查右子树*/  \n        if (!checkBST2(root->right))  \n            return false;  \n        return true;  \n    }  \n  \n    /*方法三，最大最小值法*/  \n    bool checkBST3(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n        return checkBST3(root, INT_MAX, INT_MIN);  \n    }  \n    bool checkBST3(TreeNode *root, int maxVal, int minVal)  \n    {  \n        if (!root)  \n            return true;  \n        if (root->val < minVal || root->val >= maxVal)  \n            return false;  \n        if (!checkBST3(root->left, root->val, minVal) || !checkBST3(root->right, maxVal, root->val))  \n            return false;  \n        return true;  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v = { 7, 6, flag, 4, flag, 2, 5, 8, 3, flag, flag, flag, flag, flag, flag };  \n    TreeNode *root = generateTree(v);  \n  \n    Checker c;  \n    bool ret = c.checkBST1(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST2(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST3(root);  \n  \n    cout << ret << endl;  \n  \n    system(\"pause\");  \n    return 0;  \n}  \n~~~\n\n","slug":"Algorithm/Data-Structure/isBST","published":1,"date":"2019-11-11T07:59:20.428Z","updated":"2019-11-29T02:58:14.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdb001hlon9vwkdm6ha","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>实现一个函数，判断一棵二叉树是否为二叉搜索树。</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ul>\n<li>二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。</li>\n<li>上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。</li>\n<li>基于left &lt; current &lt; right的特性，可以递归用大小值比较进行判断</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">题目描述 </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">请实现一个函数，检查一棵二叉树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*二叉树节点数据结构*/</span>  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span>  </span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) :  </span><br><span class=\"line\">        val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flag = INT_MAX;  </span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">generateTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty())  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; que;  </span><br><span class=\"line\">    que.push(root);  </span><br><span class=\"line\">    <span class=\"comment\">//求出所给元素个数，对应二叉查找树节点个数  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i += <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//处理队首节点的左右子树  </span></span><br><span class=\"line\">        TreeNode *tmp = que.front();  </span><br><span class=\"line\">        TreeNode *left = <span class=\"literal\">NULL</span>, *right = <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            left = <span class=\"keyword\">new</span> TreeNode(nums[i]);  </span><br><span class=\"line\">            que.push(left);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; size &amp;&amp; nums[i + <span class=\"number\">1</span>] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            right = <span class=\"keyword\">new</span> TreeNode(nums[i + <span class=\"number\">1</span>]);  </span><br><span class=\"line\">            que.push(right);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        tmp-&gt;left = left;  </span><br><span class=\"line\">        tmp-&gt;right = right;  </span><br><span class=\"line\">        <span class=\"comment\">//弹出当前处理的节点  </span></span><br><span class=\"line\">        que.pop();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Checker</span> &#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        inOrder(root-&gt;left, v);  </span><br><span class=\"line\">        v.push_back(root-&gt;val);  </span><br><span class=\"line\">        inOrder(root-&gt;right, v);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST1</span><span class=\"params\">(TreeNode* root)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;  </span><br><span class=\"line\">        inOrder(root, ret);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = ret.begin()+<span class=\"number\">1</span>; i != ret.end(); ++i)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*i &lt; *(i - <span class=\"number\">1</span>))  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法二、省掉线性空间，保存遍历的最后一个节点*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastVal = INT_MIN;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查左子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;left))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*比较当前节点，并更新已遍历节点最后的值*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt;= lastVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        lastVal = root-&gt;val;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查右子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;right))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法三，最大最小值法*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkBST3(root, INT_MAX, INT_MIN);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt;= maxVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST3(root-&gt;left, root-&gt;val, minVal) || !checkBST3(root-&gt;right, maxVal, root-&gt;val))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">7</span>, <span class=\"number\">6</span>, flag, <span class=\"number\">4</span>, flag, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, flag, flag, flag, flag, flag, flag &#125;;  </span><br><span class=\"line\">    TreeNode *root = generateTree(v);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Checker c;  </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = c.checkBST1(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST2(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST3(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>实现一个函数，判断一棵二叉树是否为二叉搜索树。</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ul>\n<li>二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。</li>\n<li>上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。</li>\n<li>基于left &lt; current &lt; right的特性，可以递归用大小值比较进行判断</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">题目描述 </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">请实现一个函数，检查一棵二叉树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*二叉树节点数据结构*/</span>  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span>  </span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) :  </span><br><span class=\"line\">        val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flag = INT_MAX;  </span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">generateTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty())  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; que;  </span><br><span class=\"line\">    que.push(root);  </span><br><span class=\"line\">    <span class=\"comment\">//求出所给元素个数，对应二叉查找树节点个数  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i += <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//处理队首节点的左右子树  </span></span><br><span class=\"line\">        TreeNode *tmp = que.front();  </span><br><span class=\"line\">        TreeNode *left = <span class=\"literal\">NULL</span>, *right = <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            left = <span class=\"keyword\">new</span> TreeNode(nums[i]);  </span><br><span class=\"line\">            que.push(left);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; size &amp;&amp; nums[i + <span class=\"number\">1</span>] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            right = <span class=\"keyword\">new</span> TreeNode(nums[i + <span class=\"number\">1</span>]);  </span><br><span class=\"line\">            que.push(right);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        tmp-&gt;left = left;  </span><br><span class=\"line\">        tmp-&gt;right = right;  </span><br><span class=\"line\">        <span class=\"comment\">//弹出当前处理的节点  </span></span><br><span class=\"line\">        que.pop();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Checker</span> &#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        inOrder(root-&gt;left, v);  </span><br><span class=\"line\">        v.push_back(root-&gt;val);  </span><br><span class=\"line\">        inOrder(root-&gt;right, v);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST1</span><span class=\"params\">(TreeNode* root)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;  </span><br><span class=\"line\">        inOrder(root, ret);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = ret.begin()+<span class=\"number\">1</span>; i != ret.end(); ++i)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*i &lt; *(i - <span class=\"number\">1</span>))  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法二、省掉线性空间，保存遍历的最后一个节点*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastVal = INT_MIN;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查左子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;left))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*比较当前节点，并更新已遍历节点最后的值*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt;= lastVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        lastVal = root-&gt;val;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查右子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;right))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法三，最大最小值法*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkBST3(root, INT_MAX, INT_MIN);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt;= maxVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST3(root-&gt;left, root-&gt;val, minVal) || !checkBST3(root-&gt;right, maxVal, root-&gt;val))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">7</span>, <span class=\"number\">6</span>, flag, <span class=\"number\">4</span>, flag, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, flag, flag, flag, flag, flag, flag &#125;;  </span><br><span class=\"line\">    TreeNode *root = generateTree(v);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Checker c;  </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = c.checkBST1(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST2(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST3(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"命令行的艺术(转载)","toc":true,"comments":0,"date":"2019-11-28T02:58:43.000Z","_content":"\n> 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\n\n- [前言](#前言)\n- [基础](#基础)\n- [日常使用](#日常使用)\n- [文件及数据处理](#文件及数据处理)\n- [系统调试](#系统调试)\n- [单行脚本](#单行脚本)\n- [冷门但有用](#冷门但有用)\n- [仅限 OS X 系统](#仅限-os-x-系统)\n- [仅限 Windows 系统](#仅限-windows-系统)\n- [更多资源](#更多资源)\n- [免责声明](#免责声明)\n\n这篇文章是[许多作者和译者](AUTHORS.md)共同的成果。\n这里的部分内容\n[首次](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[出现](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n于 [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know)，\n但已经迁移到了 [Github](https://github.com/jlevy/the-art-of-command-line)，并由众多高手做出了许多改进。\n如果你在本文中发现了错误或者存在可以改善的地方，请[**贡献你的一份力量**][](https://github.com/jlevy/the-art-of-command-line/blob/master/CONTRIBUTING.md)\n\n## 前言\n\n涵盖范围：\n\n- 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到*覆盖面广*（涉及所有重要的内容），*具体*（给出具体的最常用的例子），以及*简洁*（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。\n- 本文主要为 Linux 所写，但在[仅限 OS X 系统](#仅限-os-x-系统)章节和[仅限 Windows 系统](#仅限-windows-系统)章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。\n- 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。\n- 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。\n\n注意事项：\n\n- 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 `apt-get`，`yum`，`dnf`，`pacman`，\n`pip` 或 `brew`（以及其它合适的包管理器）来安装依赖的程序。\n- 遇到问题的话，请尝试使用 [Explainshell](http://explainshell.com/) 去获取相关命令、参数、管道等内容的解释。\n\n\n## 基础\n\n- 学习 Bash 的基础知识。具体地，在命令行中输入 `man bash` 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你*只*学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。\n\n- 熟悉至少一个基于文本的编辑器。通常而言 Vim （`vi`） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。\n\n- 学会如何使用 `man` 命令去阅读文档。学会使用 `apropos` 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 `help` 和 `help -d` 命令获取帮助信息。你可以用 `type 命令` 来判断这个命令到底是可执行文件、shell 内置命令还是别名。\n\n- 学会使用 `>` 和 `<` 来重定向输出和输入，学会使用 `|` 来重定向管道。明白 `>` 会覆盖了输出文件而 `>>` 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。\n\n- 学会使用通配符 `*` （或许再算上 `?` 和 `[`...`]`） 和引用以及引用中 `'` 和 `\"` 的区别（后文中有一些具体的例子）。\n\n- 熟悉 Bash 中的任务管理工具：`&`，**ctrl-z**，**ctrl-c**，`jobs`，`fg`，`bg`，`kill` 等。\n\n- 学会使用 `ssh` 进行远程命令行登录，最好知道如何使用 `ssh-agent`，`ssh-add` 等命令来实现基础的无密码认证登录。\n\n- 学会基本的文件管理工具：`ls` 和 `ls -l` （了解 `ls -l` 中每一列代表的意义），`less`，`head`，`tail` 和 `tail -f` （甚至 `less +F`），`ln` 和 `ln -s` （了解硬链接与软链接的区别），`chown`，`chmod`，`du` （硬盘使用情况概述：`du -hs *`）。 关于文件系统的管理，学习 `df`，`mount`，`fdisk`，`mkfs`，`lsblk`。知道 inode 是什么（与 `ls -i` 和 `df -i` 等命令相关）。\n\n- 学习基本的网络管理工具：`ip` 或 `ifconfig`，`dig`。\n\n- 学习并使用一种版本控制管理系统，例如 `git`。\n\n- 熟悉正则表达式，学会使用 `grep`／`egrep`，它们的参数中 `-i`，`-o`，`-v`，`-A`，`-B` 和 `-C` 这些是很常用并值得认真学习的。\n\n- 学会使用 `apt-get`，`yum`，`dnf` 或 `pacman` （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 `pip` 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 `pip` 来安装会很方便）。\n\n\n## 日常使用\n\n- 在 Bash 中，可以通过按 **Tab** 键实现自动补全参数，使用 **ctrl-r** 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 **ctrl-r** 会向后查找匹配项，按下 **Enter** 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。\n\n- 在 Bash 中，可以按下 **ctrl-w** 删除你键入的最后一个单词，**ctrl-u** 可以删除行内光标所在位置之前的内容，**alt-b** 和 **alt-f** 可以以单词为单位移动光标，**ctrl-a** 可以将光标移至行首，**ctrl-e** 可以将光标移至行尾，**ctrl-k** 可以删除光标至行尾的所有内容，**ctrl-l** 可以清屏。键入 `man readline` 可以查看 Bash 中的默认快捷键。内容有很多，例如 **alt-.** 循环地移向前一个参数，而 **alt-*** 可以展开通配符。\n\n\n- 你喜欢的话，可以执行 `set -o vi` 来使用 vi 风格的快捷键，而执行 `set -o emacs` 可以把它改回来。\n\n- 为了便于编辑长命令，在设置你的默认编辑器后（例如 `export EDITOR=vim`），**ctrl-x** **ctrl-e** 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 **escape-v**。\n\n- 键入 `history` 查看命令行历史记录，再用 `!n`（`n` 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 `!$`， 它用于指代上次键入的参数，而 `!!` 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 **ctrl-r** 和 **alt-.** 来实现。\n\n- `cd` 命令可以切换工作路径，输入 `cd ~` 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 `~`（例如 `~/.bashrc`）。在 `sh` 脚本里则用环境变量 `$HOME` 指代 home 目录的路径。\n\n- 回到前一个工作路径：`cd -`。\n\n- 如果你输入命令的时候中途改了主意，按下 **alt-#** 在行首添加 `#` 把它当做注释再按下回车执行（或者依次按下 **ctrl-a**， **#**， **enter**）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。\n\n- 使用 `xargs` （ 或 `parallel`）。他们非常给力。注意到你可以控制每行参数个数（`-L`）和最大并行数（`-P`）。如果你不确定它们是否会按你想的那样工作，先使用 `xargs echo` 查看一下。此外，使用 `-I{}` 会很方便。例如：\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n\n- `pstree -p` 以一种优雅的方式展示进程树。\n\n- 使用 `pgrep` 和 `pkill` 根据名字查找进程或发送信号（`-f` 参数通常有用）。\n\n- 了解你可以发往进程的信号的种类。比如，使用 `kill -STOP [pid]` 停止一个进程。使用 `man 7 signal` 查看详细列表。\n\n- 使用 `nohup` 或 `disown` 使一个后台进程持续运行。\n\n- 使用 `netstat -lntp` 或 `ss -plat` 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 `-u` 则检查 UDP 端口）或者 `lsof -iTCP -sTCP:LISTEN -P -n` (这也可以在 OS X 上运行)。\n\n- `lsof` 来查看开启的套接字和文件。\n\n- 使用 `uptime` 或 `w` 来查看系统已经运行多长时间。\n\n- 使用 `alias` 来创建常用命令的快捷形式。例如：`alias ll='ls -latr'` 创建了一个新的命令别名 `ll`。\n\n- 可以把别名、shell 选项和常用函数保存在 `~/.bashrc`，具体看下这篇[文章](http://superuser.com/a/183980/7106)。这样做的话你就可以在所有 shell 会话中使用你的设定。\n\n- 把环境变量的设定以及登陆时要执行的命令保存在 `~/.bash_profile`。而对于从图形界面启动的 shell 和 `cron` 启动的 shell，则需要单独配置文件。\n\n- 要想在几台电脑中同步你的配置文件（例如 `.bashrc` 和 `.bash_profile`），可以借助 Git。\n\n- 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 `\"$FOO\"`。尽量使用 `-0` 或 `-print0` 选项以便用 NULL 来分隔文件名，例如 `locate -0 pattern | xargs -0 ls -al` 或 `find / -print0 -type d | xargs -0 ls -al`。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 `IFS=$'\\n'` 把内部字段分隔符设为换行符。\n\n- 在 Bash 脚本中，使用 `set -x` 去调试输出（或者使用它的变体 `set -v`，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 `set -e` 令脚本在发生错误时退出而不是继续运行；使用 `set -u` 来检查是否使用了未赋值的变量；试试 `set -o pipefail`，它可以监测管道中的错误。当牵扯到很多脚本时，使用 `trap` 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- 在 Bash 脚本中，子 shell（使用括号 `(...)`）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- 在 Bash 中，变量有许多的扩展方式。`${name:?error message}` 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 `input_file=${1:?usage: $0 input_file}`。在变量为空时使用默认值：`${name:-default}`。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 `output_file=${2:-logfile}`，如果省略了 $2，它的值就为空，于是 `output_file` 就会被设为 `logfile`。数学表达式：`i=$(( (i + 1) % 5 ))`。序列：`{1..10}`。截断字符串：`${var%suffix}` 和 `${var#prefix}`。例如，假设 `var=foo.pdf`，那么 `echo ${var%.pdf}.txt` 将输出 `foo.txt`。\n\n- 使用括号扩展（`{`...`}`）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 `mv foo.{txt,pdf} some-dir`（同时移动两个文件），`cp somefile{,.bak}`（会被扩展成 `cp somefile somefile.bak`）或者 `mkdir -p test-{a,b,c}/subtest-{1,2,3}`（会被扩展成所有可能的组合，并创建一个目录树）。\n\n- 通过使用 `<(some command)` 可以将输出视为文件。例如，对比本地文件 `/etc/hosts` 和一个远程文件：\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。\n```bash\n{\n      # 在这里写代码\n}\n```\n\n- 了解 Bash 中的“here documents”，例如 `cat <<EOF ...`。\n\n- 在 Bash 中，同时重定向标准输出和标准错误：`some-command >logfile 2>&1` 或者 `some-command &>logfile`。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 `</dev/null` 是一个好习惯。\n\n- 使用 `man ascii` 查看具有十六进制和十进制值的ASCII表。`man unicode`，`man utf-8`，以及 `man latin1` 有助于你去了解通用的编码信息。\n\n- 使用 `screen` 或 [`tmux`](https://tmux.github.io/) 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 `byobu` 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 [`dtach`](https://github.com/bogner/dtach)。\n\n- ssh 中，了解如何使用 `-L` 或 `-D`（偶尔需要用 `-R`）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。\n\n- 对 ssh 设置做一些小优化可能是很有用的，例如这个 `~/.ssh/config` 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 `StrictHostKeyChecking=no`，`ForwardAgent=yes`。\n\n- 考虑使用 [`mosh`](https://mosh.mit.edu/) 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。\n\n- 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 `ls` 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 使用 [`percol`](https://github.com/mooz/percol) 或者 [`fzf`](https://github.com/junegunn/fzf) 可以交互式地从另一个命令输出中选取值。\n\n- 使用 `fpp`（[PathPicker](https://github.com/facebook/PathPicker)）可以与基于另一个命令(例如 `git`）输出的文件交互。\n\n- 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：\n`python -m SimpleHTTPServer 7777` （使用端口 7777 和 Python 2）或`python -m http.server 7777` （使用端口 7777 和 Python 3）。\n\n- 以其他用户的身份执行命令，使用 `sudo`。默认以 root 用户的身份执行；使用 `-u` 来指定其他用户。使用 `-i` 来以该用户登录（需要输入_你自己的_密码）。\n\n- 将 shell 切换为其他用户，使用 `su username` 或者 `sudo - username`。加入 `-` 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。\n\n- 了解命令行的 [128K 限制](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 `find` 或 `xargs` 通常可以解决。）\n\n- 当你需要一个基本的计算器时，可以使用 `python` 解释器（当然你要用 python 的时候也是这样）。例如：\n```\n>>> 2+3\n5\n```\n\n\n## 文件及数据处理\n\n- 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：`find . -iname '*something*'`。在所有路径下通过文件名查找文件，使用 `locate something` （但注意到 `updatedb` 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。\n\n- 使用 [`ag`](https://github.com/ggreer/the_silver_searcher) 在源代码或数据文件里检索（`grep -r` 同样可以做到，但相比之下 `ag` 更加先进）。\n\n- 将 HTML 转为文本：`lynx -dump -stdin`。\n\n- Markdown，HTML，以及所有文档格式之间的转换，试试 [`pandoc`](http://pandoc.org/)。\n\n- 当你要处理棘手的 XML 时候，`xmlstarlet` 算是上古时代流传下来的神器。\n\n- 使用 [`jq`](http://stedolan.github.io/jq/) 处理 JSON。\n\n- 使用 [`shyaml`](https://github.com/0k/shyaml) 处理 YAML。\n\n- 要处理 Excel 或 CSV 文件的话，[csvkit](https://github.com/onyxfish/csvkit) 提供了 `in2csv`，`csvcut`，`csvjoin`，`csvgrep` 等方便易用的工具。\n\n- 当你要处理 Amazon S3 相关的工作的时候，[`s3cmd`](https://github.com/s3tools/s3cmd) 是一个很方便的工具而 [`s4cmd`](https://github.com/bloomreach/s4cmd) 的效率更高。Amazon 官方提供的 [`aws`](https://github.com/aws/aws-cli) 以及  [`saws`](https://github.com/donnemartin/saws) 是其他 AWS 相关工作的基础，值得学习。\n\n- 了解如何使用 `sort` 和 `uniq`，包括 uniq 的 `-u` 参数和 `-d` 参数，具体内容在后文单行脚本节中。另外可以了解一下 `comm`。\n\n- 了解如何使用 `cut`，`paste` 和 `join` 来更改文件。很多人都会使用 `cut`，但遗忘了 `join`。\n\n- 了解如何运用 `wc` 去计算新行数（`-l`），字符数（`-m`），单词数（`-w`）以及字节数（`-c`）。\n\n- 了解如何使用 `tee` 将标准输入复制到文件甚至标准输出，例如 `ls -al | tee file.txt`。\n\n- 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 [`datamash`](https://www.gnu.org/software/datamash/)。\n\n- 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 `LANG` 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降*许多倍*。某些情况下（例如集合运算）你可以放心的使用 `export LC_ALL=C` 来忽略掉国际化并按照字节来判断顺序。\n\n- 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 `TZ=Pacific/Fiji date` 可以获取斐济的时间。\n\n- 了解如何使用 `awk` 和 `sed` 来进行简单的数据处理。 参阅 [One-liners](#one-liners) 获取示例。\n\n- 替换一个或多个文件中出现的字符串：\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 使用 [`repren`](https://github.com/jlevy/repren) 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 `rename` 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）\n```sh\n      # 将文件、目录和内容全部重命名 foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # 还原所有备份文件 whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # 用 rename 实现上述功能（若可用）:\n      rename 's/\\.bak$//' *.bak\n```\n\n- 根据 man 页面的描述，`rsync` 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 `rsync` 代替 `scp` 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的[最快方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)之一：\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- 若要在复制文件时获取当前进度，可使用 `pv`，[`pycp`](https://github.com/dmerejkowsky/pycp)，[`progress`](https://github.com/Xfennec/progress)，`rsync --progress`。若所执行的复制为block块拷贝，可以使用 `dd status=progress`。\n\n- 使用 `shuf` 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。\n\n- 了解 `sort` 的参数。显示数字时，使用 `-n` 或者 `-h` 来显示更易读的数（例如 `du -h` 的输出）。明白排序时关键字的工作原理（`-t` 和 `-k`）。例如，注意到你需要 `-k1，1` 来仅按第一个域来排序，而 `-k1` 意味着按整行排序。稳定排序（`sort -s`）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 `sort -k1，1 | sort -s -k2，2`。\n\n- 如果你想在 Bash 命令行中写 tab 制表符，按下 **ctrl-v** **[Tab]** 或键入 `$'\\t'` （后者可能更好，因为你可以复制粘贴它）。\n\n- 标准的源代码对比及合并工具是 `diff` 和 `patch`。使用 `diffstat` 查看变更总览数据。注意到 `diff -r` 对整个文件夹有效。使用 `diff -r tree1 tree2 | diffstat` 查看变更的统计数据。`vimdiff` 用于比对并编辑文件。\n\n- 对于二进制文件，使用 `hd`，`hexdump` 或者 `xxd` 使其以十六进制显示，使用 `bvi`，`hexedit` 或者 `biew` 来进行二进制编辑。\n\n- 同样对于二进制文件，`strings`（包括 `grep` 等工具）可以帮助在二进制文件中查找特定比特。\n\n- 制作二进制差分文件（Delta 压缩），使用 `xdelta3`。\n\n- 使用 `iconv` 更改文本编码。需要更高级的功能，可以使用 `uconv`，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- 拆分文件可以使用 `split`（按大小拆分）和 `csplit`（按模式拆分）。\n\n- 操作日期和时间表达式，可以用 [`dateutils`](http://www.fresse.org/dateutils/) 中的 `dateadd`、`datediff`、`strptime` 等工具。\n\n- 使用 `zless`、`zmore`、`zcat` 和 `zgrep` 对压缩过的文件进行操作。\n\n- 文件属性可以通过 `chattr` 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：`sudo chattr +i /critical/directory/or/file`\n\n- 使用 `getfacl` 和 `setfacl` 以保存和恢复文件权限。例如：\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- 为了高效地创建空文件，请使用 `truncate`（创建[稀疏文件](https://zh.wikipedia.org/wiki/稀疏文件)），`fallocate`（用于 ext4，xfs，btrf 和 ocfs2 文件系统），`xfs_mkfile`（适用于几乎所有的文件系统，包含在 xfsprogs 包中），`mkfile`（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。\n\n## 系统调试\n\n- `curl` 和 `curl -I` 可以被轻松地应用于 web 调试中，它们的好兄弟 `wget` 也是如此，或者也可以试试更潮的 [`httpie`](https://github.com/jkbrzt/httpie)。\n\n- 获取 CPU 和硬盘的使用状态，通常使用使用 `top`（`htop` 更佳），`iostat` 和 `iotop`。而 `iostat -mxz 15` 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。\n\n- 使用 `netstat` 和 `ss` 查看网络连接的细节。\n\n- `dstat` 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 [`glances`](https://github.com/nicolargo/glances)，它会在一个终端窗口中向你提供一些系统级的数据。\n\n- 若要了解内存状态，运行并理解 `free` 和 `vmstat` 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。\n\n- Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 `kill -3 <pid>` 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 `jps`，`jstat`，`jstack`，`jmap` 很有用。[SJK tools](https://github.com/aragozin/jvm-tools) 更高级。\n\n- 使用 [`mtr`](http://www.bitwizard.nl/mtr/) 去跟踪路由，用于确定网络问题。\n\n- 用 [`ncdu`](https://dev.yorhel.nl/ncdu) 来查看磁盘使用情况，它比寻常的命令，如 `du -sh *`，更节省时间。\n\n- 查找正在使用带宽的套接字连接或进程，使用 [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)。\n\n- `ab` 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 `siege`。\n\n- [`wireshark`](https://wireshark.org/)，[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) 和 [`ngrep`](http://ngrep.sourceforge.net/) 可用于复杂的网络调试。\n\n- 了解 `strace` 和 `ltrace`。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（`-c`）和附加到一个运行的进程参数 （`-p`）。\n\n- 了解使用 `ldd` 来检查共享库。但是[永远不要在不信任的文件上运行](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)。\n\n- 了解如何运用 `gdb` 连接到一个运行着的进程并获取它的堆栈轨迹。\n\n- 学会使用 `/proc`。它在调试正在出现的问题的时候有时会效果惊人。比如：`/proc/cpuinfo`，`/proc/meminfo`，`/proc/cmdline`，`/proc/xxx/cwd`，`/proc/xxx/exe`，`/proc/xxx/fd/`，`/proc/xxx/smaps`（这里的 `xxx` 表示进程的 id 或 pid）。\n\n- 当调试一些之前出现的问题的时候，[`sar`](http://sebastien.godard.pagesperso-orange.fr/) 非常有用。它展示了 cpu、内存以及网络等的历史数据。\n\n- 关于更深层次的系统分析以及性能分析，看看 `stap`（[SystemTap](https://sourceware.org/systemtap/wiki)），[`perf`](https://en.wikipedia.org/wiki/Perf_(Linux))，以及[`sysdig`](https://github.com/draios/sysdig)。\n\n- 查看你当前使用的系统，使用 `uname`，`uname -a`（Unix／kernel 信息）或者 `lsb_release -a`（Linux 发行版信息）。\n\n- 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 `dmesg`。\n\n- 如果你删除了一个文件，但通过 `du` 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## 单行脚本\n\n一些命令组合的例子：\n\n- 当你需要对文本文件做集合交、并、差运算时，`sort` 和 `uniq` 会是你的好帮手。具体例子请参照代码后面的，此处假设 `a` 与 `b` 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 `/tmp` 在一个小的根分区上时你可能需要 `-T` 参数，但是实际上 `sort` 并不被内存大小约束），参阅前文中关于 `LC_ALL` 和 `sort` 的 `-u` 参数的部分。\n```sh\n      sort a b | uniq > c   # c 是 a 并 b\n      sort a b | uniq -d > c   # c 是 a 交 b\n      sort a b b | uniq -u > c   # c 是 a - b\n```\n\n- 使用 `grep . *`（每行都会附上文件名）或者 `head -100 *`（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 `/sys`、`/proc`、`/etc`）时特别好用。\n\n\n- 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 `ls -l` 但比 `ls -lR` 更易于理解：\n```sh\n      find . -type f -ls\n```\n\n- 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 `acct_id` 参数在 URI 中。如果你想计算出每个 `acct_id` 值有多少次请求，使用如下代码：\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 要持续监测文件改动，可以使用 `watch`，例如检查某个文件夹中文件的改变，可以用 `watch -d -n 2 'ls -rtlh | tail'`；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 `watch -d -n 2 ifconfig`。\n\n- 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|\n          pandoc -f markdown -t html |\n          iconv -f 'utf-8' -t 'unicode' |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## 冷门但有用\n\n- `expr`：计算表达式或正则匹配\n\n- `m4`：简单的宏处理器\n\n- `yes`：多次打印字符串\n\n- `cal`：漂亮的日历\n\n- `env`：执行一个命令（脚本文件中很有用）\n\n- `printenv`：打印环境变量（调试时或在写脚本文件时很有用）\n\n- `look`：查找以特定字符串开头的单词或行\n\n- `cut`，`paste` 和 `join`：数据修改\n\n- `fmt`：格式化文本段落\n\n- `pr`：将文本格式化成页／列形式\n\n- `fold`：包裹文本中的几行\n\n- `column`：将文本格式化成多个对齐、定宽的列或表格\n\n- `expand` 和 `unexpand`：制表符与空格之间转换\n\n- `nl`：添加行号\n\n- `seq`：打印数字\n\n- `bc`：计算器\n\n- `factor`：分解因数\n\n- [`gpg`](https://gnupg.org/)：加密并签名文件\n\n- `toe`：terminfo 入口列表\n\n- `nc`：网络调试及数据传输\n\n- `socat`：套接字代理，与 `netcat` 类似\n\n- [`slurm`](https://github.com/mattthias/slurm)：网络流量可视化\n\n- `dd`：文件或设备间传输数据\n\n- `file`：确定文件类型\n\n- `tree`：以树的形式显示路径和文件，类似于递归的 `ls`\n\n- `stat`：文件信息\n\n- `time`：执行命令，并计算执行时间\n\n- `timeout`：在指定时长范围内执行命令，并在规定时间结束后停止进程\n\n- `lockfile`：使文件只能通过 `rm -f` 移除\n\n- `logrotate`： 切换、压缩以及发送日志文件\n\n- `watch`：重复运行同一个命令，展示结果并／或高亮有更改的部分\n\n- [`when-changed`](https://github.com/joh/when-changed)：当检测到文件更改时执行指定命令。参阅 `inotifywait` 和 `entr`。\n\n- `tac`：反向输出文件\n\n- `shuf`：文件中随机选取几行\n\n- `comm`：一行一行的比较排序过的文件\n\n- `strings`：从二进制文件中抽取文本\n\n- `tr`：转换字母\n\n- `iconv` 或 `uconv`：文本编码转换\n\n- `split` 和 `csplit`：分割文件\n\n- `sponge`：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 `grep -v something some-file | sponge some-file`\n\n- `units`：将一种计量单位转换为另一种等效的计量单位（参阅 `/usr/share/units/definitions.units`）\n\n- `apg`：随机生成密码\n\n- `xz`：高比例的文件压缩\n\n- `ldd`：动态库信息\n\n- `nm`：提取 obj 文件中的符号\n\n- `ab` 或 [`wrk`](https://github.com/wg/wrk)：web 服务器性能分析\n\n- `strace`：调试系统调用\n\n- [`mtr`](http://www.bitwizard.nl/mtr/)：更好的网络调试跟踪工具\n\n- `cssh`：可视化的并发 shell\n\n- `rsync`：通过 ssh 或本地文件系统同步文件和文件夹\n\n- [`wireshark`](https://wireshark.org/) 和 [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)：抓包和网络调试工具\n\n- [`ngrep`](http://ngrep.sourceforge.net/)：网络层的 grep\n\n- `host` 和 `dig`：DNS 查找\n\n- `lsof`：列出当前系统打开文件的工具以及查看端口信息\n\n- `dstat`：系统状态查看\n\n- [`glances`](https://github.com/nicolargo/glances)：高层次的多子系统总览\n\n- `iostat`：硬盘使用状态\n\n- `mpstat`： CPU 使用状态\n\n- `vmstat`： 内存使用状态\n\n- `htop`：top 的加强版\n\n- `last`：登入记录\n\n- `w`：查看处于登录状态的用户\n\n- `id`：用户/组 ID 信息\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/)：系统历史数据\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)：套接字及进程的网络利用情况\n\n- `ss`：套接字数据\n\n- `dmesg`：引导及系统错误信息\n\n- `sysctl`： 在内核运行时动态地查看和修改内核的运行参数\n\n- `hdparm`：SATA/ATA 磁盘更改及性能分析\n\n- `lsblk`：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息\n\n- `lshw`，`lscpu`，`lspci`，`lsusb` 和 `dmidecode`：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等\n\n- `lsmod` 和 `modinfo`：列出内核模块，并显示其细节\n\n- `fortune`，`ddate` 和 `sl`：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”\n\n\n## 仅限 OS X 系统\n\n以下是*仅限于* OS X 系统的技巧。\n\n- 用 `brew` （Homebrew）或者 `port` （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。\n\n- 用 `pbcopy` 复制任何命令的输出到桌面应用，用 `pbpaste` 粘贴输入。\n\n- 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 **alt-b**、**alt-f** 等命令中用到），打开 偏好设置 -> 描述文件 -> 键盘 并勾选“使用 Option 键作为 Meta 键”。\n\n- 用 `open` 或者 `open -a /Applications/Whatever.app` 使用桌面应用打开文件。\n\n- Spotlight：用 `mdfind` 搜索文件，用 `mdls` 列出元数据（例如照片的 EXIF 信息）。\n\n- 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 `ps`，`ls`，`tail`，`awk`，`sed`）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 \"BSD General Commands Manual\" 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 `gawk` 和 `gsed` 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 `perl` ）或者经过仔细的测试。\n\n- 用 `sw_vers` 获取 OS X 的版本信息。\n\n## 仅限 Windows 系统\n\n以下是*仅限于* Windows 系统的技巧。\n\n### 在 Winodws 下获取 Unix 工具\n\n- 可以安装 [Cygwin](https://cygwin.com/) 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。\n\n- 在 Windows 10 上，你可以使用 [Bash on Ubuntu on Windows](https://msdn.microsoft.com/commandline/wsl/about)，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。\n\n- 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。\n\n- 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 [Cash](https://github.com/dthree/cash)。注意在此环境下只有很少的 Unix 命令和命令行可用。\n\n### 实用 Windows 命令行工具\n\n- 可以使用 `wmic` 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。\n\n- Windows 实用的原生命令行网络工具包括 `ping`，`ipconfig`，`tracert`，和 `netstat`。\n\n- 可以使用 `Rundll32` 命令来实现[许多有用的 Windows 任务](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) 。\n\n### Cygwin 技巧\n\n- 通过 Cygwin 的包管理器来安装额外的 Unix 程序。\n\n- 使用 `mintty` 作为你的命令行窗口。\n\n- 要访问 Windows 剪贴板，可以通过 `/dev/clipboard`。\n\n- 运行 `cygstart` 以通过默认程序打开一个文件。\n\n- 要访问 Windows 注册表，可以使用 `regtool`。\n\n- 注意 Windows 驱动器路径 `C:\\` 在 Cygwin 中用 `/cygdrive/c` 代表，而 Cygwin 的 `/` 代表 Windows 中的 `C:\\cygwin`。要转换 Cygwin 和 Windows 风格的路径可以用 `cygpath`。这在需要调用 Windows 程序的脚本里很有用。\n\n- 学会使用 `wmic`，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。\n\n- 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 [Cash](https://github.com/dthree/cash)。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。\n\n- 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。\n\n## 更多资源\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell)：一份精心组织的命令行工具及资源的列表。\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)：一份针对 OS X 命令行的更深入的指南。\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)：为了编写更好的脚本文件。\n- [shellcheck](https://github.com/koalaman/shellcheck)：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)：有关如何在 shell 脚本里正确处理文件名的细枝末节。\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools)：用于数据科学的一些命令和工具，摘自同名书籍。\n\n## 免责声明\n\n除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 *有能力* 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)\n\n\n## 授权条款\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\n本文使用授权协议 [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)。","source":"_posts/the-art-of-command-line.md","raw":"---\ntitle: 命令行的艺术(转载)\ntoc: true\ncomments: false\ndate: 2019-11-28 10:58:43\ntags:\n---\n\n> 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\n\n- [前言](#前言)\n- [基础](#基础)\n- [日常使用](#日常使用)\n- [文件及数据处理](#文件及数据处理)\n- [系统调试](#系统调试)\n- [单行脚本](#单行脚本)\n- [冷门但有用](#冷门但有用)\n- [仅限 OS X 系统](#仅限-os-x-系统)\n- [仅限 Windows 系统](#仅限-windows-系统)\n- [更多资源](#更多资源)\n- [免责声明](#免责声明)\n\n这篇文章是[许多作者和译者](AUTHORS.md)共同的成果。\n这里的部分内容\n[首次](http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands)\n[出现](http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix)\n于 [Quora](http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know)，\n但已经迁移到了 [Github](https://github.com/jlevy/the-art-of-command-line)，并由众多高手做出了许多改进。\n如果你在本文中发现了错误或者存在可以改善的地方，请[**贡献你的一份力量**][](https://github.com/jlevy/the-art-of-command-line/blob/master/CONTRIBUTING.md)\n\n## 前言\n\n涵盖范围：\n\n- 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到*覆盖面广*（涉及所有重要的内容），*具体*（给出具体的最常用的例子），以及*简洁*（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。\n- 本文主要为 Linux 所写，但在[仅限 OS X 系统](#仅限-os-x-系统)章节和[仅限 Windows 系统](#仅限-windows-系统)章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。\n- 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。\n- 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。\n\n注意事项：\n\n- 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 `apt-get`，`yum`，`dnf`，`pacman`，\n`pip` 或 `brew`（以及其它合适的包管理器）来安装依赖的程序。\n- 遇到问题的话，请尝试使用 [Explainshell](http://explainshell.com/) 去获取相关命令、参数、管道等内容的解释。\n\n\n## 基础\n\n- 学习 Bash 的基础知识。具体地，在命令行中输入 `man bash` 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你*只*学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。\n\n- 熟悉至少一个基于文本的编辑器。通常而言 Vim （`vi`） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。\n\n- 学会如何使用 `man` 命令去阅读文档。学会使用 `apropos` 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 `help` 和 `help -d` 命令获取帮助信息。你可以用 `type 命令` 来判断这个命令到底是可执行文件、shell 内置命令还是别名。\n\n- 学会使用 `>` 和 `<` 来重定向输出和输入，学会使用 `|` 来重定向管道。明白 `>` 会覆盖了输出文件而 `>>` 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。\n\n- 学会使用通配符 `*` （或许再算上 `?` 和 `[`...`]`） 和引用以及引用中 `'` 和 `\"` 的区别（后文中有一些具体的例子）。\n\n- 熟悉 Bash 中的任务管理工具：`&`，**ctrl-z**，**ctrl-c**，`jobs`，`fg`，`bg`，`kill` 等。\n\n- 学会使用 `ssh` 进行远程命令行登录，最好知道如何使用 `ssh-agent`，`ssh-add` 等命令来实现基础的无密码认证登录。\n\n- 学会基本的文件管理工具：`ls` 和 `ls -l` （了解 `ls -l` 中每一列代表的意义），`less`，`head`，`tail` 和 `tail -f` （甚至 `less +F`），`ln` 和 `ln -s` （了解硬链接与软链接的区别），`chown`，`chmod`，`du` （硬盘使用情况概述：`du -hs *`）。 关于文件系统的管理，学习 `df`，`mount`，`fdisk`，`mkfs`，`lsblk`。知道 inode 是什么（与 `ls -i` 和 `df -i` 等命令相关）。\n\n- 学习基本的网络管理工具：`ip` 或 `ifconfig`，`dig`。\n\n- 学习并使用一种版本控制管理系统，例如 `git`。\n\n- 熟悉正则表达式，学会使用 `grep`／`egrep`，它们的参数中 `-i`，`-o`，`-v`，`-A`，`-B` 和 `-C` 这些是很常用并值得认真学习的。\n\n- 学会使用 `apt-get`，`yum`，`dnf` 或 `pacman` （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 `pip` 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 `pip` 来安装会很方便）。\n\n\n## 日常使用\n\n- 在 Bash 中，可以通过按 **Tab** 键实现自动补全参数，使用 **ctrl-r** 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 **ctrl-r** 会向后查找匹配项，按下 **Enter** 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。\n\n- 在 Bash 中，可以按下 **ctrl-w** 删除你键入的最后一个单词，**ctrl-u** 可以删除行内光标所在位置之前的内容，**alt-b** 和 **alt-f** 可以以单词为单位移动光标，**ctrl-a** 可以将光标移至行首，**ctrl-e** 可以将光标移至行尾，**ctrl-k** 可以删除光标至行尾的所有内容，**ctrl-l** 可以清屏。键入 `man readline` 可以查看 Bash 中的默认快捷键。内容有很多，例如 **alt-.** 循环地移向前一个参数，而 **alt-*** 可以展开通配符。\n\n\n- 你喜欢的话，可以执行 `set -o vi` 来使用 vi 风格的快捷键，而执行 `set -o emacs` 可以把它改回来。\n\n- 为了便于编辑长命令，在设置你的默认编辑器后（例如 `export EDITOR=vim`），**ctrl-x** **ctrl-e** 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 **escape-v**。\n\n- 键入 `history` 查看命令行历史记录，再用 `!n`（`n` 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 `!$`， 它用于指代上次键入的参数，而 `!!` 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 **ctrl-r** 和 **alt-.** 来实现。\n\n- `cd` 命令可以切换工作路径，输入 `cd ~` 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 `~`（例如 `~/.bashrc`）。在 `sh` 脚本里则用环境变量 `$HOME` 指代 home 目录的路径。\n\n- 回到前一个工作路径：`cd -`。\n\n- 如果你输入命令的时候中途改了主意，按下 **alt-#** 在行首添加 `#` 把它当做注释再按下回车执行（或者依次按下 **ctrl-a**， **#**， **enter**）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。\n\n- 使用 `xargs` （ 或 `parallel`）。他们非常给力。注意到你可以控制每行参数个数（`-L`）和最大并行数（`-P`）。如果你不确定它们是否会按你想的那样工作，先使用 `xargs echo` 查看一下。此外，使用 `-I{}` 会很方便。例如：\n```bash\n      find . -name '*.py' | xargs grep some_function\n      cat hosts | xargs -I{} ssh root@{} hostname\n```\n\n\n- `pstree -p` 以一种优雅的方式展示进程树。\n\n- 使用 `pgrep` 和 `pkill` 根据名字查找进程或发送信号（`-f` 参数通常有用）。\n\n- 了解你可以发往进程的信号的种类。比如，使用 `kill -STOP [pid]` 停止一个进程。使用 `man 7 signal` 查看详细列表。\n\n- 使用 `nohup` 或 `disown` 使一个后台进程持续运行。\n\n- 使用 `netstat -lntp` 或 `ss -plat` 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 `-u` 则检查 UDP 端口）或者 `lsof -iTCP -sTCP:LISTEN -P -n` (这也可以在 OS X 上运行)。\n\n- `lsof` 来查看开启的套接字和文件。\n\n- 使用 `uptime` 或 `w` 来查看系统已经运行多长时间。\n\n- 使用 `alias` 来创建常用命令的快捷形式。例如：`alias ll='ls -latr'` 创建了一个新的命令别名 `ll`。\n\n- 可以把别名、shell 选项和常用函数保存在 `~/.bashrc`，具体看下这篇[文章](http://superuser.com/a/183980/7106)。这样做的话你就可以在所有 shell 会话中使用你的设定。\n\n- 把环境变量的设定以及登陆时要执行的命令保存在 `~/.bash_profile`。而对于从图形界面启动的 shell 和 `cron` 启动的 shell，则需要单独配置文件。\n\n- 要想在几台电脑中同步你的配置文件（例如 `.bashrc` 和 `.bash_profile`），可以借助 Git。\n\n- 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 `\"$FOO\"`。尽量使用 `-0` 或 `-print0` 选项以便用 NULL 来分隔文件名，例如 `locate -0 pattern | xargs -0 ls -al` 或 `find / -print0 -type d | xargs -0 ls -al`。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 `IFS=$'\\n'` 把内部字段分隔符设为换行符。\n\n- 在 Bash 脚本中，使用 `set -x` 去调试输出（或者使用它的变体 `set -v`，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 `set -e` 令脚本在发生错误时退出而不是继续运行；使用 `set -u` 来检查是否使用了未赋值的变量；试试 `set -o pipefail`，它可以监测管道中的错误。当牵扯到很多脚本时，使用 `trap` 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：\n```bash\n      set -euo pipefail\n      trap \"echo 'error: Script failed: see failed command above'\" ERR\n```\n\n- 在 Bash 脚本中，子 shell（使用括号 `(...)`）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：\n```bash\n      # do something in current dir\n      (cd /some/other/dir && other-command)\n      # continue in original dir\n```\n\n- 在 Bash 中，变量有许多的扩展方式。`${name:?error message}` 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 `input_file=${1:?usage: $0 input_file}`。在变量为空时使用默认值：`${name:-default}`。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 `output_file=${2:-logfile}`，如果省略了 $2，它的值就为空，于是 `output_file` 就会被设为 `logfile`。数学表达式：`i=$(( (i + 1) % 5 ))`。序列：`{1..10}`。截断字符串：`${var%suffix}` 和 `${var#prefix}`。例如，假设 `var=foo.pdf`，那么 `echo ${var%.pdf}.txt` 将输出 `foo.txt`。\n\n- 使用括号扩展（`{`...`}`）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 `mv foo.{txt,pdf} some-dir`（同时移动两个文件），`cp somefile{,.bak}`（会被扩展成 `cp somefile somefile.bak`）或者 `mkdir -p test-{a,b,c}/subtest-{1,2,3}`（会被扩展成所有可能的组合，并创建一个目录树）。\n\n- 通过使用 `<(some command)` 可以将输出视为文件。例如，对比本地文件 `/etc/hosts` 和一个远程文件：\n```sh\n      diff /etc/hosts <(ssh somehost cat /etc/hosts)\n```\n\n- 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。\n```bash\n{\n      # 在这里写代码\n}\n```\n\n- 了解 Bash 中的“here documents”，例如 `cat <<EOF ...`。\n\n- 在 Bash 中，同时重定向标准输出和标准错误：`some-command >logfile 2>&1` 或者 `some-command &>logfile`。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 `</dev/null` 是一个好习惯。\n\n- 使用 `man ascii` 查看具有十六进制和十进制值的ASCII表。`man unicode`，`man utf-8`，以及 `man latin1` 有助于你去了解通用的编码信息。\n\n- 使用 `screen` 或 [`tmux`](https://tmux.github.io/) 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 `byobu` 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 [`dtach`](https://github.com/bogner/dtach)。\n\n- ssh 中，了解如何使用 `-L` 或 `-D`（偶尔需要用 `-R`）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。\n\n- 对 ssh 设置做一些小优化可能是很有用的，例如这个 `~/.ssh/config` 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：\n```\n      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n```\n\n- 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 `StrictHostKeyChecking=no`，`ForwardAgent=yes`。\n\n- 考虑使用 [`mosh`](https://mosh.mit.edu/) 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。\n\n- 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 `ls` 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：\n```sh\n      stat -c '%A %a %n' /etc/timezone\n```\n\n- 使用 [`percol`](https://github.com/mooz/percol) 或者 [`fzf`](https://github.com/junegunn/fzf) 可以交互式地从另一个命令输出中选取值。\n\n- 使用 `fpp`（[PathPicker](https://github.com/facebook/PathPicker)）可以与基于另一个命令(例如 `git`）输出的文件交互。\n\n- 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：\n`python -m SimpleHTTPServer 7777` （使用端口 7777 和 Python 2）或`python -m http.server 7777` （使用端口 7777 和 Python 3）。\n\n- 以其他用户的身份执行命令，使用 `sudo`。默认以 root 用户的身份执行；使用 `-u` 来指定其他用户。使用 `-i` 来以该用户登录（需要输入_你自己的_密码）。\n\n- 将 shell 切换为其他用户，使用 `su username` 或者 `sudo - username`。加入 `-` 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。\n\n- 了解命令行的 [128K 限制](https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong)。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 `find` 或 `xargs` 通常可以解决。）\n\n- 当你需要一个基本的计算器时，可以使用 `python` 解释器（当然你要用 python 的时候也是这样）。例如：\n```\n>>> 2+3\n5\n```\n\n\n## 文件及数据处理\n\n- 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：`find . -iname '*something*'`。在所有路径下通过文件名查找文件，使用 `locate something` （但注意到 `updatedb` 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。\n\n- 使用 [`ag`](https://github.com/ggreer/the_silver_searcher) 在源代码或数据文件里检索（`grep -r` 同样可以做到，但相比之下 `ag` 更加先进）。\n\n- 将 HTML 转为文本：`lynx -dump -stdin`。\n\n- Markdown，HTML，以及所有文档格式之间的转换，试试 [`pandoc`](http://pandoc.org/)。\n\n- 当你要处理棘手的 XML 时候，`xmlstarlet` 算是上古时代流传下来的神器。\n\n- 使用 [`jq`](http://stedolan.github.io/jq/) 处理 JSON。\n\n- 使用 [`shyaml`](https://github.com/0k/shyaml) 处理 YAML。\n\n- 要处理 Excel 或 CSV 文件的话，[csvkit](https://github.com/onyxfish/csvkit) 提供了 `in2csv`，`csvcut`，`csvjoin`，`csvgrep` 等方便易用的工具。\n\n- 当你要处理 Amazon S3 相关的工作的时候，[`s3cmd`](https://github.com/s3tools/s3cmd) 是一个很方便的工具而 [`s4cmd`](https://github.com/bloomreach/s4cmd) 的效率更高。Amazon 官方提供的 [`aws`](https://github.com/aws/aws-cli) 以及  [`saws`](https://github.com/donnemartin/saws) 是其他 AWS 相关工作的基础，值得学习。\n\n- 了解如何使用 `sort` 和 `uniq`，包括 uniq 的 `-u` 参数和 `-d` 参数，具体内容在后文单行脚本节中。另外可以了解一下 `comm`。\n\n- 了解如何使用 `cut`，`paste` 和 `join` 来更改文件。很多人都会使用 `cut`，但遗忘了 `join`。\n\n- 了解如何运用 `wc` 去计算新行数（`-l`），字符数（`-m`），单词数（`-w`）以及字节数（`-c`）。\n\n- 了解如何使用 `tee` 将标准输入复制到文件甚至标准输出，例如 `ls -al | tee file.txt`。\n\n- 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 [`datamash`](https://www.gnu.org/software/datamash/)。\n\n- 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 `LANG` 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降*许多倍*。某些情况下（例如集合运算）你可以放心的使用 `export LC_ALL=C` 来忽略掉国际化并按照字节来判断顺序。\n\n- 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 `TZ=Pacific/Fiji date` 可以获取斐济的时间。\n\n- 了解如何使用 `awk` 和 `sed` 来进行简单的数据处理。 参阅 [One-liners](#one-liners) 获取示例。\n\n- 替换一个或多个文件中出现的字符串：\n```sh\n      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt\n```\n\n- 使用 [`repren`](https://github.com/jlevy/repren) 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 `rename` 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）\n```sh\n      # 将文件、目录和内容全部重命名 foo -> bar:\n      repren --full --preserve-case --from foo --to bar .\n      # 还原所有备份文件 whatever.bak -> whatever:\n      repren --renames --from '(.*)\\.bak' --to '\\1' *.bak\n      # 用 rename 实现上述功能（若可用）:\n      rename 's/\\.bak$//' *.bak\n```\n\n- 根据 man 页面的描述，`rsync` 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 `rsync` 代替 `scp` 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的[最快方法](https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html)之一：\n```sh\nmkdir empty && rsync -r --delete empty/ some-dir && rmdir some-dir\n```\n\n- 若要在复制文件时获取当前进度，可使用 `pv`，[`pycp`](https://github.com/dmerejkowsky/pycp)，[`progress`](https://github.com/Xfennec/progress)，`rsync --progress`。若所执行的复制为block块拷贝，可以使用 `dd status=progress`。\n\n- 使用 `shuf` 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。\n\n- 了解 `sort` 的参数。显示数字时，使用 `-n` 或者 `-h` 来显示更易读的数（例如 `du -h` 的输出）。明白排序时关键字的工作原理（`-t` 和 `-k`）。例如，注意到你需要 `-k1，1` 来仅按第一个域来排序，而 `-k1` 意味着按整行排序。稳定排序（`sort -s`）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 `sort -k1，1 | sort -s -k2，2`。\n\n- 如果你想在 Bash 命令行中写 tab 制表符，按下 **ctrl-v** **[Tab]** 或键入 `$'\\t'` （后者可能更好，因为你可以复制粘贴它）。\n\n- 标准的源代码对比及合并工具是 `diff` 和 `patch`。使用 `diffstat` 查看变更总览数据。注意到 `diff -r` 对整个文件夹有效。使用 `diff -r tree1 tree2 | diffstat` 查看变更的统计数据。`vimdiff` 用于比对并编辑文件。\n\n- 对于二进制文件，使用 `hd`，`hexdump` 或者 `xxd` 使其以十六进制显示，使用 `bvi`，`hexedit` 或者 `biew` 来进行二进制编辑。\n\n- 同样对于二进制文件，`strings`（包括 `grep` 等工具）可以帮助在二进制文件中查找特定比特。\n\n- 制作二进制差分文件（Delta 压缩），使用 `xdelta3`。\n\n- 使用 `iconv` 更改文本编码。需要更高级的功能，可以使用 `uconv`，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：\n```sh\n      uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] >; ::Any-NFC; ' < input.txt > output.txt\n```\n\n- 拆分文件可以使用 `split`（按大小拆分）和 `csplit`（按模式拆分）。\n\n- 操作日期和时间表达式，可以用 [`dateutils`](http://www.fresse.org/dateutils/) 中的 `dateadd`、`datediff`、`strptime` 等工具。\n\n- 使用 `zless`、`zmore`、`zcat` 和 `zgrep` 对压缩过的文件进行操作。\n\n- 文件属性可以通过 `chattr` 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：`sudo chattr +i /critical/directory/or/file`\n\n- 使用 `getfacl` 和 `setfacl` 以保存和恢复文件权限。例如：\n```sh\n   getfacl -R /some/path > permissions.txt\n   setfacl --restore=permissions.txt\n```\n\n- 为了高效地创建空文件，请使用 `truncate`（创建[稀疏文件](https://zh.wikipedia.org/wiki/稀疏文件)），`fallocate`（用于 ext4，xfs，btrf 和 ocfs2 文件系统），`xfs_mkfile`（适用于几乎所有的文件系统，包含在 xfsprogs 包中），`mkfile`（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。\n\n## 系统调试\n\n- `curl` 和 `curl -I` 可以被轻松地应用于 web 调试中，它们的好兄弟 `wget` 也是如此，或者也可以试试更潮的 [`httpie`](https://github.com/jkbrzt/httpie)。\n\n- 获取 CPU 和硬盘的使用状态，通常使用使用 `top`（`htop` 更佳），`iostat` 和 `iotop`。而 `iostat -mxz 15` 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。\n\n- 使用 `netstat` 和 `ss` 查看网络连接的细节。\n\n- `dstat` 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 [`glances`](https://github.com/nicolargo/glances)，它会在一个终端窗口中向你提供一些系统级的数据。\n\n- 若要了解内存状态，运行并理解 `free` 和 `vmstat` 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。\n\n- Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 `kill -3 <pid>` 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 `jps`，`jstat`，`jstack`，`jmap` 很有用。[SJK tools](https://github.com/aragozin/jvm-tools) 更高级。\n\n- 使用 [`mtr`](http://www.bitwizard.nl/mtr/) 去跟踪路由，用于确定网络问题。\n\n- 用 [`ncdu`](https://dev.yorhel.nl/ncdu) 来查看磁盘使用情况，它比寻常的命令，如 `du -sh *`，更节省时间。\n\n- 查找正在使用带宽的套接字连接或进程，使用 [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)。\n\n- `ab` 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 `siege`。\n\n- [`wireshark`](https://wireshark.org/)，[`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html) 和 [`ngrep`](http://ngrep.sourceforge.net/) 可用于复杂的网络调试。\n\n- 了解 `strace` 和 `ltrace`。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（`-c`）和附加到一个运行的进程参数 （`-p`）。\n\n- 了解使用 `ldd` 来检查共享库。但是[永远不要在不信任的文件上运行](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)。\n\n- 了解如何运用 `gdb` 连接到一个运行着的进程并获取它的堆栈轨迹。\n\n- 学会使用 `/proc`。它在调试正在出现的问题的时候有时会效果惊人。比如：`/proc/cpuinfo`，`/proc/meminfo`，`/proc/cmdline`，`/proc/xxx/cwd`，`/proc/xxx/exe`，`/proc/xxx/fd/`，`/proc/xxx/smaps`（这里的 `xxx` 表示进程的 id 或 pid）。\n\n- 当调试一些之前出现的问题的时候，[`sar`](http://sebastien.godard.pagesperso-orange.fr/) 非常有用。它展示了 cpu、内存以及网络等的历史数据。\n\n- 关于更深层次的系统分析以及性能分析，看看 `stap`（[SystemTap](https://sourceware.org/systemtap/wiki)），[`perf`](https://en.wikipedia.org/wiki/Perf_(Linux))，以及[`sysdig`](https://github.com/draios/sysdig)。\n\n- 查看你当前使用的系统，使用 `uname`，`uname -a`（Unix／kernel 信息）或者 `lsb_release -a`（Linux 发行版信息）。\n\n- 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 `dmesg`。\n\n- 如果你删除了一个文件，但通过 `du` 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：\n`lsof | grep deleted | grep \"filename-of-my-big-file\"`\n\n\n## 单行脚本\n\n一些命令组合的例子：\n\n- 当你需要对文本文件做集合交、并、差运算时，`sort` 和 `uniq` 会是你的好帮手。具体例子请参照代码后面的，此处假设 `a` 与 `b` 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 `/tmp` 在一个小的根分区上时你可能需要 `-T` 参数，但是实际上 `sort` 并不被内存大小约束），参阅前文中关于 `LC_ALL` 和 `sort` 的 `-u` 参数的部分。\n```sh\n      sort a b | uniq > c   # c 是 a 并 b\n      sort a b | uniq -d > c   # c 是 a 交 b\n      sort a b b | uniq -u > c   # c 是 a - b\n```\n\n- 使用 `grep . *`（每行都会附上文件名）或者 `head -100 *`（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 `/sys`、`/proc`、`/etc`）时特别好用。\n\n\n- 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：\n```sh\n      awk '{ x += $3 } END { print x }' myfile\n```\n\n- 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 `ls -l` 但比 `ls -lR` 更易于理解：\n```sh\n      find . -type f -ls\n```\n\n- 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 `acct_id` 参数在 URI 中。如果你想计算出每个 `acct_id` 值有多少次请求，使用如下代码：\n```sh\n      egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn\n```\n\n- 要持续监测文件改动，可以使用 `watch`，例如检查某个文件夹中文件的改变，可以用 `watch -d -n 2 'ls -rtlh | tail'`；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 `watch -d -n 2 ifconfig`。\n\n- 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：\n```sh\n      function taocl() {\n        curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|\n          pandoc -f markdown -t html |\n          iconv -f 'utf-8' -t 'unicode' |\n          xmlstarlet fo --html --dropdtd |\n          xmlstarlet sel -t -v \"(html/body/ul/li[count(p)>0])[$RANDOM mod last()+1]\" |\n          xmlstarlet unesc | fmt -80\n      }\n```\n\n## 冷门但有用\n\n- `expr`：计算表达式或正则匹配\n\n- `m4`：简单的宏处理器\n\n- `yes`：多次打印字符串\n\n- `cal`：漂亮的日历\n\n- `env`：执行一个命令（脚本文件中很有用）\n\n- `printenv`：打印环境变量（调试时或在写脚本文件时很有用）\n\n- `look`：查找以特定字符串开头的单词或行\n\n- `cut`，`paste` 和 `join`：数据修改\n\n- `fmt`：格式化文本段落\n\n- `pr`：将文本格式化成页／列形式\n\n- `fold`：包裹文本中的几行\n\n- `column`：将文本格式化成多个对齐、定宽的列或表格\n\n- `expand` 和 `unexpand`：制表符与空格之间转换\n\n- `nl`：添加行号\n\n- `seq`：打印数字\n\n- `bc`：计算器\n\n- `factor`：分解因数\n\n- [`gpg`](https://gnupg.org/)：加密并签名文件\n\n- `toe`：terminfo 入口列表\n\n- `nc`：网络调试及数据传输\n\n- `socat`：套接字代理，与 `netcat` 类似\n\n- [`slurm`](https://github.com/mattthias/slurm)：网络流量可视化\n\n- `dd`：文件或设备间传输数据\n\n- `file`：确定文件类型\n\n- `tree`：以树的形式显示路径和文件，类似于递归的 `ls`\n\n- `stat`：文件信息\n\n- `time`：执行命令，并计算执行时间\n\n- `timeout`：在指定时长范围内执行命令，并在规定时间结束后停止进程\n\n- `lockfile`：使文件只能通过 `rm -f` 移除\n\n- `logrotate`： 切换、压缩以及发送日志文件\n\n- `watch`：重复运行同一个命令，展示结果并／或高亮有更改的部分\n\n- [`when-changed`](https://github.com/joh/when-changed)：当检测到文件更改时执行指定命令。参阅 `inotifywait` 和 `entr`。\n\n- `tac`：反向输出文件\n\n- `shuf`：文件中随机选取几行\n\n- `comm`：一行一行的比较排序过的文件\n\n- `strings`：从二进制文件中抽取文本\n\n- `tr`：转换字母\n\n- `iconv` 或 `uconv`：文本编码转换\n\n- `split` 和 `csplit`：分割文件\n\n- `sponge`：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 `grep -v something some-file | sponge some-file`\n\n- `units`：将一种计量单位转换为另一种等效的计量单位（参阅 `/usr/share/units/definitions.units`）\n\n- `apg`：随机生成密码\n\n- `xz`：高比例的文件压缩\n\n- `ldd`：动态库信息\n\n- `nm`：提取 obj 文件中的符号\n\n- `ab` 或 [`wrk`](https://github.com/wg/wrk)：web 服务器性能分析\n\n- `strace`：调试系统调用\n\n- [`mtr`](http://www.bitwizard.nl/mtr/)：更好的网络调试跟踪工具\n\n- `cssh`：可视化的并发 shell\n\n- `rsync`：通过 ssh 或本地文件系统同步文件和文件夹\n\n- [`wireshark`](https://wireshark.org/) 和 [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)：抓包和网络调试工具\n\n- [`ngrep`](http://ngrep.sourceforge.net/)：网络层的 grep\n\n- `host` 和 `dig`：DNS 查找\n\n- `lsof`：列出当前系统打开文件的工具以及查看端口信息\n\n- `dstat`：系统状态查看\n\n- [`glances`](https://github.com/nicolargo/glances)：高层次的多子系统总览\n\n- `iostat`：硬盘使用状态\n\n- `mpstat`： CPU 使用状态\n\n- `vmstat`： 内存使用状态\n\n- `htop`：top 的加强版\n\n- `last`：登入记录\n\n- `w`：查看处于登录状态的用户\n\n- `id`：用户/组 ID 信息\n\n- [`sar`](http://sebastien.godard.pagesperso-orange.fr/)：系统历史数据\n\n- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)：套接字及进程的网络利用情况\n\n- `ss`：套接字数据\n\n- `dmesg`：引导及系统错误信息\n\n- `sysctl`： 在内核运行时动态地查看和修改内核的运行参数\n\n- `hdparm`：SATA/ATA 磁盘更改及性能分析\n\n- `lsblk`：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息\n\n- `lshw`，`lscpu`，`lspci`，`lsusb` 和 `dmidecode`：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等\n\n- `lsmod` 和 `modinfo`：列出内核模块，并显示其细节\n\n- `fortune`，`ddate` 和 `sl`：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”\n\n\n## 仅限 OS X 系统\n\n以下是*仅限于* OS X 系统的技巧。\n\n- 用 `brew` （Homebrew）或者 `port` （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。\n\n- 用 `pbcopy` 复制任何命令的输出到桌面应用，用 `pbpaste` 粘贴输入。\n\n- 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 **alt-b**、**alt-f** 等命令中用到），打开 偏好设置 -> 描述文件 -> 键盘 并勾选“使用 Option 键作为 Meta 键”。\n\n- 用 `open` 或者 `open -a /Applications/Whatever.app` 使用桌面应用打开文件。\n\n- Spotlight：用 `mdfind` 搜索文件，用 `mdls` 列出元数据（例如照片的 EXIF 信息）。\n\n- 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 `ps`，`ls`，`tail`，`awk`，`sed`）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 \"BSD General Commands Manual\" 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 `gawk` 和 `gsed` 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 `perl` ）或者经过仔细的测试。\n\n- 用 `sw_vers` 获取 OS X 的版本信息。\n\n## 仅限 Windows 系统\n\n以下是*仅限于* Windows 系统的技巧。\n\n### 在 Winodws 下获取 Unix 工具\n\n- 可以安装 [Cygwin](https://cygwin.com/) 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。\n\n- 在 Windows 10 上，你可以使用 [Bash on Ubuntu on Windows](https://msdn.microsoft.com/commandline/wsl/about)，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。\n\n- 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。\n\n- 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 [Cash](https://github.com/dthree/cash)。注意在此环境下只有很少的 Unix 命令和命令行可用。\n\n### 实用 Windows 命令行工具\n\n- 可以使用 `wmic` 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。\n\n- Windows 实用的原生命令行网络工具包括 `ping`，`ipconfig`，`tracert`，和 `netstat`。\n\n- 可以使用 `Rundll32` 命令来实现[许多有用的 Windows 任务](http://www.thewindowsclub.com/rundll32-shortcut-commands-windows) 。\n\n### Cygwin 技巧\n\n- 通过 Cygwin 的包管理器来安装额外的 Unix 程序。\n\n- 使用 `mintty` 作为你的命令行窗口。\n\n- 要访问 Windows 剪贴板，可以通过 `/dev/clipboard`。\n\n- 运行 `cygstart` 以通过默认程序打开一个文件。\n\n- 要访问 Windows 注册表，可以使用 `regtool`。\n\n- 注意 Windows 驱动器路径 `C:\\` 在 Cygwin 中用 `/cygdrive/c` 代表，而 Cygwin 的 `/` 代表 Windows 中的 `C:\\cygwin`。要转换 Cygwin 和 Windows 风格的路径可以用 `cygpath`。这在需要调用 Windows 程序的脚本里很有用。\n\n- 学会使用 `wmic`，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。\n\n- 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 [Cash](https://github.com/dthree/cash)。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。\n\n- 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 [MinGW](http://www.mingw.org/) 以及它的 [MSYS](http://www.mingw.org/wiki/msys) 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。\n\n## 更多资源\n\n- [awesome-shell](https://github.com/alebcay/awesome-shell)：一份精心组织的命令行工具及资源的列表。\n- [awesome-osx-command-line](https://github.com/herrbischoff/awesome-osx-command-line)：一份针对 OS X 命令行的更深入的指南。\n- [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/)：为了编写更好的脚本文件。\n- [shellcheck](https://github.com/koalaman/shellcheck)：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。\n- [Filenames and Pathnames in Shell](http://www.dwheeler.com/essays/filenames-in-shell.html)：有关如何在 shell 脚本里正确处理文件名的细枝末节。\n- [Data Science at the Command Line](http://datascienceatthecommandline.com/#tools)：用于数据科学的一些命令和工具，摘自同名书籍。\n\n## 免责声明\n\n除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 *有能力* 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)\n\n\n## 授权条款\n\n[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)\n\n本文使用授权协议 [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)。","slug":"the-art-of-command-line","published":1,"updated":"2019-11-28T03:02:46.525Z","layout":"post","photos":[],"link":"","_id":"ck3mrzrdb001ilon95ucde1m8","content":"<blockquote>\n<p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p>\n</blockquote>\n<ul>\n<li><a href=\"#前言\">前言</a></li>\n<li><a href=\"#基础\">基础</a></li>\n<li><a href=\"#日常使用\">日常使用</a></li>\n<li><a href=\"#文件及数据处理\">文件及数据处理</a></li>\n<li><a href=\"#系统调试\">系统调试</a></li>\n<li><a href=\"#单行脚本\">单行脚本</a></li>\n<li><a href=\"#冷门但有用\">冷门但有用</a></li>\n<li><a href=\"#仅限-os-x-系统\">仅限 OS X 系统</a></li>\n<li><a href=\"#仅限-windows-系统\">仅限 Windows 系统</a></li>\n<li><a href=\"#更多资源\">更多资源</a></li>\n<li><a href=\"#免责声明\">免责声明</a></li>\n</ul>\n<p>这篇文章是<a href=\"AUTHORS.md\">许多作者和译者</a>共同的成果。<br>这里的部分内容<br><a href=\"http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands\" target=\"_blank\" rel=\"noopener\">首次</a><br><a href=\"http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix\" target=\"_blank\" rel=\"noopener\">出现</a><br>于 <a href=\"http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know\" target=\"_blank\" rel=\"noopener\">Quora</a>，<br>但已经迁移到了 <a href=\"https://github.com/jlevy/the-art-of-command-line\" target=\"_blank\" rel=\"noopener\">Github</a>，并由众多高手做出了许多改进。<br>如果你在本文中发现了错误或者存在可以改善的地方，请[<strong>贡献你的一份力量</strong>]<a href=\"https://github.com/jlevy/the-art-of-command-line/blob/master/CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>涵盖范围：</p>\n<ul>\n<li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li>\n<li>本文主要为 Linux 所写，但在<a href=\"#仅限-os-x-系统\">仅限 OS X 系统</a>章节和<a href=\"#仅限-windows-系统\">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li>\n<li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li>\n<li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br><code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li>\n<li>遇到问题的话，请尝试使用 <a href=\"http://explainshell.com/\" target=\"_blank\" rel=\"noopener\">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p>\n</li>\n<li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p>\n</li>\n<li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p>\n</li>\n<li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p>\n</li>\n<li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别（后文中有一些具体的例子）。</p>\n</li>\n<li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p>\n</li>\n<li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p>\n</li>\n<li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p>\n</li>\n<li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p>\n</li>\n<li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p>\n</li>\n<li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p>\n</li>\n<li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p>\n</li>\n</ul>\n<h2 id=\"日常使用\"><a href=\"#日常使用\" class=\"headerlink\" title=\"日常使用\"></a>日常使用</h2><ul>\n<li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p>\n</li>\n<li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-*</strong> 可以展开通配符。</p>\n</li>\n</ul>\n<ul>\n<li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p>\n</li>\n<li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p>\n</li>\n<li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p>\n</li>\n<li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>~</code>（例如 <code>~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p>\n</li>\n<li><p>回到前一个工作路径：<code>cd -</code>。</p>\n</li>\n<li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p>\n</li>\n<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name <span class=\"string\">'*.py'</span> | xargs grep some_function</span><br><span class=\"line\">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p>\n</li>\n<li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p>\n</li>\n<li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p>\n</li>\n<li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p>\n</li>\n<li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p>\n</li>\n<li><p><code>lsof</code> 来查看开启的套接字和文件。</p>\n</li>\n<li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p>\n</li>\n<li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 创建了一个新的命令别名 <code>ll</code>。</p>\n</li>\n<li><p>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href=\"http://superuser.com/a/183980/7106\" target=\"_blank\" rel=\"noopener\">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p>\n</li>\n<li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p>\n</li>\n<li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p>\n</li>\n<li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>&quot;$FOO&quot;</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$&#39;\\n&#39;</code> 把内部字段分隔符设为换行符。</p>\n</li>\n<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> -euo pipefail</span><br><span class=\"line\"><span class=\"built_in\">trap</span> <span class=\"string\">\"echo 'error: Script failed: see failed command above'\"</span> ERR</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># do something in current dir</span></span><br><span class=\"line\">(<span class=\"built_in\">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class=\"line\"><span class=\"comment\"># continue in original dir</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 Bash 中，变量有许多的扩展方式。<code>${name:?error message}</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。在变量为空时使用默认值：<code>${name:-default}</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=${2:-logfile}</code>，如果省略了 $2，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>\n</li>\n<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>\n</li>\n<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      <span class=\"comment\"># 在这里写代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>\n</li>\n<li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>\n</li>\n<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>\n</li>\n<li><p>使用 <code>screen</code> 或 <a href=\"https://tmux.github.io/\" target=\"_blank\" rel=\"noopener\"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href=\"https://github.com/bogner/dtach\" target=\"_blank\" rel=\"noopener\"><code>dtach</code></a>。</p>\n</li>\n<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p>\n</li>\n<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCPKeepAlive=yes</span><br><span class=\"line\">ServerAliveInterval=15</span><br><span class=\"line\">ServerAliveCountMax=6</span><br><span class=\"line\">Compression=yes</span><br><span class=\"line\">ControlMaster auto</span><br><span class=\"line\">ControlPath /tmp/%r@%h:%p</span><br><span class=\"line\">ControlPersist yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p>\n</li>\n<li><p>考虑使用 <a href=\"https://mosh.mit.edu/\" target=\"_blank\" rel=\"noopener\"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p>\n</li>\n<li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stat</span> -c <span class=\"string\">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <a href=\"https://github.com/mooz/percol\" target=\"_blank\" rel=\"noopener\"><code>percol</code></a> 或者 <a href=\"https://github.com/junegunn/fzf\" target=\"_blank\" rel=\"noopener\"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>\n</li>\n<li><p>使用 <code>fpp</code>（<a href=\"https://github.com/facebook/PathPicker\" target=\"_blank\" rel=\"noopener\">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>\n</li>\n<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>\n</li>\n<li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入<em>你自己的</em>密码）。</p>\n</li>\n<li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>sudo - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入<em>哪个用户的</em>密码。</p>\n</li>\n<li><p>了解命令行的 <a href=\"https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong\" target=\"_blank\" rel=\"noopener\">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p>\n</li>\n<li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 2+3</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件及数据处理\"><a href=\"#文件及数据处理\" class=\"headerlink\" title=\"文件及数据处理\"></a>文件及数据处理</h2><ul>\n<li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname &#39;*something*&#39;</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p>\n</li>\n<li><p>使用 <a href=\"https://github.com/ggreer/the_silver_searcher\" target=\"_blank\" rel=\"noopener\"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p>\n</li>\n<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p>\n</li>\n<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href=\"http://pandoc.org/\" target=\"_blank\" rel=\"noopener\"><code>pandoc</code></a>。</p>\n</li>\n<li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p>\n</li>\n<li><p>使用 <a href=\"http://stedolan.github.io/jq/\" target=\"_blank\" rel=\"noopener\"><code>jq</code></a> 处理 JSON。</p>\n</li>\n<li><p>使用 <a href=\"https://github.com/0k/shyaml\" target=\"_blank\" rel=\"noopener\"><code>shyaml</code></a> 处理 YAML。</p>\n</li>\n<li><p>要处理 Excel 或 CSV 文件的话，<a href=\"https://github.com/onyxfish/csvkit\" target=\"_blank\" rel=\"noopener\">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p>\n</li>\n<li><p>当你要处理 Amazon S3 相关的工作的时候，<a href=\"https://github.com/s3tools/s3cmd\" target=\"_blank\" rel=\"noopener\"><code>s3cmd</code></a> 是一个很方便的工具而 <a href=\"https://github.com/bloomreach/s4cmd\" target=\"_blank\" rel=\"noopener\"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href=\"https://github.com/aws/aws-cli\" target=\"_blank\" rel=\"noopener\"><code>aws</code></a> 以及  <a href=\"https://github.com/donnemartin/saws\" target=\"_blank\" rel=\"noopener\"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p>\n</li>\n<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p>\n</li>\n<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p>\n</li>\n<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>\n</li>\n<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>\n</li>\n<li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href=\"https://www.gnu.org/software/datamash/\" target=\"_blank\" rel=\"noopener\"><code>datamash</code></a>。</p>\n</li>\n<li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p>\n</li>\n<li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p>\n</li>\n<li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href=\"#one-liners\">One-liners</a> 获取示例。</p>\n</li>\n<li><p>替换一个或多个文件中出现的字符串：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perl -pi.bak -e <span class=\"string\">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <a href=\"https://github.com/jlevy/repren\" target=\"_blank\" rel=\"noopener\"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件、目录和内容全部重命名 foo -&gt; bar:</span></span><br><span class=\"line\">repren --full --preserve-case --from foo --to bar .</span><br><span class=\"line\"><span class=\"comment\"># 还原所有备份文件 whatever.bak -&gt; whatever:</span></span><br><span class=\"line\">repren --renames --from <span class=\"string\">'(.*)\\.bak'</span> --to <span class=\"string\">'\\1'</span> *.bak</span><br><span class=\"line\"><span class=\"comment\"># 用 rename 实现上述功能（若可用）:</span></span><br><span class=\"line\">rename <span class=\"string\">'s/\\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href=\"https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html\" target=\"_blank\" rel=\"noopener\">最快方法</a>之一：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href=\"https://github.com/dmerejkowsky/pycp\" target=\"_blank\" rel=\"noopener\"><code>pycp</code></a>，<a href=\"https://github.com/Xfennec/progress\" target=\"_blank\" rel=\"noopener\"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p>\n</li>\n<li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p>\n</li>\n<li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>\n</li>\n<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>\n</li>\n<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p>\n</li>\n<li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p>\n</li>\n<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p>\n</li>\n<li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p>\n</li>\n<li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uconv -f utf-8 -t utf-8 -x <span class=\"string\">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>\n</li>\n<li><p>操作日期和时间表达式，可以用 <a href=\"http://www.fresse.org/dateutils/\" target=\"_blank\" rel=\"noopener\"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p>\n</li>\n<li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>\n</li>\n<li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p>\n</li>\n<li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getfacl -R /some/path &gt; permissions.txt</span><br><span class=\"line\">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href=\"https://zh.wikipedia.org/wiki/稀疏文件\" target=\"_blank\" rel=\"noopener\">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</p>\n</li>\n</ul>\n<h2 id=\"系统调试\"><a href=\"#系统调试\" class=\"headerlink\" title=\"系统调试\"></a>系统调试</h2><ul>\n<li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href=\"https://github.com/jkbrzt/httpie\" target=\"_blank\" rel=\"noopener\"><code>httpie</code></a>。</p>\n</li>\n<li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p>\n</li>\n<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>\n</li>\n<li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href=\"https://github.com/nicolargo/glances\" target=\"_blank\" rel=\"noopener\"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p>\n</li>\n<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p>\n</li>\n<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href=\"https://github.com/aragozin/jvm-tools\" target=\"_blank\" rel=\"noopener\">SJK tools</a> 更高级。</p>\n</li>\n<li><p>使用 <a href=\"http://www.bitwizard.nl/mtr/\" target=\"_blank\" rel=\"noopener\"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p>\n</li>\n<li><p>用 <a href=\"https://dev.yorhel.nl/ncdu\" target=\"_blank\" rel=\"noopener\"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p>\n</li>\n<li><p>查找正在使用带宽的套接字连接或进程，使用 <a href=\"http://www.ex-parrot.com/~pdw/iftop/\" target=\"_blank\" rel=\"noopener\"><code>iftop</code></a> 或 <a href=\"https://github.com/raboof/nethogs\" target=\"_blank\" rel=\"noopener\"><code>nethogs</code></a>。</p>\n</li>\n<li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>\n</li>\n<li><p><a href=\"https://wireshark.org/\" target=\"_blank\" rel=\"noopener\"><code>wireshark</code></a>，<a href=\"https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html\" target=\"_blank\" rel=\"noopener\"><code>tshark</code></a> 和 <a href=\"http://ngrep.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><code>ngrep</code></a> 可用于复杂的网络调试。</p>\n</li>\n<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>\n</li>\n<li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href=\"http://www.catonmat.net/blog/ldd-arbitrary-code-execution/\" target=\"_blank\" rel=\"noopener\">永远不要在不信任的文件上运行</a>。</p>\n</li>\n<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>\n</li>\n<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>\n</li>\n<li><p>当调试一些之前出现的问题的时候，<a href=\"http://sebastien.godard.pagesperso-orange.fr/\" target=\"_blank\" rel=\"noopener\"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>\n</li>\n<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href=\"https://sourceware.org/systemtap/wiki\" target=\"_blank\" rel=\"noopener\">SystemTap</a>），<a href=\"https://en.wikipedia.org/wiki/Perf_(Linux\" target=\"_blank\" rel=\"noopener\"><code>perf</code></a>)，以及<a href=\"https://github.com/draios/sysdig\" target=\"_blank\" rel=\"noopener\"><code>sysdig</code></a>。</p>\n</li>\n<li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p>\n</li>\n<li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p>\n</li>\n<li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br><code>lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;</code></p>\n</li>\n</ul>\n<h2 id=\"单行脚本\"><a href=\"#单行脚本\" class=\"headerlink\" title=\"单行脚本\"></a>单行脚本</h2><p>一些命令组合的例子：</p>\n<ul>\n<li><p>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort a b | uniq &gt; c   <span class=\"comment\"># c 是 a 并 b</span></span><br><span class=\"line\">sort a b | uniq -d &gt; c   <span class=\"comment\"># c 是 a 交 b</span></span><br><span class=\"line\">sort a b b | uniq -u &gt; c   <span class=\"comment\"># c 是 a - b</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>\n</li>\n</ul>\n<ul>\n<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk <span class=\"string\">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -<span class=\"built_in\">type</span> f -ls</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">egrep -o <span class=\"string\">'acct_id=[0-9]+'</span> access.log | cut -d= -f2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 &#39;ls -rtlh | tail&#39;</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p>\n</li>\n<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">taocl</span></span>() &#123;</span><br><span class=\"line\">  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class=\"line\">    pandoc -f markdown -t html |</span><br><span class=\"line\">    iconv -f <span class=\"string\">'utf-8'</span> -t <span class=\"string\">'unicode'</span> |</span><br><span class=\"line\">    xmlstarlet fo --html --dropdtd |</span><br><span class=\"line\">    xmlstarlet sel -t -v <span class=\"string\">\"(html/body/ul/li[count(p)&gt;0])[<span class=\"variable\">$RANDOM</span> mod last()+1]\"</span> |</span><br><span class=\"line\">    xmlstarlet unesc | fmt -80</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"冷门但有用\"><a href=\"#冷门但有用\" class=\"headerlink\" title=\"冷门但有用\"></a>冷门但有用</h2><ul>\n<li><p><code>expr</code>：计算表达式或正则匹配</p>\n</li>\n<li><p><code>m4</code>：简单的宏处理器</p>\n</li>\n<li><p><code>yes</code>：多次打印字符串</p>\n</li>\n<li><p><code>cal</code>：漂亮的日历</p>\n</li>\n<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>\n</li>\n<li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p>\n</li>\n<li><p><code>look</code>：查找以特定字符串开头的单词或行</p>\n</li>\n<li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p>\n</li>\n<li><p><code>fmt</code>：格式化文本段落</p>\n</li>\n<li><p><code>pr</code>：将文本格式化成页／列形式</p>\n</li>\n<li><p><code>fold</code>：包裹文本中的几行</p>\n</li>\n<li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p>\n</li>\n<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>\n</li>\n<li><p><code>nl</code>：添加行号</p>\n</li>\n<li><p><code>seq</code>：打印数字</p>\n</li>\n<li><p><code>bc</code>：计算器</p>\n</li>\n<li><p><code>factor</code>：分解因数</p>\n</li>\n<li><p><a href=\"https://gnupg.org/\" target=\"_blank\" rel=\"noopener\"><code>gpg</code></a>：加密并签名文件</p>\n</li>\n<li><p><code>toe</code>：terminfo 入口列表</p>\n</li>\n<li><p><code>nc</code>：网络调试及数据传输</p>\n</li>\n<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>\n</li>\n<li><p><a href=\"https://github.com/mattthias/slurm\" target=\"_blank\" rel=\"noopener\"><code>slurm</code></a>：网络流量可视化</p>\n</li>\n<li><p><code>dd</code>：文件或设备间传输数据</p>\n</li>\n<li><p><code>file</code>：确定文件类型</p>\n</li>\n<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>\n</li>\n<li><p><code>stat</code>：文件信息</p>\n</li>\n<li><p><code>time</code>：执行命令，并计算执行时间</p>\n</li>\n<li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p>\n</li>\n<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>\n</li>\n<li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p>\n</li>\n<li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p>\n</li>\n<li><p><a href=\"https://github.com/joh/when-changed\" target=\"_blank\" rel=\"noopener\"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p>\n</li>\n<li><p><code>tac</code>：反向输出文件</p>\n</li>\n<li><p><code>shuf</code>：文件中随机选取几行</p>\n</li>\n<li><p><code>comm</code>：一行一行的比较排序过的文件</p>\n</li>\n<li><p><code>strings</code>：从二进制文件中抽取文本</p>\n</li>\n<li><p><code>tr</code>：转换字母</p>\n</li>\n<li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p>\n</li>\n<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>\n</li>\n<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>\n</li>\n<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>\n</li>\n<li><p><code>apg</code>：随机生成密码</p>\n</li>\n<li><p><code>xz</code>：高比例的文件压缩</p>\n</li>\n<li><p><code>ldd</code>：动态库信息</p>\n</li>\n<li><p><code>nm</code>：提取 obj 文件中的符号</p>\n</li>\n<li><p><code>ab</code> 或 <a href=\"https://github.com/wg/wrk\" target=\"_blank\" rel=\"noopener\"><code>wrk</code></a>：web 服务器性能分析</p>\n</li>\n<li><p><code>strace</code>：调试系统调用</p>\n</li>\n<li><p><a href=\"http://www.bitwizard.nl/mtr/\" target=\"_blank\" rel=\"noopener\"><code>mtr</code></a>：更好的网络调试跟踪工具</p>\n</li>\n<li><p><code>cssh</code>：可视化的并发 shell</p>\n</li>\n<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>\n</li>\n<li><p><a href=\"https://wireshark.org/\" target=\"_blank\" rel=\"noopener\"><code>wireshark</code></a> 和 <a href=\"https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html\" target=\"_blank\" rel=\"noopener\"><code>tshark</code></a>：抓包和网络调试工具</p>\n</li>\n<li><p><a href=\"http://ngrep.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><code>ngrep</code></a>：网络层的 grep</p>\n</li>\n<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>\n</li>\n<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>\n</li>\n<li><p><code>dstat</code>：系统状态查看</p>\n</li>\n<li><p><a href=\"https://github.com/nicolargo/glances\" target=\"_blank\" rel=\"noopener\"><code>glances</code></a>：高层次的多子系统总览</p>\n</li>\n<li><p><code>iostat</code>：硬盘使用状态</p>\n</li>\n<li><p><code>mpstat</code>： CPU 使用状态</p>\n</li>\n<li><p><code>vmstat</code>： 内存使用状态</p>\n</li>\n<li><p><code>htop</code>：top 的加强版</p>\n</li>\n<li><p><code>last</code>：登入记录</p>\n</li>\n<li><p><code>w</code>：查看处于登录状态的用户</p>\n</li>\n<li><p><code>id</code>：用户/组 ID 信息</p>\n</li>\n<li><p><a href=\"http://sebastien.godard.pagesperso-orange.fr/\" target=\"_blank\" rel=\"noopener\"><code>sar</code></a>：系统历史数据</p>\n</li>\n<li><p><a href=\"http://www.ex-parrot.com/~pdw/iftop/\" target=\"_blank\" rel=\"noopener\"><code>iftop</code></a> 或 <a href=\"https://github.com/raboof/nethogs\" target=\"_blank\" rel=\"noopener\"><code>nethogs</code></a>：套接字及进程的网络利用情况</p>\n</li>\n<li><p><code>ss</code>：套接字数据</p>\n</li>\n<li><p><code>dmesg</code>：引导及系统错误信息</p>\n</li>\n<li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p>\n</li>\n<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>\n</li>\n<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>\n</li>\n<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>\n</li>\n<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>\n</li>\n<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>\n</li>\n</ul>\n<h2 id=\"仅限-OS-X-系统\"><a href=\"#仅限-OS-X-系统\" class=\"headerlink\" title=\"仅限 OS X 系统\"></a>仅限 OS X 系统</h2><p>以下是<em>仅限于</em> OS X 系统的技巧。</p>\n<ul>\n<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p>\n</li>\n<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>\n</li>\n<li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>\n</li>\n<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>\n</li>\n<li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>\n</li>\n<li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>\n</li>\n<li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p>\n</li>\n</ul>\n<h2 id=\"仅限-Windows-系统\"><a href=\"#仅限-Windows-系统\" class=\"headerlink\" title=\"仅限 Windows 系统\"></a>仅限 Windows 系统</h2><p>以下是<em>仅限于</em> Windows 系统的技巧。</p>\n<h3 id=\"在-Winodws-下获取-Unix-工具\"><a href=\"#在-Winodws-下获取-Unix-工具\" class=\"headerlink\" title=\"在 Winodws 下获取 Unix 工具\"></a>在 Winodws 下获取 Unix 工具</h3><ul>\n<li><p>可以安装 <a href=\"https://cygwin.com/\" target=\"_blank\" rel=\"noopener\">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p>\n</li>\n<li><p>在 Windows 10 上，你可以使用 <a href=\"https://msdn.microsoft.com/commandline/wsl/about\" target=\"_blank\" rel=\"noopener\">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p>\n</li>\n<li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"noopener\">MinGW</a> 以及它的 <a href=\"http://www.mingw.org/wiki/msys\" target=\"_blank\" rel=\"noopener\">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p>\n</li>\n<li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href=\"https://github.com/dthree/cash\" target=\"_blank\" rel=\"noopener\">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p>\n</li>\n</ul>\n<h3 id=\"实用-Windows-命令行工具\"><a href=\"#实用-Windows-命令行工具\" class=\"headerlink\" title=\"实用 Windows 命令行工具\"></a>实用 Windows 命令行工具</h3><ul>\n<li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p>\n</li>\n<li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p>\n</li>\n<li><p>可以使用 <code>Rundll32</code> 命令来实现<a href=\"http://www.thewindowsclub.com/rundll32-shortcut-commands-windows\" target=\"_blank\" rel=\"noopener\">许多有用的 Windows 任务</a> 。</p>\n</li>\n</ul>\n<h3 id=\"Cygwin-技巧\"><a href=\"#Cygwin-技巧\" class=\"headerlink\" title=\"Cygwin 技巧\"></a>Cygwin 技巧</h3><ul>\n<li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p>\n</li>\n<li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p>\n</li>\n<li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p>\n</li>\n<li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p>\n</li>\n<li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p>\n</li>\n<li><p>注意 Windows 驱动器路径 <code>C:\\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p>\n</li>\n<li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p>\n</li>\n<li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href=\"https://github.com/dthree/cash\" target=\"_blank\" rel=\"noopener\">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p>\n</li>\n<li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"noopener\">MinGW</a> 以及它的 <a href=\"http://www.mingw.org/wiki/msys\" target=\"_blank\" rel=\"noopener\">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p>\n</li>\n</ul>\n<h2 id=\"更多资源\"><a href=\"#更多资源\" class=\"headerlink\" title=\"更多资源\"></a>更多资源</h2><ul>\n<li><a href=\"https://github.com/alebcay/awesome-shell\" target=\"_blank\" rel=\"noopener\">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>\n<li><a href=\"https://github.com/herrbischoff/awesome-osx-command-line\" target=\"_blank\" rel=\"noopener\">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li>\n<li><a href=\"http://redsymbol.net/articles/unofficial-bash-strict-mode/\" target=\"_blank\" rel=\"noopener\">Strict mode</a>：为了编写更好的脚本文件。</li>\n<li><a href=\"https://github.com/koalaman/shellcheck\" target=\"_blank\" rel=\"noopener\">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>\n<li><a href=\"http://www.dwheeler.com/essays/filenames-in-shell.html\" target=\"_blank\" rel=\"noopener\">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>\n<li><a href=\"http://datascienceatthecommandline.com/#tools\" target=\"_blank\" rel=\"noopener\">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li>\n</ul>\n<h2 id=\"免责声明\"><a href=\"#免责声明\" class=\"headerlink\" title=\"免责声明\"></a>免责声明</h2><p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p>\n<h2 id=\"授权条款\"><a href=\"#授权条款\" class=\"headerlink\" title=\"授权条款\"></a>授权条款</h2><p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.creativecommons.org/l/by-sa/4.0/88x31.png\" alt=\"Creative Commons License\"></a></p>\n<p>本文使用授权协议 <a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p>\n</blockquote>\n<ul>\n<li><a href=\"#前言\">前言</a></li>\n<li><a href=\"#基础\">基础</a></li>\n<li><a href=\"#日常使用\">日常使用</a></li>\n<li><a href=\"#文件及数据处理\">文件及数据处理</a></li>\n<li><a href=\"#系统调试\">系统调试</a></li>\n<li><a href=\"#单行脚本\">单行脚本</a></li>\n<li><a href=\"#冷门但有用\">冷门但有用</a></li>\n<li><a href=\"#仅限-os-x-系统\">仅限 OS X 系统</a></li>\n<li><a href=\"#仅限-windows-系统\">仅限 Windows 系统</a></li>\n<li><a href=\"#更多资源\">更多资源</a></li>\n<li><a href=\"#免责声明\">免责声明</a></li>\n</ul>\n<p>这篇文章是<a href=\"AUTHORS.md\">许多作者和译者</a>共同的成果。<br>这里的部分内容<br><a href=\"http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands\" target=\"_blank\" rel=\"noopener\">首次</a><br><a href=\"http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix\" target=\"_blank\" rel=\"noopener\">出现</a><br>于 <a href=\"http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know\" target=\"_blank\" rel=\"noopener\">Quora</a>，<br>但已经迁移到了 <a href=\"https://github.com/jlevy/the-art-of-command-line\" target=\"_blank\" rel=\"noopener\">Github</a>，并由众多高手做出了许多改进。<br>如果你在本文中发现了错误或者存在可以改善的地方，请[<strong>贡献你的一份力量</strong>]<a href=\"https://github.com/jlevy/the-art-of-command-line/blob/master/CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>涵盖范围：</p>\n<ul>\n<li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li>\n<li>本文主要为 Linux 所写，但在<a href=\"#仅限-os-x-系统\">仅限 OS X 系统</a>章节和<a href=\"#仅限-windows-系统\">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li>\n<li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li>\n<li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br><code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li>\n<li>遇到问题的话，请尝试使用 <a href=\"http://explainshell.com/\" target=\"_blank\" rel=\"noopener\">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li>\n</ul>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p>\n</li>\n<li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p>\n</li>\n<li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p>\n</li>\n<li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p>\n</li>\n<li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>…<code>]</code>） 和引用以及引用中 <code>&#39;</code> 和 <code>&quot;</code> 的区别（后文中有一些具体的例子）。</p>\n</li>\n<li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p>\n</li>\n<li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p>\n</li>\n<li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p>\n</li>\n<li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p>\n</li>\n<li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p>\n</li>\n<li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p>\n</li>\n<li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p>\n</li>\n</ul>\n<h2 id=\"日常使用\"><a href=\"#日常使用\" class=\"headerlink\" title=\"日常使用\"></a>日常使用</h2><ul>\n<li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p>\n</li>\n<li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-*</strong> 可以展开通配符。</p>\n</li>\n</ul>\n<ul>\n<li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p>\n</li>\n<li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p>\n</li>\n<li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p>\n</li>\n<li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>~</code>（例如 <code>~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p>\n</li>\n<li><p>回到前一个工作路径：<code>cd -</code>。</p>\n</li>\n<li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p>\n</li>\n<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I{}</code> 会很方便。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name <span class=\"string\">'*.py'</span> | xargs grep some_function</span><br><span class=\"line\">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p>\n</li>\n<li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p>\n</li>\n<li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p>\n</li>\n<li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p>\n</li>\n<li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p>\n</li>\n<li><p><code>lsof</code> 来查看开启的套接字和文件。</p>\n</li>\n<li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p>\n</li>\n<li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll=&#39;ls -latr&#39;</code> 创建了一个新的命令别名 <code>ll</code>。</p>\n</li>\n<li><p>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href=\"http://superuser.com/a/183980/7106\" target=\"_blank\" rel=\"noopener\">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p>\n</li>\n<li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p>\n</li>\n<li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p>\n</li>\n<li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>&quot;$FOO&quot;</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$&#39;\\n&#39;</code> 把内部字段分隔符设为换行符。</p>\n</li>\n<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> -euo pipefail</span><br><span class=\"line\"><span class=\"built_in\">trap</span> <span class=\"string\">\"echo 'error: Script failed: see failed command above'\"</span> ERR</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># do something in current dir</span></span><br><span class=\"line\">(<span class=\"built_in\">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class=\"line\"><span class=\"comment\"># continue in original dir</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 Bash 中，变量有许多的扩展方式。<code>${name:?error message}</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=${1:?usage: $0 input_file}</code>。在变量为空时使用默认值：<code>${name:-default}</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=${2:-logfile}</code>，如果省略了 $2，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>{1..10}</code>。截断字符串：<code>${var%suffix}</code> 和 <code>${var#prefix}</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo ${var%.pdf}.txt</code> 将输出 <code>foo.txt</code>。</p>\n</li>\n<li><p>使用括号扩展（<code>{</code>…<code>}</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.{txt,pdf} some-dir</code>（同时移动两个文件），<code>cp somefile{,.bak}</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p>\n</li>\n<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">      <span class=\"comment\"># 在这里写代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p>\n</li>\n<li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p>\n</li>\n<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p>\n</li>\n<li><p>使用 <code>screen</code> 或 <a href=\"https://tmux.github.io/\" target=\"_blank\" rel=\"noopener\"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href=\"https://github.com/bogner/dtach\" target=\"_blank\" rel=\"noopener\"><code>dtach</code></a>。</p>\n</li>\n<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p>\n</li>\n<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TCPKeepAlive=yes</span><br><span class=\"line\">ServerAliveInterval=15</span><br><span class=\"line\">ServerAliveCountMax=6</span><br><span class=\"line\">Compression=yes</span><br><span class=\"line\">ControlMaster auto</span><br><span class=\"line\">ControlPath /tmp/%r@%h:%p</span><br><span class=\"line\">ControlPersist yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p>\n</li>\n<li><p>考虑使用 <a href=\"https://mosh.mit.edu/\" target=\"_blank\" rel=\"noopener\"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p>\n</li>\n<li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">stat</span> -c <span class=\"string\">'%A %a %n'</span> /etc/timezone</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <a href=\"https://github.com/mooz/percol\" target=\"_blank\" rel=\"noopener\"><code>percol</code></a> 或者 <a href=\"https://github.com/junegunn/fzf\" target=\"_blank\" rel=\"noopener\"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p>\n</li>\n<li><p>使用 <code>fpp</code>（<a href=\"https://github.com/facebook/PathPicker\" target=\"_blank\" rel=\"noopener\">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p>\n</li>\n<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br><code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p>\n</li>\n<li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入<em>你自己的</em>密码）。</p>\n</li>\n<li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>sudo - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入<em>哪个用户的</em>密码。</p>\n</li>\n<li><p>了解命令行的 <a href=\"https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong\" target=\"_blank\" rel=\"noopener\">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p>\n</li>\n<li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; 2+3</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件及数据处理\"><a href=\"#文件及数据处理\" class=\"headerlink\" title=\"文件及数据处理\"></a>文件及数据处理</h2><ul>\n<li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname &#39;*something*&#39;</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p>\n</li>\n<li><p>使用 <a href=\"https://github.com/ggreer/the_silver_searcher\" target=\"_blank\" rel=\"noopener\"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p>\n</li>\n<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p>\n</li>\n<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href=\"http://pandoc.org/\" target=\"_blank\" rel=\"noopener\"><code>pandoc</code></a>。</p>\n</li>\n<li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p>\n</li>\n<li><p>使用 <a href=\"http://stedolan.github.io/jq/\" target=\"_blank\" rel=\"noopener\"><code>jq</code></a> 处理 JSON。</p>\n</li>\n<li><p>使用 <a href=\"https://github.com/0k/shyaml\" target=\"_blank\" rel=\"noopener\"><code>shyaml</code></a> 处理 YAML。</p>\n</li>\n<li><p>要处理 Excel 或 CSV 文件的话，<a href=\"https://github.com/onyxfish/csvkit\" target=\"_blank\" rel=\"noopener\">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p>\n</li>\n<li><p>当你要处理 Amazon S3 相关的工作的时候，<a href=\"https://github.com/s3tools/s3cmd\" target=\"_blank\" rel=\"noopener\"><code>s3cmd</code></a> 是一个很方便的工具而 <a href=\"https://github.com/bloomreach/s4cmd\" target=\"_blank\" rel=\"noopener\"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href=\"https://github.com/aws/aws-cli\" target=\"_blank\" rel=\"noopener\"><code>aws</code></a> 以及  <a href=\"https://github.com/donnemartin/saws\" target=\"_blank\" rel=\"noopener\"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p>\n</li>\n<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p>\n</li>\n<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p>\n</li>\n<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p>\n</li>\n<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p>\n</li>\n<li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href=\"https://www.gnu.org/software/datamash/\" target=\"_blank\" rel=\"noopener\"><code>datamash</code></a>。</p>\n</li>\n<li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p>\n</li>\n<li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p>\n</li>\n<li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href=\"#one-liners\">One-liners</a> 获取示例。</p>\n</li>\n<li><p>替换一个或多个文件中出现的字符串：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">perl -pi.bak -e <span class=\"string\">'s/old-string/new-string/g'</span> my-files-*.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <a href=\"https://github.com/jlevy/repren\" target=\"_blank\" rel=\"noopener\"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将文件、目录和内容全部重命名 foo -&gt; bar:</span></span><br><span class=\"line\">repren --full --preserve-case --from foo --to bar .</span><br><span class=\"line\"><span class=\"comment\"># 还原所有备份文件 whatever.bak -&gt; whatever:</span></span><br><span class=\"line\">repren --renames --from <span class=\"string\">'(.*)\\.bak'</span> --to <span class=\"string\">'\\1'</span> *.bak</span><br><span class=\"line\"><span class=\"comment\"># 用 rename 实现上述功能（若可用）:</span></span><br><span class=\"line\">rename <span class=\"string\">'s/\\.bak$//'</span> *.bak</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href=\"https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html\" target=\"_blank\" rel=\"noopener\">最快方法</a>之一：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href=\"https://github.com/dmerejkowsky/pycp\" target=\"_blank\" rel=\"noopener\"><code>pycp</code></a>，<a href=\"https://github.com/Xfennec/progress\" target=\"_blank\" rel=\"noopener\"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p>\n</li>\n<li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p>\n</li>\n<li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p>\n</li>\n<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$&#39;\\t&#39;</code> （后者可能更好，因为你可以复制粘贴它）。</p>\n</li>\n<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p>\n</li>\n<li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p>\n</li>\n<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p>\n</li>\n<li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p>\n</li>\n<li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uconv -f utf-8 -t utf-8 -x <span class=\"string\">'::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; '</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p>\n</li>\n<li><p>操作日期和时间表达式，可以用 <a href=\"http://www.fresse.org/dateutils/\" target=\"_blank\" rel=\"noopener\"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p>\n</li>\n<li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p>\n</li>\n<li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p>\n</li>\n<li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getfacl -R /some/path &gt; permissions.txt</span><br><span class=\"line\">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href=\"https://zh.wikipedia.org/wiki/稀疏文件\" target=\"_blank\" rel=\"noopener\">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</p>\n</li>\n</ul>\n<h2 id=\"系统调试\"><a href=\"#系统调试\" class=\"headerlink\" title=\"系统调试\"></a>系统调试</h2><ul>\n<li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href=\"https://github.com/jkbrzt/httpie\" target=\"_blank\" rel=\"noopener\"><code>httpie</code></a>。</p>\n</li>\n<li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p>\n</li>\n<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p>\n</li>\n<li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href=\"https://github.com/nicolargo/glances\" target=\"_blank\" rel=\"noopener\"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p>\n</li>\n<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p>\n</li>\n<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href=\"https://github.com/aragozin/jvm-tools\" target=\"_blank\" rel=\"noopener\">SJK tools</a> 更高级。</p>\n</li>\n<li><p>使用 <a href=\"http://www.bitwizard.nl/mtr/\" target=\"_blank\" rel=\"noopener\"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p>\n</li>\n<li><p>用 <a href=\"https://dev.yorhel.nl/ncdu\" target=\"_blank\" rel=\"noopener\"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p>\n</li>\n<li><p>查找正在使用带宽的套接字连接或进程，使用 <a href=\"http://www.ex-parrot.com/~pdw/iftop/\" target=\"_blank\" rel=\"noopener\"><code>iftop</code></a> 或 <a href=\"https://github.com/raboof/nethogs\" target=\"_blank\" rel=\"noopener\"><code>nethogs</code></a>。</p>\n</li>\n<li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p>\n</li>\n<li><p><a href=\"https://wireshark.org/\" target=\"_blank\" rel=\"noopener\"><code>wireshark</code></a>，<a href=\"https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html\" target=\"_blank\" rel=\"noopener\"><code>tshark</code></a> 和 <a href=\"http://ngrep.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><code>ngrep</code></a> 可用于复杂的网络调试。</p>\n</li>\n<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p>\n</li>\n<li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href=\"http://www.catonmat.net/blog/ldd-arbitrary-code-execution/\" target=\"_blank\" rel=\"noopener\">永远不要在不信任的文件上运行</a>。</p>\n</li>\n<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p>\n</li>\n<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p>\n</li>\n<li><p>当调试一些之前出现的问题的时候，<a href=\"http://sebastien.godard.pagesperso-orange.fr/\" target=\"_blank\" rel=\"noopener\"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p>\n</li>\n<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href=\"https://sourceware.org/systemtap/wiki\" target=\"_blank\" rel=\"noopener\">SystemTap</a>），<a href=\"https://en.wikipedia.org/wiki/Perf_(Linux\" target=\"_blank\" rel=\"noopener\"><code>perf</code></a>)，以及<a href=\"https://github.com/draios/sysdig\" target=\"_blank\" rel=\"noopener\"><code>sysdig</code></a>。</p>\n</li>\n<li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p>\n</li>\n<li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p>\n</li>\n<li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br><code>lsof | grep deleted | grep &quot;filename-of-my-big-file&quot;</code></p>\n</li>\n</ul>\n<h2 id=\"单行脚本\"><a href=\"#单行脚本\" class=\"headerlink\" title=\"单行脚本\"></a>单行脚本</h2><p>一些命令组合的例子：</p>\n<ul>\n<li><p>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort a b | uniq &gt; c   <span class=\"comment\"># c 是 a 并 b</span></span><br><span class=\"line\">sort a b | uniq -d &gt; c   <span class=\"comment\"># c 是 a 交 b</span></span><br><span class=\"line\">sort a b b | uniq -u &gt; c   <span class=\"comment\"># c 是 a - b</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p>\n</li>\n</ul>\n<ul>\n<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk <span class=\"string\">'&#123; x += $3 &#125; END &#123; print x &#125;'</span> myfile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -<span class=\"built_in\">type</span> f -ls</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">egrep -o <span class=\"string\">'acct_id=[0-9]+'</span> access.log | cut -d= -f2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 &#39;ls -rtlh | tail&#39;</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p>\n</li>\n<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">taocl</span></span>() &#123;</span><br><span class=\"line\">  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class=\"line\">    pandoc -f markdown -t html |</span><br><span class=\"line\">    iconv -f <span class=\"string\">'utf-8'</span> -t <span class=\"string\">'unicode'</span> |</span><br><span class=\"line\">    xmlstarlet fo --html --dropdtd |</span><br><span class=\"line\">    xmlstarlet sel -t -v <span class=\"string\">\"(html/body/ul/li[count(p)&gt;0])[<span class=\"variable\">$RANDOM</span> mod last()+1]\"</span> |</span><br><span class=\"line\">    xmlstarlet unesc | fmt -80</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"冷门但有用\"><a href=\"#冷门但有用\" class=\"headerlink\" title=\"冷门但有用\"></a>冷门但有用</h2><ul>\n<li><p><code>expr</code>：计算表达式或正则匹配</p>\n</li>\n<li><p><code>m4</code>：简单的宏处理器</p>\n</li>\n<li><p><code>yes</code>：多次打印字符串</p>\n</li>\n<li><p><code>cal</code>：漂亮的日历</p>\n</li>\n<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p>\n</li>\n<li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p>\n</li>\n<li><p><code>look</code>：查找以特定字符串开头的单词或行</p>\n</li>\n<li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p>\n</li>\n<li><p><code>fmt</code>：格式化文本段落</p>\n</li>\n<li><p><code>pr</code>：将文本格式化成页／列形式</p>\n</li>\n<li><p><code>fold</code>：包裹文本中的几行</p>\n</li>\n<li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p>\n</li>\n<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p>\n</li>\n<li><p><code>nl</code>：添加行号</p>\n</li>\n<li><p><code>seq</code>：打印数字</p>\n</li>\n<li><p><code>bc</code>：计算器</p>\n</li>\n<li><p><code>factor</code>：分解因数</p>\n</li>\n<li><p><a href=\"https://gnupg.org/\" target=\"_blank\" rel=\"noopener\"><code>gpg</code></a>：加密并签名文件</p>\n</li>\n<li><p><code>toe</code>：terminfo 入口列表</p>\n</li>\n<li><p><code>nc</code>：网络调试及数据传输</p>\n</li>\n<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p>\n</li>\n<li><p><a href=\"https://github.com/mattthias/slurm\" target=\"_blank\" rel=\"noopener\"><code>slurm</code></a>：网络流量可视化</p>\n</li>\n<li><p><code>dd</code>：文件或设备间传输数据</p>\n</li>\n<li><p><code>file</code>：确定文件类型</p>\n</li>\n<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p>\n</li>\n<li><p><code>stat</code>：文件信息</p>\n</li>\n<li><p><code>time</code>：执行命令，并计算执行时间</p>\n</li>\n<li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p>\n</li>\n<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p>\n</li>\n<li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p>\n</li>\n<li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p>\n</li>\n<li><p><a href=\"https://github.com/joh/when-changed\" target=\"_blank\" rel=\"noopener\"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p>\n</li>\n<li><p><code>tac</code>：反向输出文件</p>\n</li>\n<li><p><code>shuf</code>：文件中随机选取几行</p>\n</li>\n<li><p><code>comm</code>：一行一行的比较排序过的文件</p>\n</li>\n<li><p><code>strings</code>：从二进制文件中抽取文本</p>\n</li>\n<li><p><code>tr</code>：转换字母</p>\n</li>\n<li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p>\n</li>\n<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p>\n</li>\n<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p>\n</li>\n<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p>\n</li>\n<li><p><code>apg</code>：随机生成密码</p>\n</li>\n<li><p><code>xz</code>：高比例的文件压缩</p>\n</li>\n<li><p><code>ldd</code>：动态库信息</p>\n</li>\n<li><p><code>nm</code>：提取 obj 文件中的符号</p>\n</li>\n<li><p><code>ab</code> 或 <a href=\"https://github.com/wg/wrk\" target=\"_blank\" rel=\"noopener\"><code>wrk</code></a>：web 服务器性能分析</p>\n</li>\n<li><p><code>strace</code>：调试系统调用</p>\n</li>\n<li><p><a href=\"http://www.bitwizard.nl/mtr/\" target=\"_blank\" rel=\"noopener\"><code>mtr</code></a>：更好的网络调试跟踪工具</p>\n</li>\n<li><p><code>cssh</code>：可视化的并发 shell</p>\n</li>\n<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p>\n</li>\n<li><p><a href=\"https://wireshark.org/\" target=\"_blank\" rel=\"noopener\"><code>wireshark</code></a> 和 <a href=\"https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html\" target=\"_blank\" rel=\"noopener\"><code>tshark</code></a>：抓包和网络调试工具</p>\n</li>\n<li><p><a href=\"http://ngrep.sourceforge.net/\" target=\"_blank\" rel=\"noopener\"><code>ngrep</code></a>：网络层的 grep</p>\n</li>\n<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p>\n</li>\n<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p>\n</li>\n<li><p><code>dstat</code>：系统状态查看</p>\n</li>\n<li><p><a href=\"https://github.com/nicolargo/glances\" target=\"_blank\" rel=\"noopener\"><code>glances</code></a>：高层次的多子系统总览</p>\n</li>\n<li><p><code>iostat</code>：硬盘使用状态</p>\n</li>\n<li><p><code>mpstat</code>： CPU 使用状态</p>\n</li>\n<li><p><code>vmstat</code>： 内存使用状态</p>\n</li>\n<li><p><code>htop</code>：top 的加强版</p>\n</li>\n<li><p><code>last</code>：登入记录</p>\n</li>\n<li><p><code>w</code>：查看处于登录状态的用户</p>\n</li>\n<li><p><code>id</code>：用户/组 ID 信息</p>\n</li>\n<li><p><a href=\"http://sebastien.godard.pagesperso-orange.fr/\" target=\"_blank\" rel=\"noopener\"><code>sar</code></a>：系统历史数据</p>\n</li>\n<li><p><a href=\"http://www.ex-parrot.com/~pdw/iftop/\" target=\"_blank\" rel=\"noopener\"><code>iftop</code></a> 或 <a href=\"https://github.com/raboof/nethogs\" target=\"_blank\" rel=\"noopener\"><code>nethogs</code></a>：套接字及进程的网络利用情况</p>\n</li>\n<li><p><code>ss</code>：套接字数据</p>\n</li>\n<li><p><code>dmesg</code>：引导及系统错误信息</p>\n</li>\n<li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p>\n</li>\n<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p>\n</li>\n<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p>\n</li>\n<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p>\n</li>\n<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p>\n</li>\n<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p>\n</li>\n</ul>\n<h2 id=\"仅限-OS-X-系统\"><a href=\"#仅限-OS-X-系统\" class=\"headerlink\" title=\"仅限 OS X 系统\"></a>仅限 OS X 系统</h2><p>以下是<em>仅限于</em> OS X 系统的技巧。</p>\n<ul>\n<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p>\n</li>\n<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p>\n</li>\n<li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p>\n</li>\n<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p>\n</li>\n<li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p>\n</li>\n<li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p>\n</li>\n<li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p>\n</li>\n</ul>\n<h2 id=\"仅限-Windows-系统\"><a href=\"#仅限-Windows-系统\" class=\"headerlink\" title=\"仅限 Windows 系统\"></a>仅限 Windows 系统</h2><p>以下是<em>仅限于</em> Windows 系统的技巧。</p>\n<h3 id=\"在-Winodws-下获取-Unix-工具\"><a href=\"#在-Winodws-下获取-Unix-工具\" class=\"headerlink\" title=\"在 Winodws 下获取 Unix 工具\"></a>在 Winodws 下获取 Unix 工具</h3><ul>\n<li><p>可以安装 <a href=\"https://cygwin.com/\" target=\"_blank\" rel=\"noopener\">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p>\n</li>\n<li><p>在 Windows 10 上，你可以使用 <a href=\"https://msdn.microsoft.com/commandline/wsl/about\" target=\"_blank\" rel=\"noopener\">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p>\n</li>\n<li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"noopener\">MinGW</a> 以及它的 <a href=\"http://www.mingw.org/wiki/msys\" target=\"_blank\" rel=\"noopener\">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p>\n</li>\n<li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href=\"https://github.com/dthree/cash\" target=\"_blank\" rel=\"noopener\">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p>\n</li>\n</ul>\n<h3 id=\"实用-Windows-命令行工具\"><a href=\"#实用-Windows-命令行工具\" class=\"headerlink\" title=\"实用 Windows 命令行工具\"></a>实用 Windows 命令行工具</h3><ul>\n<li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p>\n</li>\n<li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p>\n</li>\n<li><p>可以使用 <code>Rundll32</code> 命令来实现<a href=\"http://www.thewindowsclub.com/rundll32-shortcut-commands-windows\" target=\"_blank\" rel=\"noopener\">许多有用的 Windows 任务</a> 。</p>\n</li>\n</ul>\n<h3 id=\"Cygwin-技巧\"><a href=\"#Cygwin-技巧\" class=\"headerlink\" title=\"Cygwin 技巧\"></a>Cygwin 技巧</h3><ul>\n<li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p>\n</li>\n<li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p>\n</li>\n<li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p>\n</li>\n<li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p>\n</li>\n<li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p>\n</li>\n<li><p>注意 Windows 驱动器路径 <code>C:\\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p>\n</li>\n<li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p>\n</li>\n<li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href=\"https://github.com/dthree/cash\" target=\"_blank\" rel=\"noopener\">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p>\n</li>\n<li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"noopener\">MinGW</a> 以及它的 <a href=\"http://www.mingw.org/wiki/msys\" target=\"_blank\" rel=\"noopener\">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p>\n</li>\n</ul>\n<h2 id=\"更多资源\"><a href=\"#更多资源\" class=\"headerlink\" title=\"更多资源\"></a>更多资源</h2><ul>\n<li><a href=\"https://github.com/alebcay/awesome-shell\" target=\"_blank\" rel=\"noopener\">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>\n<li><a href=\"https://github.com/herrbischoff/awesome-osx-command-line\" target=\"_blank\" rel=\"noopener\">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li>\n<li><a href=\"http://redsymbol.net/articles/unofficial-bash-strict-mode/\" target=\"_blank\" rel=\"noopener\">Strict mode</a>：为了编写更好的脚本文件。</li>\n<li><a href=\"https://github.com/koalaman/shellcheck\" target=\"_blank\" rel=\"noopener\">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>\n<li><a href=\"http://www.dwheeler.com/essays/filenames-in-shell.html\" target=\"_blank\" rel=\"noopener\">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>\n<li><a href=\"http://datascienceatthecommandline.com/#tools\" target=\"_blank\" rel=\"noopener\">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li>\n</ul>\n<h2 id=\"免责声明\"><a href=\"#免责声明\" class=\"headerlink\" title=\"免责声明\"></a>免责声明</h2><p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p>\n<h2 id=\"授权条款\"><a href=\"#授权条款\" class=\"headerlink\" title=\"授权条款\"></a>授权条款</h2><p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.creativecommons.org/l/by-sa/4.0/88x31.png\" alt=\"Creative Commons License\"></a></p>\n<p>本文使用授权协议 <a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>\n"},{"title":"【剑指Offer】栈实现队列","_content":"\n## 题目描述\n\n用两个栈来实现一个队列，完成队列的`Push`和`Pop`操作。 队列中的元素为`int`类型。\n\n\n\n## 算法分析\n\n队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：\n\n`push`操作用一个栈进行存储，`pop`操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，\n\n第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution\n{\npublic:\n    void push(int node) {\n        stack1.push(node);\n    }\n\n    int pop() {\n        int res;\n        while (!stack1.empty()) {\n            stack2.push(stack1.top());\n            stack1.pop();\n        }\n        \n        res = stack2.top();\n        stack2.pop();\n        \n        while (!stack2.empty()) {\n            stack1.push(stack2.top());\n            stack2.pop();\n        }\n        \n        return res;\n    }\n\nprivate:\n    stack<int> stack1;\n    stack<int> stack2;\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/implement-queue-with-stack.md","raw":"---\ntitle: 【剑指offer】栈实现队列\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - queue\n  - stack\n---\n\n## 题目描述\n\n用两个栈来实现一个队列，完成队列的`Push`和`Pop`操作。 队列中的元素为`int`类型。\n\n\n\n## 算法分析\n\n队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：\n\n`push`操作用一个栈进行存储，`pop`操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，\n\n第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution\n{\npublic:\n    void push(int node) {\n        stack1.push(node);\n    }\n\n    int pop() {\n        int res;\n        while (!stack1.empty()) {\n            stack2.push(stack1.top());\n            stack1.pop();\n        }\n        \n        res = stack2.top();\n        stack2.pop();\n        \n        while (!stack2.empty()) {\n            stack1.push(stack2.top());\n            stack2.pop();\n        }\n        \n        return res;\n    }\n\nprivate:\n    stack<int> stack1;\n    stack<int> stack2;\n};\n~~~\n\n","slug":"Algorithm/ForOffer/implement-queue-with-stack","published":1,"date":"2019-11-11T07:59:20.429Z","updated":"2019-11-11T07:59:20.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdc001jlon9sf6q37t8","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：</p>\n<p><code>push</code>操作用一个栈进行存储，<code>pop</code>操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，</p>\n<p>第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.top());</span><br><span class=\"line\">            stack1.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        res = stack2.top();</span><br><span class=\"line\">        stack2.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.top());</span><br><span class=\"line\">            stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack1;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：</p>\n<p><code>push</code>操作用一个栈进行存储，<code>pop</code>操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，</p>\n<p>第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.top());</span><br><span class=\"line\">            stack1.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        res = stack2.top();</span><br><span class=\"line\">        stack2.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.top());</span><br><span class=\"line\">            stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack1;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指Offer】旋转数组的最小数字","_content":"\n## 题目描述\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n\n\n## 算法分析\n\n我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        if(rotateArray.size() == 0){\n            return 0;\n        } else{\n            int first = rotateArray[0];\n            int i = 1;\n            while(rotateArray[i] != '\\0'){\n                if(rotateArray[i] < first){\n                    break;\n                    //return rotateArray[i];\n                }\n                i++;\n            }\n            return rotateArray[i];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        int n = rotateArray.size();\n        if (n == 0) return 0;\n        else {\n            int min = rotateArray[0];\n            for (auto i : rotateArray) {\n                if (i < min) min = i;\n            }\n            \n            return min;\n        }\n    }\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/min-number-in-rotate-array.md","raw":"---\ntitle: 【剑指offer】旋转数组的最小数字\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - search\n---\n\n## 题目描述\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n\n\n## 算法分析\n\n我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        if(rotateArray.size() == 0){\n            return 0;\n        } else{\n            int first = rotateArray[0];\n            int i = 1;\n            while(rotateArray[i] != '\\0'){\n                if(rotateArray[i] < first){\n                    break;\n                    //return rotateArray[i];\n                }\n                i++;\n            }\n            return rotateArray[i];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        int n = rotateArray.size();\n        if (n == 0) return 0;\n        else {\n            int min = rotateArray[0];\n            for (auto i : rotateArray) {\n                if (i < min) min = i;\n            }\n            \n            return min;\n        }\n    }\n};\n~~~\n\n","slug":"Algorithm/ForOffer/min-number-in-rotate-array","published":1,"date":"2019-11-11T07:59:20.429Z","updated":"2019-11-11T07:59:20.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdd001mlon9icd3kt12","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotateArray.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(rotateArray[i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rotateArray[i] &lt; first)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//return rotateArray[i];</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rotateArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = rotateArray.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : rotateArray) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; min) min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotateArray.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(rotateArray[i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rotateArray[i] &lt; first)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//return rotateArray[i];</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rotateArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = rotateArray.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : rotateArray) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; min) min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指Offer】从尾到头打印链表","_content":"\n## 题目描述\n\n输入一个链表，按链表值从尾到头的顺序返回一个`ArrayList`。\n\n\n\n## 算法分析\n\n1. 使用递归的方法：\n\n   我们可以使用递归函数，`head`和`head->next`存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。\n\n2. 使用栈的方法：\n\n   首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n*  struct ListNode {\n*        int val;\n*        struct ListNode *next;\n*        ListNode(int x) :\n*              val(x), next(NULL) {\n*        }\n*  };\n*/\n\n// 递归\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n\t\tvector<int> result;\n        helper(head, result);\n        return result;\n    }\n    \nprivate:\n    void helper(ListNode* head, vector<int> &result){\n        if(head){\n            if(head -> next){\n                helper(head -> next, result);\n            }\n            result.push_back(head -> val);\n        }\n    }\n};\n\n\n// 栈\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        vector<int> res;\n        stack<int> st;\n        \n        while (head) {\n            st.push(head->val);\n            head = head->next;\n        }\n        \n        while (!st.empty()) {\n            res.push_back(st.top());\n            st.pop();\n        }\n        \n        return res;\n    }\n};\n~~~\n\n\n\n\n\n","source":"_posts/Algorithm/ForOffer/print-list-from-tail-to-head.md","raw":"---\ntitle: 【剑指offer】从尾到头打印链表\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - linked-list\n---\n\n## 题目描述\n\n输入一个链表，按链表值从尾到头的顺序返回一个`ArrayList`。\n\n\n\n## 算法分析\n\n1. 使用递归的方法：\n\n   我们可以使用递归函数，`head`和`head->next`存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。\n\n2. 使用栈的方法：\n\n   首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n*  struct ListNode {\n*        int val;\n*        struct ListNode *next;\n*        ListNode(int x) :\n*              val(x), next(NULL) {\n*        }\n*  };\n*/\n\n// 递归\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n\t\tvector<int> result;\n        helper(head, result);\n        return result;\n    }\n    \nprivate:\n    void helper(ListNode* head, vector<int> &result){\n        if(head){\n            if(head -> next){\n                helper(head -> next, result);\n            }\n            result.push_back(head -> val);\n        }\n    }\n};\n\n\n// 栈\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        vector<int> res;\n        stack<int> st;\n        \n        while (head) {\n            st.push(head->val);\n            head = head->next;\n        }\n        \n        while (!st.empty()) {\n            res.push_back(st.top());\n            st.pop();\n        }\n        \n        return res;\n    }\n};\n~~~\n\n\n\n\n\n","slug":"Algorithm/ForOffer/print-list-from-tail-to-head","published":1,"date":"2019-11-11T07:59:20.429Z","updated":"2019-11-11T07:59:20.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrde001nlon94vxp5vkg","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><ol>\n<li><p>使用递归的方法：</p>\n<p>我们可以使用递归函数，<code>head</code>和<code>head-&gt;next</code>存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。</p>\n</li>\n<li><p>使用栈的方法：</p>\n<p>首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        int val;</span></span><br><span class=\"line\"><span class=\"comment\">*        struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*        ListNode(int x) :</span></span><br><span class=\"line\"><span class=\"comment\">*              val(x), next(NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*  &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        helper(head, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head -&gt; next)&#123;</span><br><span class=\"line\">                helper(head -&gt; next, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(head -&gt; val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            st.push(head-&gt;val);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.empty()) &#123;</span><br><span class=\"line\">            res.push_back(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><ol>\n<li><p>使用递归的方法：</p>\n<p>我们可以使用递归函数，<code>head</code>和<code>head-&gt;next</code>存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。</p>\n</li>\n<li><p>使用栈的方法：</p>\n<p>首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        int val;</span></span><br><span class=\"line\"><span class=\"comment\">*        struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*        ListNode(int x) :</span></span><br><span class=\"line\"><span class=\"comment\">*              val(x), next(NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*  &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        helper(head, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head -&gt; next)&#123;</span><br><span class=\"line\">                helper(head -&gt; next, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(head -&gt; val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            st.push(head-&gt;val);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.empty()) &#123;</span><br><span class=\"line\">            res.push_back(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指Offer】重建二叉树","_content":"\n## 问题描述\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n\n\n## 算法分析\n\n算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {\n\t\tif (pre.size() == 0) return NULL;\n        else if (pre.size() == 1){\n            TreeNode* root = new TreeNode(pre.back());\n            root -> left = NULL;\n            root -> right = NULL;\n            return root;\n        }\n        else {\n            TreeNode* root = new TreeNode(pre.at(0));\n            vector<int>::iterator it = vin.begin();\n            while(it != vin.end() && *it != pre.at(0)) ++it;\n            int dis = it - vin.begin();\n            vector<int> subPreLeft(pre.begin() + 1, pre.begin() + dis + 1);\n            vector<int> subPreRight(pre.begin() + dis + 1, pre.end());\n            vector<int> subVinLeft(vin.begin(), it);\n            vector<int> subVinRight(it + 1, vin.end() );\n            root -> left = reConstructBinaryTree(subPreLeft, subVinLeft);\n            root -> right = reConstructBinaryTree(subPreRight, subVinRight);\n            return root;\n        }\n    }\n    \n};\n~~~\n\n\n\n","source":"_posts/Algorithm/ForOffer/reconstruct-binary-tree.md","raw":"---\ntitle: 【剑指offer】重建二叉树\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - binary-tree\n---\n\n## 问题描述\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n\n\n## 算法分析\n\n算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {\n\t\tif (pre.size() == 0) return NULL;\n        else if (pre.size() == 1){\n            TreeNode* root = new TreeNode(pre.back());\n            root -> left = NULL;\n            root -> right = NULL;\n            return root;\n        }\n        else {\n            TreeNode* root = new TreeNode(pre.at(0));\n            vector<int>::iterator it = vin.begin();\n            while(it != vin.end() && *it != pre.at(0)) ++it;\n            int dis = it - vin.begin();\n            vector<int> subPreLeft(pre.begin() + 1, pre.begin() + dis + 1);\n            vector<int> subPreRight(pre.begin() + dis + 1, pre.end());\n            vector<int> subVinLeft(vin.begin(), it);\n            vector<int> subVinRight(it + 1, vin.end() );\n            root -> left = reConstructBinaryTree(subPreLeft, subVinLeft);\n            root -> right = reConstructBinaryTree(subPreRight, subVinRight);\n            return root;\n        }\n    }\n    \n};\n~~~\n\n\n\n","slug":"Algorithm/ForOffer/reconstruct-binary-tree","published":1,"date":"2019-11-11T07:59:20.430Z","updated":"2019-11-11T07:59:20.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdf001qlon94sitv4ih","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pre,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vin)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.back());</span><br><span class=\"line\">            root -&gt; left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root -&gt; right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.at(<span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = vin.begin();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(it != vin.end() &amp;&amp; *it != pre.at(<span class=\"number\">0</span>)) ++it;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = it - vin.begin();</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreLeft(pre.begin() + <span class=\"number\">1</span>, pre.begin() + dis + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreRight(pre.begin() + dis + <span class=\"number\">1</span>, pre.end());</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinLeft(vin.begin(), it);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinRight(it + <span class=\"number\">1</span>, vin.end() );</span><br><span class=\"line\">            root -&gt; left = reConstructBinaryTree(subPreLeft, subVinLeft);</span><br><span class=\"line\">            root -&gt; right = reConstructBinaryTree(subPreRight, subVinRight);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pre,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vin)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.back());</span><br><span class=\"line\">            root -&gt; left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root -&gt; right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.at(<span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = vin.begin();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(it != vin.end() &amp;&amp; *it != pre.at(<span class=\"number\">0</span>)) ++it;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = it - vin.begin();</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreLeft(pre.begin() + <span class=\"number\">1</span>, pre.begin() + dis + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreRight(pre.begin() + dis + <span class=\"number\">1</span>, pre.end());</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinLeft(vin.begin(), it);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinRight(it + <span class=\"number\">1</span>, vin.end() );</span><br><span class=\"line\">            root -&gt; left = reConstructBinaryTree(subPreLeft, subVinLeft);</span><br><span class=\"line\">            root -&gt; right = reConstructBinaryTree(subPreRight, subVinRight);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指Offer】替换空格","_content":"\n## 题目描述\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n\n\n## 算法分析\n\n首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n\tvoid replaceSpace(char *str,int length) {\n\t\tchar *t = str;\n        int strLen = 0, newStrLen = 0, spaceCount = 0;\n        int p,q;\n        \n        if(str == NULL || length <0) return; // 首先判定进入算法的有效条件\n        \n        while(*t != '\\0'){\n            strLen++;\n            if(*t == ' ') spaceCount++;\n            t++;\n        }\t// 取字符串长度， 空格的个数\n        \n        newStrLen = strLen + 2 * spaceCount;  // 新的字符串的长度\n        if(newStrLen > length) return ;\n        \n        for(p = strLen, q = newStrLen; p >= 0; p-- ){\n            if(str[p] == ' '){\n                str[q--] = '0';\n                str[q--] = '2';\n                str[q--] = '%';\n            } else {\n                str[q--] = str[p];\n            }\n        }\n\t}\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/replace-sapce.md","raw":"---\ntitle: 【剑指Offer】替换空格\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - string\n---\n\n## 题目描述\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n\n\n## 算法分析\n\n首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n\tvoid replaceSpace(char *str,int length) {\n\t\tchar *t = str;\n        int strLen = 0, newStrLen = 0, spaceCount = 0;\n        int p,q;\n        \n        if(str == NULL || length <0) return; // 首先判定进入算法的有效条件\n        \n        while(*t != '\\0'){\n            strLen++;\n            if(*t == ' ') spaceCount++;\n            t++;\n        }\t// 取字符串长度， 空格的个数\n        \n        newStrLen = strLen + 2 * spaceCount;  // 新的字符串的长度\n        if(newStrLen > length) return ;\n        \n        for(p = strLen, q = newStrLen; p >= 0; p-- ){\n            if(str[p] == ' '){\n                str[q--] = '0';\n                str[q--] = '2';\n                str[q--] = '%';\n            } else {\n                str[q--] = str[p];\n            }\n        }\n\t}\n};\n~~~\n\n","slug":"Algorithm/ForOffer/replace-sapce","published":1,"date":"2019-11-11T07:59:20.430Z","updated":"2019-11-11T07:59:20.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdg001slon9x5502i98","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *t = str;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> strLen = <span class=\"number\">0</span>, newStrLen = <span class=\"number\">0</span>, spaceCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,q;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span> || length &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 首先判定进入算法的有效条件</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*t != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            strLen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(*t == <span class=\"string\">' '</span>) spaceCount++;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;\t<span class=\"comment\">// 取字符串长度， 空格的个数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newStrLen = strLen + <span class=\"number\">2</span> * spaceCount;  <span class=\"comment\">// 新的字符串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(newStrLen &gt; length) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = strLen, q = newStrLen; p &gt;= <span class=\"number\">0</span>; p-- )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[p] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'2'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'%'</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                str[q--] = str[p];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *t = str;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> strLen = <span class=\"number\">0</span>, newStrLen = <span class=\"number\">0</span>, spaceCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,q;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span> || length &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 首先判定进入算法的有效条件</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*t != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            strLen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(*t == <span class=\"string\">' '</span>) spaceCount++;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;\t<span class=\"comment\">// 取字符串长度， 空格的个数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newStrLen = strLen + <span class=\"number\">2</span> * spaceCount;  <span class=\"comment\">// 新的字符串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(newStrLen &gt; length) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = strLen, q = newStrLen; p &gt;= <span class=\"number\">0</span>; p-- )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[p] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'2'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'%'</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                str[q--] = str[p];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"《深入理解JVM》函数调用","date":"2019-11-27T11:48:56.000Z","update":"2019-11-27T11:49:07.000Z","toc":true,"_content":"\n\n## C语言函数调用实现\n\n通过一个简单的C语言程序分析\n~~~c\n#include <stdio.h>\n\nint add();\n\nint main(int argc, char const *argv[])\n{\n    int c = add();\n    printf(\"%d\", c);\n    return 0;\n}\n\nint add() {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序：\n\n~~~asm\n\t.file\t\".\\\\sampleAdd.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"%d\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB13:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE13:\n\t.size\tmain, .-main\n\t.globl\tadd\n\t.type\tadd, @function\nadd:\n.LFB14:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE14:\n\t.size\tadd, .-add\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n~~~\n\n去除宏定义，保留主要指令如下：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n汇编程序有两个标号`main`, `add`。这不是巧合，而是编译器处理的结果，**编译器会把函数名处理成汇编程序中的标号**。 有了标号，汇编程序就能执行函数调用，即call指令，有一条`call and`指令，就是汇编中执行函数调用的指令。\n\n接下来逐段分析：\n\n~~~asm\n\t# 保存调用者栈基地址，并为main()函数分配新栈空间\n\tpushq\t%rbp\t\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\t# 分配新栈，一共32字节\n~~~\n\n在`mian`，`add`代码段的开始都包含这3条指令，add代码段第3行是`movl\t$3, -4(%rbp)`该指令与`mian`代码段的`subq\t$32, %rsp`作用是相同的——分配栈空间。\n\n这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。\n\n`main()` 函数的方法栈内存布局如下图所示：\n\n// 这里需要插入一张图片\n\n\n\n### 带入参的C程序\n\n~~~c\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(int argc, char const *argv[])\n{\n    int a = 5, b = 3;\n    int c = add(a, b);\n    return 0;\n}\n\nint add(int a, int b) {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序(**去除宏定义，保留主要指令**)：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$5, -12(%rbp)\n\tmovl\t$3, -8(%rbp)\n\tmovl\t-8(%rbp), %edx\n\tmovl\t-12(%rbp), %eax\n\tmovl\t%edx, %esi\n\tmovl\t%eax, %edi\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t%edi, -20(%rbp)\n\tmovl\t%esi, -24(%rbp)\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n## C语言函数的调用机制\n\n1. 压栈\nmain函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。\n2. 参数传递顺序\nLinux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈\n3. 读取入参\n读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)......\n\n\n## 真实物理机器上执行函数调用的步骤：\n\n1. 保存调用者栈基地址，当前IP寄存器入栈\n2. 调用函数时，在x86平台参数从右到左依次入栈\n3. 一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小\n4. 被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数\n5. 被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值\n\n\n\n## 补充（关于寄存器）\n\n- %rax 作为函数返回值使用。\n- %rsp 栈指针寄存器，指向栈顶\n- %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。\n- %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改\n- %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n\n\n## Reference\n\n- [X86-64寄存器和栈帧](http://ju.outofmemory.cn/entry/769)\n\n- 揭秘Java虚拟机 \n","source":"_posts/Java/JVM/implement-function-call-in-c.md","raw":"---\ntitle: 《深入理解JVM》函数调用\ndate: 2019-11-27 19:48:56\nupdate: 2019-11-27 19:49:07\ntoc: true\ncategories:\n  - Java\n  - JVM\ntags:\n  - jvm\n---\n\n\n## C语言函数调用实现\n\n通过一个简单的C语言程序分析\n~~~c\n#include <stdio.h>\n\nint add();\n\nint main(int argc, char const *argv[])\n{\n    int c = add();\n    printf(\"%d\", c);\n    return 0;\n}\n\nint add() {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序：\n\n~~~asm\n\t.file\t\".\\\\sampleAdd.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"%d\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB13:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE13:\n\t.size\tmain, .-main\n\t.globl\tadd\n\t.type\tadd, @function\nadd:\n.LFB14:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE14:\n\t.size\tadd, .-add\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n~~~\n\n去除宏定义，保留主要指令如下：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n汇编程序有两个标号`main`, `add`。这不是巧合，而是编译器处理的结果，**编译器会把函数名处理成汇编程序中的标号**。 有了标号，汇编程序就能执行函数调用，即call指令，有一条`call and`指令，就是汇编中执行函数调用的指令。\n\n接下来逐段分析：\n\n~~~asm\n\t# 保存调用者栈基地址，并为main()函数分配新栈空间\n\tpushq\t%rbp\t\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\t# 分配新栈，一共32字节\n~~~\n\n在`mian`，`add`代码段的开始都包含这3条指令，add代码段第3行是`movl\t$3, -4(%rbp)`该指令与`mian`代码段的`subq\t$32, %rsp`作用是相同的——分配栈空间。\n\n这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。\n\n`main()` 函数的方法栈内存布局如下图所示：\n\n// 这里需要插入一张图片\n\n\n\n### 带入参的C程序\n\n~~~c\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(int argc, char const *argv[])\n{\n    int a = 5, b = 3;\n    int c = add(a, b);\n    return 0;\n}\n\nint add(int a, int b) {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序(**去除宏定义，保留主要指令**)：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$5, -12(%rbp)\n\tmovl\t$3, -8(%rbp)\n\tmovl\t-8(%rbp), %edx\n\tmovl\t-12(%rbp), %eax\n\tmovl\t%edx, %esi\n\tmovl\t%eax, %edi\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t%edi, -20(%rbp)\n\tmovl\t%esi, -24(%rbp)\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n## C语言函数的调用机制\n\n1. 压栈\nmain函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。\n2. 参数传递顺序\nLinux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈\n3. 读取入参\n读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)......\n\n\n## 真实物理机器上执行函数调用的步骤：\n\n1. 保存调用者栈基地址，当前IP寄存器入栈\n2. 调用函数时，在x86平台参数从右到左依次入栈\n3. 一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小\n4. 被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数\n5. 被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值\n\n\n\n## 补充（关于寄存器）\n\n- %rax 作为函数返回值使用。\n- %rsp 栈指针寄存器，指向栈顶\n- %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。\n- %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改\n- %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n\n\n## Reference\n\n- [X86-64寄存器和栈帧](http://ju.outofmemory.cn/entry/769)\n\n- 揭秘Java虚拟机 \n","slug":"Java/JVM/implement-function-call-in-c","published":1,"updated":"2019-11-27T12:14:18.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdh001wlon9nqbz605i","content":"<h2 id=\"C语言函数调用实现\"><a href=\"#C语言函数调用实现\" class=\"headerlink\" title=\"C语言函数调用实现\"></a>C语言函数调用实现</h2><p>通过一个简单的C语言程序分析<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将这段C程序编译成汇编程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.file\t&quot;.\\\\sampleAdd.c&quot;</span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string\t&quot;%d&quot;</span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB13:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE13:</span><br><span class=\"line\">\t.size\tmain, .-main</span><br><span class=\"line\">\t.globl\tadd</span><br><span class=\"line\">\t.type\tadd, @function</span><br><span class=\"line\">add:</span><br><span class=\"line\">.LFB14:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE14:</span><br><span class=\"line\">\t.size\tadd, .-add</span><br><span class=\"line\">\t.ident\t&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609&quot;</span><br><span class=\"line\">\t.section\t.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>去除宏定义，保留主要指令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>汇编程序有两个标号<code>main</code>, <code>add</code>。这不是巧合，而是编译器处理的结果，<strong>编译器会把函数名处理成汇编程序中的标号</strong>。 有了标号，汇编程序就能执行函数调用，即call指令，有一条<code>call and</code>指令，就是汇编中执行函数调用的指令。</p>\n<p>接下来逐段分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 保存调用者栈基地址，并为main()函数分配新栈空间</span><br><span class=\"line\">pushq\t%rbp\t</span><br><span class=\"line\">movq\t%rsp, %rbp</span><br><span class=\"line\">subq\t$32, %rsp\t# 分配新栈，一共32字节</span><br></pre></td></tr></table></figure>\n<p>在<code>mian</code>，<code>add</code>代码段的开始都包含这3条指令，add代码段第3行是<code>movl    $3, -4(%rbp)</code>该指令与<code>mian</code>代码段的<code>subq    $32, %rsp</code>作用是相同的——分配栈空间。</p>\n<p>这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。</p>\n<p><code>main()</code> 函数的方法栈内存布局如下图所示：</p>\n<p>// 这里需要插入一张图片</p>\n<h3 id=\"带入参的C程序\"><a href=\"#带入参的C程序\" class=\"headerlink\" title=\"带入参的C程序\"></a>带入参的C程序</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序(<strong>去除宏定义，保留主要指令</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$5, -12(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -8(%rbp)</span><br><span class=\"line\">\tmovl\t-8(%rbp), %edx</span><br><span class=\"line\">\tmovl\t-12(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%edx, %esi</span><br><span class=\"line\">\tmovl\t%eax, %edi</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovl\t%esi, -24(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<h2 id=\"C语言函数的调用机制\"><a href=\"#C语言函数的调用机制\" class=\"headerlink\" title=\"C语言函数的调用机制\"></a>C语言函数的调用机制</h2><ol>\n<li>压栈<br>main函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。</li>\n<li>参数传递顺序<br>Linux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈</li>\n<li>读取入参<br>读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)……</li>\n</ol>\n<h2 id=\"真实物理机器上执行函数调用的步骤：\"><a href=\"#真实物理机器上执行函数调用的步骤：\" class=\"headerlink\" title=\"真实物理机器上执行函数调用的步骤：\"></a>真实物理机器上执行函数调用的步骤：</h2><ol>\n<li>保存调用者栈基地址，当前IP寄存器入栈</li>\n<li>调用函数时，在x86平台参数从右到左依次入栈</li>\n<li>一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小</li>\n<li>被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数</li>\n<li>被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值</li>\n</ol>\n<h2 id=\"补充（关于寄存器）\"><a href=\"#补充（关于寄存器）\" class=\"headerlink\" title=\"补充（关于寄存器）\"></a>补充（关于寄存器）</h2><ul>\n<li>%rax 作为函数返回值使用。</li>\n<li>%rsp 栈指针寄存器，指向栈顶</li>\n<li>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</li>\n<li>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>\n<li>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><p><a href=\"http://ju.outofmemory.cn/entry/769\" target=\"_blank\" rel=\"noopener\">X86-64寄存器和栈帧</a></p>\n</li>\n<li><p>揭秘Java虚拟机 </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C语言函数调用实现\"><a href=\"#C语言函数调用实现\" class=\"headerlink\" title=\"C语言函数调用实现\"></a>C语言函数调用实现</h2><p>通过一个简单的C语言程序分析<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将这段C程序编译成汇编程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.file\t&quot;.\\\\sampleAdd.c&quot;</span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string\t&quot;%d&quot;</span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB13:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE13:</span><br><span class=\"line\">\t.size\tmain, .-main</span><br><span class=\"line\">\t.globl\tadd</span><br><span class=\"line\">\t.type\tadd, @function</span><br><span class=\"line\">add:</span><br><span class=\"line\">.LFB14:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE14:</span><br><span class=\"line\">\t.size\tadd, .-add</span><br><span class=\"line\">\t.ident\t&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609&quot;</span><br><span class=\"line\">\t.section\t.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>去除宏定义，保留主要指令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>汇编程序有两个标号<code>main</code>, <code>add</code>。这不是巧合，而是编译器处理的结果，<strong>编译器会把函数名处理成汇编程序中的标号</strong>。 有了标号，汇编程序就能执行函数调用，即call指令，有一条<code>call and</code>指令，就是汇编中执行函数调用的指令。</p>\n<p>接下来逐段分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 保存调用者栈基地址，并为main()函数分配新栈空间</span><br><span class=\"line\">pushq\t%rbp\t</span><br><span class=\"line\">movq\t%rsp, %rbp</span><br><span class=\"line\">subq\t$32, %rsp\t# 分配新栈，一共32字节</span><br></pre></td></tr></table></figure>\n<p>在<code>mian</code>，<code>add</code>代码段的开始都包含这3条指令，add代码段第3行是<code>movl    $3, -4(%rbp)</code>该指令与<code>mian</code>代码段的<code>subq    $32, %rsp</code>作用是相同的——分配栈空间。</p>\n<p>这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。</p>\n<p><code>main()</code> 函数的方法栈内存布局如下图所示：</p>\n<p>// 这里需要插入一张图片</p>\n<h3 id=\"带入参的C程序\"><a href=\"#带入参的C程序\" class=\"headerlink\" title=\"带入参的C程序\"></a>带入参的C程序</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序(<strong>去除宏定义，保留主要指令</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$5, -12(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -8(%rbp)</span><br><span class=\"line\">\tmovl\t-8(%rbp), %edx</span><br><span class=\"line\">\tmovl\t-12(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%edx, %esi</span><br><span class=\"line\">\tmovl\t%eax, %edi</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovl\t%esi, -24(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<h2 id=\"C语言函数的调用机制\"><a href=\"#C语言函数的调用机制\" class=\"headerlink\" title=\"C语言函数的调用机制\"></a>C语言函数的调用机制</h2><ol>\n<li>压栈<br>main函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。</li>\n<li>参数传递顺序<br>Linux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈</li>\n<li>读取入参<br>读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)……</li>\n</ol>\n<h2 id=\"真实物理机器上执行函数调用的步骤：\"><a href=\"#真实物理机器上执行函数调用的步骤：\" class=\"headerlink\" title=\"真实物理机器上执行函数调用的步骤：\"></a>真实物理机器上执行函数调用的步骤：</h2><ol>\n<li>保存调用者栈基地址，当前IP寄存器入栈</li>\n<li>调用函数时，在x86平台参数从右到左依次入栈</li>\n<li>一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小</li>\n<li>被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数</li>\n<li>被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值</li>\n</ol>\n<h2 id=\"补充（关于寄存器）\"><a href=\"#补充（关于寄存器）\" class=\"headerlink\" title=\"补充（关于寄存器）\"></a>补充（关于寄存器）</h2><ul>\n<li>%rax 作为函数返回值使用。</li>\n<li>%rsp 栈指针寄存器，指向栈顶</li>\n<li>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</li>\n<li>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>\n<li>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><p><a href=\"http://ju.outofmemory.cn/entry/769\" target=\"_blank\" rel=\"noopener\">X86-64寄存器和栈帧</a></p>\n</li>\n<li><p>揭秘Java虚拟机 </p>\n</li>\n</ul>\n"},{"title":"平衡二叉树（AVLTree）封装+模板实现","date":"2019-11-27T03:36:49.000Z","_content":"\n## 简介\n\n[平衡树（AVLTree）](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n\n> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**AVL树**是最先发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)都是![O(\\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。增加和删除可能需要通过一次或多次[树旋转](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC)来重新平衡这个树。AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA)和[E. M. Landis](https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1)，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n>\n> 节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”**二叉搜索树**，平衡条件确保整棵树的深度为O(log n)。\n\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。**查找、插入和删除在平均和最坏情况下都是 O(log n)**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。\n\nAVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。\n\n\n\n## AVL旋转\n\nAVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。\n\n在理解AVL旋转之前，首先得知道以下几个概念： \n\n1. AVL 树节点的插入总是在叶子节点。 \n2. AVL 树在插入节点之前总是满足平衡条件的。 \n1. 插入新节点后有可能满足平衡条件也有可能不满足。 \n4. 当不满足平衡条件后，我们就需要对新的树进行旋转。\n\n\n旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：\n\n> 假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。\n\n基于这个X节点，考虑一件事情： \n这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：\n\n> X的左孩子节点的左子树上**(left-left)** \n> X的右孩子节点的右子树上**(right-right)** \n> X的左孩子节点的右子树上**(left-right)** \n> X的右孩子节点的左子树上**(right-left)**\n\n根据上述情况就延生出了4种旋转： \n**1.left-left Rotation** \n**2.right-right Rotation** \n**3.left-right Rotation** \n**4.right-left Rotation**\n\n前两种属于单旋转，后两种属于双旋转，**双旋转的操作可以由两次单旋转组成。**\n\nPS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。\n\n[![avl旋转四种情况](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)\n\n图片来自 [C小加的博客](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n1. 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。\n2. 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。\n3. 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。\n4. 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。\n\n从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。\n\n那么为什么需要双旋转呢？\n\n这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。\n\n而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。\n\n// 这里的描述太那啥了，得搞点图说明下\n\n\n\n## AVL-Tree实现\n\nAVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。\n\n节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： \n\n1. 每次都计算一次（递归求深度）。 \n2. 将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。\n\n本文采取的是第一种方式，关于两种方式利弊的比较：\n\n// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor\n\n另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。\n\n```cpp\n// AVLNode.h\n\n#ifndef __AVLNODE_H__\n#define __AVLNODE_H__\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename KeyType>\nclass AVLNode{\npublic:\n    KeyType key;\n    AVLNode * left;\n    AVLNode * right;\n    AVLNode() : key(0), left(NULL), right(NULL) {}\n    AVLNode(KeyType k) :key(k), left(NULL), right(NULL) {}\n};\n#endif\n```\n\n~~~cpp\n// AVLTree.h\n\n#ifndef AVLTREE_AVLTREE_H\n#define AVLTREE_AVLTREE_H\n\n#include \"AVLNode.h\"\n\n//AVL树的模板实现\ntemplate <typename KeyType>\nclass AVLTree\n{\n    //类型定义\n    typedef AVLNode<KeyType> AVLNode;\n    typedef AVLTree<KeyType> AVLTree;\n\nprivate:\n    AVLNode * avlroot;\n    //求树的高度\n    int __height(const AVLNode *root);\n    //高度差（平衡因子）\n    int __diff(const AVLNode*root);\n\n    //AVL4种旋转：左左，左右，右右，右左\n    //X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点\n    //X通过递归返回的方式找到\n    //左左：插入点位于X的左孩子节点的左子树\n    //左右：插入点位于X的左孩子节点的右子树\n    //右右：插入点位于X的右孩子节点的右子树\n    //右左：插入点位于X的右孩子节点的左子树\n\n    //单旋转\n    AVLNode * __ll_Rotation(AVLNode *root);//left-left rotation\n    AVLNode * __rr_Rotation(AVLNode *root);//right-right rotation\n    //双旋转\n    AVLNode * __lr_Rotation(AVLNode *root);//left-right rotation\n    AVLNode * __rl_Rotation(AVLNode *root);//right-left rotation\n\n\n\t//平衡操作\n    AVLNode * __Balance(AVLNode *root);\n    //插入的内部实现\n    AVLNode * __Insert(AVLNode *root, const KeyType &k);\n    //中序遍历的两种重载\n    // 1. 直接输出中序遍历节点\n    void __InorderTraversal(const AVLNode* root);\n    // 2. 结果保存到vector中\n    void __InorderTraversal(const AVLNode*root, std::vector<KeyType>&vec);\n\t//判断是否是叶子节点\n    bool __isLeaf(AVLNode* const &node) {return (node->left == nullptr && node->right == nullptr) ? true : false};\n    //判断是否有两个孩子\n    bool __isNodeWithTwoChild(AVLNode * const &node);\n\t//查找的内部实现\n    AVLNode* __search(AVLNode *const root, const KeyType &k);\n\t//删除树的所有节点\n    void __deleteTree(AVLNode * root);\n\t//删除节点\n    AVLNode* __Delete(AVLNode * root, const KeyType& k);\n\t//求当前根节点最小（一路向左）\n    AVLNode* __treeMin(AVLNode *root);\n    //求当前根节点的最大（一路向右）\n    AVLNode* __treeMax(AVLNode *root);\n\n\npublic:\n    AVLTree(){ avlroot = nullptr; }//默认构造函数\n    ~AVLTree();//析构函数删除树中所有节点\n    AVLTree(const std::vector<KeyType>&);//构造函数，容器构造\n    AVLTree(const KeyType * arr, size_t len);//构造函数，数组构造\n    void InorderTraversal();//中序遍历外部接口\n    void InorderTraversal(std::vector<KeyType>&);//中序遍历外部接口重载2\n    bool Delete(const KeyType &k);//删除节点的外部接口\n    void Insert(const KeyType & k);//插入节点的外部接口\n    bool IsEmpty(){ return avlroot == nullptr; } //树空？\n    bool search(const KeyType &k);//查询外部接口\n};\n#endif //AVLTREE_AVLTREE_H\n\n~~~\n\n### 旋转操作\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__ll_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rr_Rotation(AVLNode *root)\n{\n    AVLNode* tmp;\n    tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__lr_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = __rr_Rotation(tmp);\n    return __ll_Rotation(root);\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rl_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->right;\n    root->right = __ll_Rotation(tmp);\n    return __rr_Rotation(root);\n}\n~~~\n\n### AVLTree 插入\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Insert(AVLNode * root, const KeyType& k)\n{\n    if (nullptr == root)\n    {\n        root = new AVLNode(k);\n        return root;\n    }//递归返回条件\n    else if (k < root->key)\n    {\n        root->left = __Insert(root->left, k);//递归左子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    else if (k>root->key)\n    {\n        root->right = __Insert(root->right, k);//递归右子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    return root;\n}\n~~~\n\n\n\n### AVLTree 删除\n\n~~~cpp\n//删除节点的私有成员实现\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Delete(AVLNode *root, const KeyType& k)\n{\n    if (nullptr == root)\n        return root;\n    if (!search(k))//查找删除元素是否存在\n    {\n        std::cerr << \"Delete error , key not find\" << std::endl;\n        return root;\n    }\n\n    if (k == root->key)//根节点\n    {\n        if (__isNodeWithTwoChild(root))//左右子树都非空\n        {\n            if (__diff(root) > 0)//左子树更高，在左边删除\n            {\n                root->key = __treeMax(root->left)->key;//以左子树的最大值替换当前值\n                root->left = __Delete(root->left, root->key);//删除左子树中已经替换上去的节点\n            }\n            else//右子树更高，在右边删除\n            {\n                root->key = __treeMin(root->right)->key;\n                root->right = __Delete(root->right, root->key);\n            }\n        }\n        else//有一个孩子、叶子节点的情况合并\n        {\n            //if (!__isLeaf(root))\n            AVLNode * tmp = root;\n            root = (root->left) ? (root->left) :( root->right);\n            delete tmp;\n            tmp = nullptr;\n        }\n    }//end-if\n    else if (k < root->key)//往左边删除\n    {\n        root->left = __Delete(root->left, k);//左子树中递归删除\n        //判断平衡的条件与在插入时情况类似\n        if (__diff(root) < -1)//不满足平衡条件，删除左边的后，右子树变高\n        {\n            if (__diff(root->right) > 0)\n            {\n                root = __rl_Rotation(root);\n            }\n            else\n            {\n                root = __rr_Rotation(root);\n            }\n        }\n    }//end else if\n    else\n    {\n        root->right = __Delete(root->right, k);\n        if (__diff(root) > 1)//不满足平衡条件\n        {\n            if (__diff(root->left) < 0)\n            {\n                root = __lr_Rotation(root);\n            }\n            else\n            {\n                root = __ll_Rotation(root);\n            }\n        }\n    }\n    return root;\n}\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree)\n\n## 参考\n\n[STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）](https://blog.csdn.net/zhangxiao93/article/details/51459743)\n\n[平衡二叉树,AVL树之图解篇](http://www.cnblogs.com/suimeng/p/4560056.html)\n\n[一步一步写平衡二叉树（AVL树）](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n[平衡二叉树(avl)分析与实现](http://luodw.cc/2015/11/14/avl/)","source":"_posts/Algorithm/Data-Structure/avlree-template-implement.md","raw":"---\ntitle: 平衡二叉树（AVLTree）封装+模板实现\ndate: 2019-11-27 11:36:49\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - tree\n---\n\n## 简介\n\n[平衡树（AVLTree）](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n\n> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**AVL树**是最先发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)都是![O(\\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。增加和删除可能需要通过一次或多次[树旋转](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC)来重新平衡这个树。AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA)和[E. M. Landis](https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1)，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n>\n> 节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”**二叉搜索树**，平衡条件确保整棵树的深度为O(log n)。\n\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。**查找、插入和删除在平均和最坏情况下都是 O(log n)**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。\n\nAVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。\n\n\n\n## AVL旋转\n\nAVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。\n\n在理解AVL旋转之前，首先得知道以下几个概念： \n\n1. AVL 树节点的插入总是在叶子节点。 \n2. AVL 树在插入节点之前总是满足平衡条件的。 \n1. 插入新节点后有可能满足平衡条件也有可能不满足。 \n4. 当不满足平衡条件后，我们就需要对新的树进行旋转。\n\n\n旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：\n\n> 假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。\n\n基于这个X节点，考虑一件事情： \n这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：\n\n> X的左孩子节点的左子树上**(left-left)** \n> X的右孩子节点的右子树上**(right-right)** \n> X的左孩子节点的右子树上**(left-right)** \n> X的右孩子节点的左子树上**(right-left)**\n\n根据上述情况就延生出了4种旋转： \n**1.left-left Rotation** \n**2.right-right Rotation** \n**3.left-right Rotation** \n**4.right-left Rotation**\n\n前两种属于单旋转，后两种属于双旋转，**双旋转的操作可以由两次单旋转组成。**\n\nPS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。\n\n[![avl旋转四种情况](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)\n\n图片来自 [C小加的博客](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n1. 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。\n2. 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。\n3. 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。\n4. 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。\n\n从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。\n\n那么为什么需要双旋转呢？\n\n这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。\n\n而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。\n\n// 这里的描述太那啥了，得搞点图说明下\n\n\n\n## AVL-Tree实现\n\nAVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。\n\n节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： \n\n1. 每次都计算一次（递归求深度）。 \n2. 将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。\n\n本文采取的是第一种方式，关于两种方式利弊的比较：\n\n// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor\n\n另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。\n\n```cpp\n// AVLNode.h\n\n#ifndef __AVLNODE_H__\n#define __AVLNODE_H__\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename KeyType>\nclass AVLNode{\npublic:\n    KeyType key;\n    AVLNode * left;\n    AVLNode * right;\n    AVLNode() : key(0), left(NULL), right(NULL) {}\n    AVLNode(KeyType k) :key(k), left(NULL), right(NULL) {}\n};\n#endif\n```\n\n~~~cpp\n// AVLTree.h\n\n#ifndef AVLTREE_AVLTREE_H\n#define AVLTREE_AVLTREE_H\n\n#include \"AVLNode.h\"\n\n//AVL树的模板实现\ntemplate <typename KeyType>\nclass AVLTree\n{\n    //类型定义\n    typedef AVLNode<KeyType> AVLNode;\n    typedef AVLTree<KeyType> AVLTree;\n\nprivate:\n    AVLNode * avlroot;\n    //求树的高度\n    int __height(const AVLNode *root);\n    //高度差（平衡因子）\n    int __diff(const AVLNode*root);\n\n    //AVL4种旋转：左左，左右，右右，右左\n    //X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点\n    //X通过递归返回的方式找到\n    //左左：插入点位于X的左孩子节点的左子树\n    //左右：插入点位于X的左孩子节点的右子树\n    //右右：插入点位于X的右孩子节点的右子树\n    //右左：插入点位于X的右孩子节点的左子树\n\n    //单旋转\n    AVLNode * __ll_Rotation(AVLNode *root);//left-left rotation\n    AVLNode * __rr_Rotation(AVLNode *root);//right-right rotation\n    //双旋转\n    AVLNode * __lr_Rotation(AVLNode *root);//left-right rotation\n    AVLNode * __rl_Rotation(AVLNode *root);//right-left rotation\n\n\n\t//平衡操作\n    AVLNode * __Balance(AVLNode *root);\n    //插入的内部实现\n    AVLNode * __Insert(AVLNode *root, const KeyType &k);\n    //中序遍历的两种重载\n    // 1. 直接输出中序遍历节点\n    void __InorderTraversal(const AVLNode* root);\n    // 2. 结果保存到vector中\n    void __InorderTraversal(const AVLNode*root, std::vector<KeyType>&vec);\n\t//判断是否是叶子节点\n    bool __isLeaf(AVLNode* const &node) {return (node->left == nullptr && node->right == nullptr) ? true : false};\n    //判断是否有两个孩子\n    bool __isNodeWithTwoChild(AVLNode * const &node);\n\t//查找的内部实现\n    AVLNode* __search(AVLNode *const root, const KeyType &k);\n\t//删除树的所有节点\n    void __deleteTree(AVLNode * root);\n\t//删除节点\n    AVLNode* __Delete(AVLNode * root, const KeyType& k);\n\t//求当前根节点最小（一路向左）\n    AVLNode* __treeMin(AVLNode *root);\n    //求当前根节点的最大（一路向右）\n    AVLNode* __treeMax(AVLNode *root);\n\n\npublic:\n    AVLTree(){ avlroot = nullptr; }//默认构造函数\n    ~AVLTree();//析构函数删除树中所有节点\n    AVLTree(const std::vector<KeyType>&);//构造函数，容器构造\n    AVLTree(const KeyType * arr, size_t len);//构造函数，数组构造\n    void InorderTraversal();//中序遍历外部接口\n    void InorderTraversal(std::vector<KeyType>&);//中序遍历外部接口重载2\n    bool Delete(const KeyType &k);//删除节点的外部接口\n    void Insert(const KeyType & k);//插入节点的外部接口\n    bool IsEmpty(){ return avlroot == nullptr; } //树空？\n    bool search(const KeyType &k);//查询外部接口\n};\n#endif //AVLTREE_AVLTREE_H\n\n~~~\n\n### 旋转操作\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__ll_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rr_Rotation(AVLNode *root)\n{\n    AVLNode* tmp;\n    tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__lr_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = __rr_Rotation(tmp);\n    return __ll_Rotation(root);\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rl_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->right;\n    root->right = __ll_Rotation(tmp);\n    return __rr_Rotation(root);\n}\n~~~\n\n### AVLTree 插入\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Insert(AVLNode * root, const KeyType& k)\n{\n    if (nullptr == root)\n    {\n        root = new AVLNode(k);\n        return root;\n    }//递归返回条件\n    else if (k < root->key)\n    {\n        root->left = __Insert(root->left, k);//递归左子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    else if (k>root->key)\n    {\n        root->right = __Insert(root->right, k);//递归右子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    return root;\n}\n~~~\n\n\n\n### AVLTree 删除\n\n~~~cpp\n//删除节点的私有成员实现\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Delete(AVLNode *root, const KeyType& k)\n{\n    if (nullptr == root)\n        return root;\n    if (!search(k))//查找删除元素是否存在\n    {\n        std::cerr << \"Delete error , key not find\" << std::endl;\n        return root;\n    }\n\n    if (k == root->key)//根节点\n    {\n        if (__isNodeWithTwoChild(root))//左右子树都非空\n        {\n            if (__diff(root) > 0)//左子树更高，在左边删除\n            {\n                root->key = __treeMax(root->left)->key;//以左子树的最大值替换当前值\n                root->left = __Delete(root->left, root->key);//删除左子树中已经替换上去的节点\n            }\n            else//右子树更高，在右边删除\n            {\n                root->key = __treeMin(root->right)->key;\n                root->right = __Delete(root->right, root->key);\n            }\n        }\n        else//有一个孩子、叶子节点的情况合并\n        {\n            //if (!__isLeaf(root))\n            AVLNode * tmp = root;\n            root = (root->left) ? (root->left) :( root->right);\n            delete tmp;\n            tmp = nullptr;\n        }\n    }//end-if\n    else if (k < root->key)//往左边删除\n    {\n        root->left = __Delete(root->left, k);//左子树中递归删除\n        //判断平衡的条件与在插入时情况类似\n        if (__diff(root) < -1)//不满足平衡条件，删除左边的后，右子树变高\n        {\n            if (__diff(root->right) > 0)\n            {\n                root = __rl_Rotation(root);\n            }\n            else\n            {\n                root = __rr_Rotation(root);\n            }\n        }\n    }//end else if\n    else\n    {\n        root->right = __Delete(root->right, k);\n        if (__diff(root) > 1)//不满足平衡条件\n        {\n            if (__diff(root->left) < 0)\n            {\n                root = __lr_Rotation(root);\n            }\n            else\n            {\n                root = __ll_Rotation(root);\n            }\n        }\n    }\n    return root;\n}\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree)\n\n## 参考\n\n[STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）](https://blog.csdn.net/zhangxiao93/article/details/51459743)\n\n[平衡二叉树,AVL树之图解篇](http://www.cnblogs.com/suimeng/p/4560056.html)\n\n[一步一步写平衡二叉树（AVL树）](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n[平衡二叉树(avl)分析与实现](http://luodw.cc/2015/11/14/avl/)","slug":"Algorithm/Data-Structure/avlree-template-implement","published":1,"updated":"2019-11-27T03:37:09.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrds003flon9mrm0c3yu","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/AVL%E6%A0%91\" target=\"_blank\" rel=\"noopener\">平衡树（AVLTree）</a></p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">计算机科学</a>中，<strong>AVL树</strong>是最先发明的<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\" target=\"_blank\" rel=\"noopener\">自平衡二叉查找树</a>。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">时间复杂度</a>都是<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99\" alt=\"O(\\log{n})\">。增加和删除可能需要通过一次或多次<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC\" target=\"_blank\" rel=\"noopener\">树旋转</a>来重新平衡这个树。AVL树得名于它的发明者<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA\" target=\"_blank\" rel=\"noopener\">G. M. Adelson-Velsky</a>和<a href=\"https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">E. M. Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>\n<p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>\n</blockquote>\n<p>二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”<strong>二叉搜索树</strong>，平衡条件确保整棵树的深度为O(log n)。</p>\n<p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。<strong>查找、插入和删除在平均和最坏情况下都是 O(log n)</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>\n<p>AVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。</p>\n<h2 id=\"AVL旋转\"><a href=\"#AVL旋转\" class=\"headerlink\" title=\"AVL旋转\"></a>AVL旋转</h2><p>AVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。</p>\n<p>在理解AVL旋转之前，首先得知道以下几个概念： </p>\n<ol>\n<li>AVL 树节点的插入总是在叶子节点。 </li>\n<li>AVL 树在插入节点之前总是满足平衡条件的。 </li>\n<li>插入新节点后有可能满足平衡条件也有可能不满足。 </li>\n<li>当不满足平衡条件后，我们就需要对新的树进行旋转。</li>\n</ol>\n<p>旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：</p>\n<blockquote>\n<p>假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。</p>\n</blockquote>\n<p>基于这个X节点，考虑一件事情：<br>这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：</p>\n<blockquote>\n<p>X的左孩子节点的左子树上<strong>(left-left)</strong><br>X的右孩子节点的右子树上<strong>(right-right)</strong><br>X的左孩子节点的右子树上<strong>(left-right)</strong><br>X的右孩子节点的左子树上<strong>(right-left)</strong></p>\n</blockquote>\n<p>根据上述情况就延生出了4种旋转：<br><strong>1.left-left Rotation</strong><br><strong>2.right-right Rotation</strong><br><strong>3.left-right Rotation</strong><br><strong>4.right-left Rotation</strong></p>\n<p>前两种属于单旋转，后两种属于双旋转，<strong>双旋转的操作可以由两次单旋转组成。</strong></p>\n<p>PS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。</p>\n<p><a href=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" alt=\"avl旋转四种情况\"></a></p>\n<p>图片来自 <a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">C小加的博客</a></p>\n<ol>\n<li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。</li>\n<li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。</li>\n<li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。</li>\n<li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。</li>\n</ol>\n<p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p>\n<p>那么为什么需要双旋转呢？</p>\n<p>这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。</p>\n<p>而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。</p>\n<p>// 这里的描述太那啥了，得搞点图说明下</p>\n<h2 id=\"AVL-Tree实现\"><a href=\"#AVL-Tree实现\" class=\"headerlink\" title=\"AVL-Tree实现\"></a>AVL-Tree实现</h2><p>AVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。</p>\n<p>节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： </p>\n<ol>\n<li>每次都计算一次（递归求深度）。 </li>\n<li>将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。</li>\n</ol>\n<p>本文采取的是第一种方式，关于两种方式利弊的比较：</p>\n<p>// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor</p>\n<p>另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLNode.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __AVLNODE_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __AVLNODE_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    KeyType key;</span><br><span class=\"line\">    AVLNode * left;</span><br><span class=\"line\">    AVLNode * right;</span><br><span class=\"line\">    AVLNode() : key(<span class=\"number\">0</span>), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">    AVLNode(KeyType k) :key(k), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLTree.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"AVLNode.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//AVL树的模板实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型定义</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLNode&lt;KeyType&gt; AVLNode;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLTree&lt;KeyType&gt; AVLTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    AVLNode * avlroot;</span><br><span class=\"line\">    <span class=\"comment\">//求树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __height(<span class=\"keyword\">const</span> AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//高度差（平衡因子）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __diff(<span class=\"keyword\">const</span> AVLNode*root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//AVL4种旋转：左左，左右，右右，右左</span></span><br><span class=\"line\">    <span class=\"comment\">//X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点</span></span><br><span class=\"line\">    <span class=\"comment\">//X通过递归返回的方式找到</span></span><br><span class=\"line\">    <span class=\"comment\">//左左：插入点位于X的左孩子节点的左子树</span></span><br><span class=\"line\">    <span class=\"comment\">//左右：插入点位于X的左孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右右：插入点位于X的右孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右左：插入点位于X的右孩子节点的左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//单旋转</span></span><br><span class=\"line\">    AVLNode * __ll_Rotation(AVLNode *root);<span class=\"comment\">//left-left rotation</span></span><br><span class=\"line\">    AVLNode * __rr_Rotation(AVLNode *root);<span class=\"comment\">//right-right rotation</span></span><br><span class=\"line\">    <span class=\"comment\">//双旋转</span></span><br><span class=\"line\">    AVLNode * __lr_Rotation(AVLNode *root);<span class=\"comment\">//left-right rotation</span></span><br><span class=\"line\">    AVLNode * __rl_Rotation(AVLNode *root);<span class=\"comment\">//right-left rotation</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//平衡操作</span></span><br><span class=\"line\">    AVLNode * __Balance(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//插入的内部实现</span></span><br><span class=\"line\">    AVLNode * __Insert(AVLNode *root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">    <span class=\"comment\">//中序遍历的两种重载</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 直接输出中序遍历节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode* root);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 结果保存到vector中</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode*root, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;vec);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否是叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isLeaf(AVLNode* <span class=\"keyword\">const</span> &amp;node) &#123;<span class=\"keyword\">return</span> (node-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right == <span class=\"literal\">nullptr</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有两个孩子</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isNodeWithTwoChild(AVLNode * <span class=\"keyword\">const</span> &amp;node);</span><br><span class=\"line\">\t<span class=\"comment\">//查找的内部实现</span></span><br><span class=\"line\">    AVLNode* __search(AVLNode *<span class=\"keyword\">const</span> root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">\t<span class=\"comment\">//删除树的所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __deleteTree(AVLNode * root);</span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    AVLNode* __Delete(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k);</span><br><span class=\"line\">\t<span class=\"comment\">//求当前根节点最小（一路向左）</span></span><br><span class=\"line\">    AVLNode* __treeMin(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//求当前根节点的最大（一路向右）</span></span><br><span class=\"line\">    AVLNode* __treeMax(AVLNode *root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AVLTree()&#123; avlroot = <span class=\"literal\">nullptr</span>; &#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    ~AVLTree();<span class=\"comment\">//析构函数删除树中所有节点</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;);<span class=\"comment\">//构造函数，容器构造</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> KeyType * arr, <span class=\"keyword\">size_t</span> len);<span class=\"comment\">//构造函数，数组构造</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">()</span></span>;<span class=\"comment\">//中序遍历外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;)</span></span>;<span class=\"comment\">//中序遍历外部接口重载2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//删除节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp; k)</span></span>;<span class=\"comment\">//插入节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> avlroot == <span class=\"literal\">nullptr</span>; &#125; <span class=\"comment\">//树空？</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//查询外部接口</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//AVLTREE_AVLTREE_H</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"旋转操作\"><a href=\"#旋转操作\" class=\"headerlink\" title=\"旋转操作\"></a>旋转操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__ll_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = tmp-&gt;right;</span><br><span class=\"line\">    tmp-&gt;right = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode* tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp-&gt;left;</span><br><span class=\"line\">    tmp-&gt;left = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__lr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = __rr_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __ll_Rotation(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rl_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = __ll_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __rr_Rotation(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-插入\"><a href=\"#AVLTree-插入\" class=\"headerlink\" title=\"AVLTree 插入\"></a>AVLTree 插入</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Insert(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> AVLNode(k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//递归返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Insert(root-&gt;left, k);<span class=\"comment\">//递归左子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k&gt;root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Insert(root-&gt;right, k);<span class=\"comment\">//递归右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-删除\"><a href=\"#AVLTree-删除\" class=\"headerlink\" title=\"AVLTree 删除\"></a>AVLTree 删除</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除节点的私有成员实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Delete(AVLNode *root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!search(k))<span class=\"comment\">//查找删除元素是否存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Delete error , key not find\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == root-&gt;key)<span class=\"comment\">//根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__isNodeWithTwoChild(root))<span class=\"comment\">//左右子树都非空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">0</span>)<span class=\"comment\">//左子树更高，在左边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMax(root-&gt;left)-&gt;key;<span class=\"comment\">//以左子树的最大值替换当前值</span></span><br><span class=\"line\">                root-&gt;left = __Delete(root-&gt;left, root-&gt;key);<span class=\"comment\">//删除左子树中已经替换上去的节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//右子树更高，在右边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMin(root-&gt;right)-&gt;key;</span><br><span class=\"line\">                root-&gt;right = __Delete(root-&gt;right, root-&gt;key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//有一个孩子、叶子节点的情况合并</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//if (!__isLeaf(root))</span></span><br><span class=\"line\">            AVLNode * tmp = root;</span><br><span class=\"line\">            root = (root-&gt;left) ? (root-&gt;left) :( root-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end-if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)<span class=\"comment\">//往左边删除</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Delete(root-&gt;left, k);<span class=\"comment\">//左子树中递归删除</span></span><br><span class=\"line\">        <span class=\"comment\">//判断平衡的条件与在插入时情况类似</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &lt; <span class=\"number\">-1</span>)<span class=\"comment\">//不满足平衡条件，删除左边的后，右子树变高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;right) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rl_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end else if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Delete(root-&gt;right, k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">1</span>)<span class=\"comment\">//不满足平衡条件</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;left) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __lr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __ll_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/zhangxiao93/article/details/51459743\" target=\"_blank\" rel=\"noopener\">STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）</a></p>\n<p><a href=\"http://www.cnblogs.com/suimeng/p/4560056.html\" target=\"_blank\" rel=\"noopener\">平衡二叉树,AVL树之图解篇</a></p>\n<p><a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">一步一步写平衡二叉树（AVL树）</a></p>\n<p><a href=\"http://luodw.cc/2015/11/14/avl/\" target=\"_blank\" rel=\"noopener\">平衡二叉树(avl)分析与实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/AVL%E6%A0%91\" target=\"_blank\" rel=\"noopener\">平衡树（AVLTree）</a></p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">计算机科学</a>中，<strong>AVL树</strong>是最先发明的<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\" target=\"_blank\" rel=\"noopener\">自平衡二叉查找树</a>。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">时间复杂度</a>都是<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99\" alt=\"O(\\log{n})\">。增加和删除可能需要通过一次或多次<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC\" target=\"_blank\" rel=\"noopener\">树旋转</a>来重新平衡这个树。AVL树得名于它的发明者<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA\" target=\"_blank\" rel=\"noopener\">G. M. Adelson-Velsky</a>和<a href=\"https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">E. M. Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>\n<p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>\n</blockquote>\n<p>二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”<strong>二叉搜索树</strong>，平衡条件确保整棵树的深度为O(log n)。</p>\n<p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。<strong>查找、插入和删除在平均和最坏情况下都是 O(log n)</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>\n<p>AVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。</p>\n<h2 id=\"AVL旋转\"><a href=\"#AVL旋转\" class=\"headerlink\" title=\"AVL旋转\"></a>AVL旋转</h2><p>AVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。</p>\n<p>在理解AVL旋转之前，首先得知道以下几个概念： </p>\n<ol>\n<li>AVL 树节点的插入总是在叶子节点。 </li>\n<li>AVL 树在插入节点之前总是满足平衡条件的。 </li>\n<li>插入新节点后有可能满足平衡条件也有可能不满足。 </li>\n<li>当不满足平衡条件后，我们就需要对新的树进行旋转。</li>\n</ol>\n<p>旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：</p>\n<blockquote>\n<p>假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。</p>\n</blockquote>\n<p>基于这个X节点，考虑一件事情：<br>这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：</p>\n<blockquote>\n<p>X的左孩子节点的左子树上<strong>(left-left)</strong><br>X的右孩子节点的右子树上<strong>(right-right)</strong><br>X的左孩子节点的右子树上<strong>(left-right)</strong><br>X的右孩子节点的左子树上<strong>(right-left)</strong></p>\n</blockquote>\n<p>根据上述情况就延生出了4种旋转：<br><strong>1.left-left Rotation</strong><br><strong>2.right-right Rotation</strong><br><strong>3.left-right Rotation</strong><br><strong>4.right-left Rotation</strong></p>\n<p>前两种属于单旋转，后两种属于双旋转，<strong>双旋转的操作可以由两次单旋转组成。</strong></p>\n<p>PS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。</p>\n<p><a href=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" alt=\"avl旋转四种情况\"></a></p>\n<p>图片来自 <a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">C小加的博客</a></p>\n<ol>\n<li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。</li>\n<li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。</li>\n<li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。</li>\n<li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。</li>\n</ol>\n<p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p>\n<p>那么为什么需要双旋转呢？</p>\n<p>这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。</p>\n<p>而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。</p>\n<p>// 这里的描述太那啥了，得搞点图说明下</p>\n<h2 id=\"AVL-Tree实现\"><a href=\"#AVL-Tree实现\" class=\"headerlink\" title=\"AVL-Tree实现\"></a>AVL-Tree实现</h2><p>AVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。</p>\n<p>节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： </p>\n<ol>\n<li>每次都计算一次（递归求深度）。 </li>\n<li>将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。</li>\n</ol>\n<p>本文采取的是第一种方式，关于两种方式利弊的比较：</p>\n<p>// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor</p>\n<p>另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLNode.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __AVLNODE_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __AVLNODE_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    KeyType key;</span><br><span class=\"line\">    AVLNode * left;</span><br><span class=\"line\">    AVLNode * right;</span><br><span class=\"line\">    AVLNode() : key(<span class=\"number\">0</span>), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">    AVLNode(KeyType k) :key(k), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLTree.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"AVLNode.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//AVL树的模板实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型定义</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLNode&lt;KeyType&gt; AVLNode;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLTree&lt;KeyType&gt; AVLTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    AVLNode * avlroot;</span><br><span class=\"line\">    <span class=\"comment\">//求树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __height(<span class=\"keyword\">const</span> AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//高度差（平衡因子）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __diff(<span class=\"keyword\">const</span> AVLNode*root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//AVL4种旋转：左左，左右，右右，右左</span></span><br><span class=\"line\">    <span class=\"comment\">//X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点</span></span><br><span class=\"line\">    <span class=\"comment\">//X通过递归返回的方式找到</span></span><br><span class=\"line\">    <span class=\"comment\">//左左：插入点位于X的左孩子节点的左子树</span></span><br><span class=\"line\">    <span class=\"comment\">//左右：插入点位于X的左孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右右：插入点位于X的右孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右左：插入点位于X的右孩子节点的左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//单旋转</span></span><br><span class=\"line\">    AVLNode * __ll_Rotation(AVLNode *root);<span class=\"comment\">//left-left rotation</span></span><br><span class=\"line\">    AVLNode * __rr_Rotation(AVLNode *root);<span class=\"comment\">//right-right rotation</span></span><br><span class=\"line\">    <span class=\"comment\">//双旋转</span></span><br><span class=\"line\">    AVLNode * __lr_Rotation(AVLNode *root);<span class=\"comment\">//left-right rotation</span></span><br><span class=\"line\">    AVLNode * __rl_Rotation(AVLNode *root);<span class=\"comment\">//right-left rotation</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//平衡操作</span></span><br><span class=\"line\">    AVLNode * __Balance(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//插入的内部实现</span></span><br><span class=\"line\">    AVLNode * __Insert(AVLNode *root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">    <span class=\"comment\">//中序遍历的两种重载</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 直接输出中序遍历节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode* root);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 结果保存到vector中</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode*root, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;vec);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否是叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isLeaf(AVLNode* <span class=\"keyword\">const</span> &amp;node) &#123;<span class=\"keyword\">return</span> (node-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right == <span class=\"literal\">nullptr</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有两个孩子</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isNodeWithTwoChild(AVLNode * <span class=\"keyword\">const</span> &amp;node);</span><br><span class=\"line\">\t<span class=\"comment\">//查找的内部实现</span></span><br><span class=\"line\">    AVLNode* __search(AVLNode *<span class=\"keyword\">const</span> root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">\t<span class=\"comment\">//删除树的所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __deleteTree(AVLNode * root);</span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    AVLNode* __Delete(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k);</span><br><span class=\"line\">\t<span class=\"comment\">//求当前根节点最小（一路向左）</span></span><br><span class=\"line\">    AVLNode* __treeMin(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//求当前根节点的最大（一路向右）</span></span><br><span class=\"line\">    AVLNode* __treeMax(AVLNode *root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AVLTree()&#123; avlroot = <span class=\"literal\">nullptr</span>; &#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    ~AVLTree();<span class=\"comment\">//析构函数删除树中所有节点</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;);<span class=\"comment\">//构造函数，容器构造</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> KeyType * arr, <span class=\"keyword\">size_t</span> len);<span class=\"comment\">//构造函数，数组构造</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">()</span></span>;<span class=\"comment\">//中序遍历外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;)</span></span>;<span class=\"comment\">//中序遍历外部接口重载2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//删除节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp; k)</span></span>;<span class=\"comment\">//插入节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> avlroot == <span class=\"literal\">nullptr</span>; &#125; <span class=\"comment\">//树空？</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//查询外部接口</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//AVLTREE_AVLTREE_H</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"旋转操作\"><a href=\"#旋转操作\" class=\"headerlink\" title=\"旋转操作\"></a>旋转操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__ll_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = tmp-&gt;right;</span><br><span class=\"line\">    tmp-&gt;right = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode* tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp-&gt;left;</span><br><span class=\"line\">    tmp-&gt;left = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__lr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = __rr_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __ll_Rotation(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rl_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = __ll_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __rr_Rotation(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-插入\"><a href=\"#AVLTree-插入\" class=\"headerlink\" title=\"AVLTree 插入\"></a>AVLTree 插入</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Insert(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> AVLNode(k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//递归返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Insert(root-&gt;left, k);<span class=\"comment\">//递归左子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k&gt;root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Insert(root-&gt;right, k);<span class=\"comment\">//递归右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-删除\"><a href=\"#AVLTree-删除\" class=\"headerlink\" title=\"AVLTree 删除\"></a>AVLTree 删除</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除节点的私有成员实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Delete(AVLNode *root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!search(k))<span class=\"comment\">//查找删除元素是否存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Delete error , key not find\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == root-&gt;key)<span class=\"comment\">//根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__isNodeWithTwoChild(root))<span class=\"comment\">//左右子树都非空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">0</span>)<span class=\"comment\">//左子树更高，在左边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMax(root-&gt;left)-&gt;key;<span class=\"comment\">//以左子树的最大值替换当前值</span></span><br><span class=\"line\">                root-&gt;left = __Delete(root-&gt;left, root-&gt;key);<span class=\"comment\">//删除左子树中已经替换上去的节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//右子树更高，在右边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMin(root-&gt;right)-&gt;key;</span><br><span class=\"line\">                root-&gt;right = __Delete(root-&gt;right, root-&gt;key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//有一个孩子、叶子节点的情况合并</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//if (!__isLeaf(root))</span></span><br><span class=\"line\">            AVLNode * tmp = root;</span><br><span class=\"line\">            root = (root-&gt;left) ? (root-&gt;left) :( root-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end-if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)<span class=\"comment\">//往左边删除</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Delete(root-&gt;left, k);<span class=\"comment\">//左子树中递归删除</span></span><br><span class=\"line\">        <span class=\"comment\">//判断平衡的条件与在插入时情况类似</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &lt; <span class=\"number\">-1</span>)<span class=\"comment\">//不满足平衡条件，删除左边的后，右子树变高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;right) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rl_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end else if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Delete(root-&gt;right, k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">1</span>)<span class=\"comment\">//不满足平衡条件</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;left) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __lr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __ll_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/zhangxiao93/article/details/51459743\" target=\"_blank\" rel=\"noopener\">STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）</a></p>\n<p><a href=\"http://www.cnblogs.com/suimeng/p/4560056.html\" target=\"_blank\" rel=\"noopener\">平衡二叉树,AVL树之图解篇</a></p>\n<p><a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">一步一步写平衡二叉树（AVL树）</a></p>\n<p><a href=\"http://luodw.cc/2015/11/14/avl/\" target=\"_blank\" rel=\"noopener\">平衡二叉树(avl)分析与实现</a></p>\n"},{"title":"求图的拓扑排序","_content":"\n## 简介\n\n[**拓扑排序** （Topological Sorting）](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)\n\n> 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。\n> 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。\n>\n> 1. 每个顶点出现且只出现一次；\n> 2. 若A在序列中排在B的前面，则在图中不存在从B到A的边。\n>\n> 也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n## 问题描述\n\n一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 <i, j> 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（*Activity on Vertex*），记作 **AOV网络**。\n\n在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。\n\n一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫**拓扑排序**。\n\n例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。\n![img](https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg)\n\n## 算法思路\n\n1. 在AOV网络中选一个没有直接前驱的顶点v，并输出\n2. 从图中删除该顶点，同时删去所有从顶点v发出的弧\n3. 重复步骤1,2. 直到没有直接前驱的顶点全部输出\n\n## 算法步骤\n\n用二维list链表存储图的领接表\n\n1. 建立入度为0的顶点栈\n2. 当入度为0的顶点栈为空时，转到步骤6，否则步骤3\n3. 从入度为0的顶点栈顶元素v出栈，并输出顶点v\n4. 从AOV网络删去顶点v和所有顶点v发出的弧 <v, j>， 并将顶点 j 的入度 -1\n5. 如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2\n6. 如果输出顶点个数 < AOV网络顶点数，则图中存在有向环\n\n\n\n## 复杂度分析\n\nTopological Sorting via Depth First Search(DFS)\n在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。\n\n在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。\n\n因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。\n\n\n\n## 代码实现\n\n### C++ \n\n```cpp\n#include<iostream>\n#include <list>\n#include <stack>\nusing namespace std;\n\n// Class to represent a graph\nclass Graph\n{\n    int V;    // No. of vertices'\n\n    // Pointer to an array containing adjacency listsList\n    list<int> *adj;\n\n    // A function used by topologicalSort\n    void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\npublic:\n    Graph(int V);   // Constructor\n\n     // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // prints a Topological Sort of the complete graph\n    void topologicalSort();\n};\n\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v’s list.\n}\n\n// A recursive function used by topologicalSort\nvoid Graph::topologicalSortUtil(int v, bool visited[], \n                                stack<int> &Stack)\n{\n    // Mark the current node as visited.\n    visited[v] = true;\n\n    // Recur for all the vertices adjacent to this vertex\n    list<int>::iterator i;\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\n        if (!visited[*i])\n            topologicalSortUtil(*i, visited, Stack);\n\n    // Push current vertex to stack which stores result\n    Stack.push(v);\n}\n\n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil()\nvoid Graph::topologicalSort()\n{\n    stack<int> Stack;\n\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    // Call the recursive helper function to store Topological\n    // Sort starting from all vertices one by one\n    for (int i = 0; i < V; i++)\n      if (visited[i] == false)\n        topologicalSortUtil(i, visited, Stack);\n\n    // Print contents of stack\n    while (Stack.empty() == false)\n    {\n        cout << Stack.top() << \" \";\n        Stack.pop();\n    }\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"Following is a Topological Sort of the given graph n\";\n    g.topologicalSort();\n\n    return 0;\n}\n```\n\n### Java \n\n```java\nimport java.io.*;\nimport java.util.*;\n\n// This class represents a directed graph using adjacency\n// list representation\nclass Graph\n{\n    private int V;   // No. of vertices\n    private LinkedList<Integer> adj[]; // Adjacency List\n\n    //Constructor\n    Graph(int v)\n    {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i=0; i<v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    // Function to add an edge into the graph\n    void addEdge(int v,int w) { adj[v].add(w); }\n\n    // A recursive function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[],\n                             Stack stack)\n    {\n        // Mark the current node as visited.\n        visited[v] = true;\n        Integer i;\n\n        // Recur for all the vertices adjacent to this\n        // vertex\n        Iterator<Integer> it = adj[v].iterator();\n        while (it.hasNext())\n        {\n            i = it.next();\n            if (!visited[i])\n                topologicalSortUtil(i, visited, stack);\n        }\n\n        // Push current vertex to stack which stores result\n        stack.push(new Integer(v));\n    }\n\n    // The function to do Topological Sort. It uses\n    // recursive topologicalSortUtil()\n    void topologicalSort()\n    {\n        Stack stack = new Stack();\n\n        // Mark all the vertices as not visited\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        // Call the recursive helper function to store\n        // Topological Sort starting from all vertices\n        // one by one\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                topologicalSortUtil(i, visited, stack);\n\n        // Print contents of stack\n        while (stack.empty()==false)\n            System.out.print(stack.pop() + \" \");\n    }\n\n    public static void main(String args[])\n    {\n        // Create a graph given in the above diagram\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n\n        System.out.println(\"Following is a Topological \" +\n                           \"sort of the given graph\");\n        g.topologicalSort();\n    }\n}\n```","source":"_posts/Algorithm/Data-Structure/topological-sort.md","raw":"---\ntitle: 求图的拓扑排序\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - graph\n  - topological-sort\n---\n\n## 简介\n\n[**拓扑排序** （Topological Sorting）](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)\n\n> 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。\n> 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。\n>\n> 1. 每个顶点出现且只出现一次；\n> 2. 若A在序列中排在B的前面，则在图中不存在从B到A的边。\n>\n> 也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n## 问题描述\n\n一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 <i, j> 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（*Activity on Vertex*），记作 **AOV网络**。\n\n在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。\n\n一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫**拓扑排序**。\n\n例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。\n![img](https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg)\n\n## 算法思路\n\n1. 在AOV网络中选一个没有直接前驱的顶点v，并输出\n2. 从图中删除该顶点，同时删去所有从顶点v发出的弧\n3. 重复步骤1,2. 直到没有直接前驱的顶点全部输出\n\n## 算法步骤\n\n用二维list链表存储图的领接表\n\n1. 建立入度为0的顶点栈\n2. 当入度为0的顶点栈为空时，转到步骤6，否则步骤3\n3. 从入度为0的顶点栈顶元素v出栈，并输出顶点v\n4. 从AOV网络删去顶点v和所有顶点v发出的弧 <v, j>， 并将顶点 j 的入度 -1\n5. 如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2\n6. 如果输出顶点个数 < AOV网络顶点数，则图中存在有向环\n\n\n\n## 复杂度分析\n\nTopological Sorting via Depth First Search(DFS)\n在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。\n\n在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。\n\n因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。\n\n\n\n## 代码实现\n\n### C++ \n\n```cpp\n#include<iostream>\n#include <list>\n#include <stack>\nusing namespace std;\n\n// Class to represent a graph\nclass Graph\n{\n    int V;    // No. of vertices'\n\n    // Pointer to an array containing adjacency listsList\n    list<int> *adj;\n\n    // A function used by topologicalSort\n    void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\npublic:\n    Graph(int V);   // Constructor\n\n     // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // prints a Topological Sort of the complete graph\n    void topologicalSort();\n};\n\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v’s list.\n}\n\n// A recursive function used by topologicalSort\nvoid Graph::topologicalSortUtil(int v, bool visited[], \n                                stack<int> &Stack)\n{\n    // Mark the current node as visited.\n    visited[v] = true;\n\n    // Recur for all the vertices adjacent to this vertex\n    list<int>::iterator i;\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\n        if (!visited[*i])\n            topologicalSortUtil(*i, visited, Stack);\n\n    // Push current vertex to stack which stores result\n    Stack.push(v);\n}\n\n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil()\nvoid Graph::topologicalSort()\n{\n    stack<int> Stack;\n\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    // Call the recursive helper function to store Topological\n    // Sort starting from all vertices one by one\n    for (int i = 0; i < V; i++)\n      if (visited[i] == false)\n        topologicalSortUtil(i, visited, Stack);\n\n    // Print contents of stack\n    while (Stack.empty() == false)\n    {\n        cout << Stack.top() << \" \";\n        Stack.pop();\n    }\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"Following is a Topological Sort of the given graph n\";\n    g.topologicalSort();\n\n    return 0;\n}\n```\n\n### Java \n\n```java\nimport java.io.*;\nimport java.util.*;\n\n// This class represents a directed graph using adjacency\n// list representation\nclass Graph\n{\n    private int V;   // No. of vertices\n    private LinkedList<Integer> adj[]; // Adjacency List\n\n    //Constructor\n    Graph(int v)\n    {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i=0; i<v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    // Function to add an edge into the graph\n    void addEdge(int v,int w) { adj[v].add(w); }\n\n    // A recursive function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[],\n                             Stack stack)\n    {\n        // Mark the current node as visited.\n        visited[v] = true;\n        Integer i;\n\n        // Recur for all the vertices adjacent to this\n        // vertex\n        Iterator<Integer> it = adj[v].iterator();\n        while (it.hasNext())\n        {\n            i = it.next();\n            if (!visited[i])\n                topologicalSortUtil(i, visited, stack);\n        }\n\n        // Push current vertex to stack which stores result\n        stack.push(new Integer(v));\n    }\n\n    // The function to do Topological Sort. It uses\n    // recursive topologicalSortUtil()\n    void topologicalSort()\n    {\n        Stack stack = new Stack();\n\n        // Mark all the vertices as not visited\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        // Call the recursive helper function to store\n        // Topological Sort starting from all vertices\n        // one by one\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                topologicalSortUtil(i, visited, stack);\n\n        // Print contents of stack\n        while (stack.empty()==false)\n            System.out.print(stack.pop() + \" \");\n    }\n\n    public static void main(String args[])\n    {\n        // Create a graph given in the above diagram\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n\n        System.out.println(\"Following is a Topological \" +\n                           \"sort of the given graph\");\n        g.topologicalSort();\n    }\n}\n```","slug":"Algorithm/Data-Structure/topological-sort","published":1,"date":"2019-11-11T07:59:20.429Z","updated":"2019-11-29T02:58:16.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdt003glon9xsfl44k0","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\"><strong>拓扑排序</strong> （Topological Sorting）</a></p>\n<blockquote>\n<p>在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。<br>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。</p>\n<ol>\n<li>每个顶点出现且只出现一次；</li>\n<li>若A在序列中排在B的前面，则在图中不存在从B到A的边。</li>\n</ol>\n<p>也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 &lt;i, j&gt; 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（<em>Activity on Vertex</em>），记作 <strong>AOV网络</strong>。</p>\n<p>在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。</p>\n<p>一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫<strong>拓扑排序</strong>。</p>\n<p>例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。<br><img src=\"https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg\" alt=\"img\"></p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>在AOV网络中选一个没有直接前驱的顶点v，并输出</li>\n<li>从图中删除该顶点，同时删去所有从顶点v发出的弧</li>\n<li>重复步骤1,2. 直到没有直接前驱的顶点全部输出</li>\n</ol>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><p>用二维list链表存储图的领接表</p>\n<ol>\n<li>建立入度为0的顶点栈</li>\n<li>当入度为0的顶点栈为空时，转到步骤6，否则步骤3</li>\n<li>从入度为0的顶点栈顶元素v出栈，并输出顶点v</li>\n<li>从AOV网络删去顶点v和所有顶点v发出的弧 &lt;v, j&gt;， 并将顶点 j 的入度 -1</li>\n<li>如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2</li>\n<li>如果输出顶点个数 &lt; AOV网络顶点数，则图中存在有向环</li>\n</ol>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><p>Topological Sorting via Depth First Search(DFS)<br>在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。</p>\n<p>在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。</p>\n<p>因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class to represent a graph</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency listsList</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prints a Topological Sort of the complete graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v’s list.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSortUtil(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], </span><br><span class=\"line\">                                <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">    visited[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recur for all the vertices adjacent to this vertex</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = adj[v].begin(); i != adj[v].end(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[*i])</span><br><span class=\"line\">            topologicalSortUtil(*i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">    Stack.push(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The function to do Topological Sort. It uses recursive </span></span><br><span class=\"line\"><span class=\"comment\">// topologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; Stack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the recursive helper function to store Topological</span></span><br><span class=\"line\">    <span class=\"comment\">// Sort starting from all vertices one by one</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        topologicalSortUtil(i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Stack.empty() == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Stack.top() &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        Stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Following is a Topological Sort of the given graph n\"</span>;</span><br><span class=\"line\">    g.topologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This class represents a directed graph using adjacency</span></span><br><span class=\"line\"><span class=\"comment\">// list representation</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> V;   <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Integer&gt; adj[]; <span class=\"comment\">// Adjacency List</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Constructor</span></span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        V = v;</span><br><span class=\"line\">        adj = <span class=\"keyword\">new</span> LinkedList[v];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;v; ++i)</span><br><span class=\"line\">            adj[i] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Function to add an edge into the graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> w)</span> </span>&#123; adj[v].add(w); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">boolean</span> visited[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             Stack stack)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">        visited[v] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        Integer i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Recur for all the vertices adjacent to this</span></span><br><span class=\"line\">        <span class=\"comment\">// vertex</span></span><br><span class=\"line\">        Iterator&lt;Integer&gt; it = adj[v].iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i = it.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[i])</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">        stack.push(<span class=\"keyword\">new</span> Integer(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The function to do Topological Sort. It uses</span></span><br><span class=\"line\">    <span class=\"comment\">// recursive topologicalSortUtil()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Stack stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> visited[] = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[V];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            visited[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Call the recursive helper function to store</span></span><br><span class=\"line\">        <span class=\"comment\">// Topological Sort starting from all vertices</span></span><br><span class=\"line\">        <span class=\"comment\">// one by one</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i] == <span class=\"keyword\">false</span>)</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stack.empty()==<span class=\"keyword\">false</span>)</span><br><span class=\"line\">            System.out.print(stack.pop() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">        Graph g = <span class=\"keyword\">new</span> Graph(<span class=\"number\">6</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Following is a Topological \"</span> +</span><br><span class=\"line\">                           <span class=\"string\">\"sort of the given graph\"</span>);</span><br><span class=\"line\">        g.topologicalSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\"><strong>拓扑排序</strong> （Topological Sorting）</a></p>\n<blockquote>\n<p>在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。<br>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。</p>\n<ol>\n<li>每个顶点出现且只出现一次；</li>\n<li>若A在序列中排在B的前面，则在图中不存在从B到A的边。</li>\n</ol>\n<p>也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 &lt;i, j&gt; 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（<em>Activity on Vertex</em>），记作 <strong>AOV网络</strong>。</p>\n<p>在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。</p>\n<p>一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫<strong>拓扑排序</strong>。</p>\n<p>例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。<br><img src=\"https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg\" alt=\"img\"></p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>在AOV网络中选一个没有直接前驱的顶点v，并输出</li>\n<li>从图中删除该顶点，同时删去所有从顶点v发出的弧</li>\n<li>重复步骤1,2. 直到没有直接前驱的顶点全部输出</li>\n</ol>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><p>用二维list链表存储图的领接表</p>\n<ol>\n<li>建立入度为0的顶点栈</li>\n<li>当入度为0的顶点栈为空时，转到步骤6，否则步骤3</li>\n<li>从入度为0的顶点栈顶元素v出栈，并输出顶点v</li>\n<li>从AOV网络删去顶点v和所有顶点v发出的弧 &lt;v, j&gt;， 并将顶点 j 的入度 -1</li>\n<li>如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2</li>\n<li>如果输出顶点个数 &lt; AOV网络顶点数，则图中存在有向环</li>\n</ol>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><p>Topological Sorting via Depth First Search(DFS)<br>在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。</p>\n<p>在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。</p>\n<p>因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class to represent a graph</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency listsList</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prints a Topological Sort of the complete graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v’s list.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSortUtil(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], </span><br><span class=\"line\">                                <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">    visited[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recur for all the vertices adjacent to this vertex</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = adj[v].begin(); i != adj[v].end(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[*i])</span><br><span class=\"line\">            topologicalSortUtil(*i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">    Stack.push(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The function to do Topological Sort. It uses recursive </span></span><br><span class=\"line\"><span class=\"comment\">// topologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; Stack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the recursive helper function to store Topological</span></span><br><span class=\"line\">    <span class=\"comment\">// Sort starting from all vertices one by one</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        topologicalSortUtil(i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Stack.empty() == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Stack.top() &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        Stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Following is a Topological Sort of the given graph n\"</span>;</span><br><span class=\"line\">    g.topologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This class represents a directed graph using adjacency</span></span><br><span class=\"line\"><span class=\"comment\">// list representation</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> V;   <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Integer&gt; adj[]; <span class=\"comment\">// Adjacency List</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Constructor</span></span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        V = v;</span><br><span class=\"line\">        adj = <span class=\"keyword\">new</span> LinkedList[v];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;v; ++i)</span><br><span class=\"line\">            adj[i] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Function to add an edge into the graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> w)</span> </span>&#123; adj[v].add(w); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">boolean</span> visited[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             Stack stack)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">        visited[v] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        Integer i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Recur for all the vertices adjacent to this</span></span><br><span class=\"line\">        <span class=\"comment\">// vertex</span></span><br><span class=\"line\">        Iterator&lt;Integer&gt; it = adj[v].iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i = it.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[i])</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">        stack.push(<span class=\"keyword\">new</span> Integer(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The function to do Topological Sort. It uses</span></span><br><span class=\"line\">    <span class=\"comment\">// recursive topologicalSortUtil()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Stack stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> visited[] = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[V];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            visited[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Call the recursive helper function to store</span></span><br><span class=\"line\">        <span class=\"comment\">// Topological Sort starting from all vertices</span></span><br><span class=\"line\">        <span class=\"comment\">// one by one</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i] == <span class=\"keyword\">false</span>)</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stack.empty()==<span class=\"keyword\">false</span>)</span><br><span class=\"line\">            System.out.print(stack.pop() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">        Graph g = <span class=\"keyword\">new</span> Graph(<span class=\"number\">6</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Following is a Topological \"</span> +</span><br><span class=\"line\">                           <span class=\"string\">\"sort of the given graph\"</span>);</span><br><span class=\"line\">        g.topologicalSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java容器——ArrayList扩容源码分析","_content":"\n## 一 先从 ArrayList 的构造函数说起\n\n**ArrayList有三种方式来初始化，构造方法源码如下：**\n\n```java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    \n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。 \n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n```\n\n细心的同学一定会发现 ：**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\n\n## 二 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n### 1. 先来看 `add` 方法\n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n### 2. 再来看看 `ensureCapacityInternal()` 方法\n\n可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n**当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。**\n\n### 3. `ensureExplicitCapacity()` 方法 \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为10。此时，`minCapacity - elementData.length > 0 `成立，所以会进入 `grow(minCapacity)` 方法。\n- 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0 ` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。\n\n直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\n\n### 4. `grow()` 方法 \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）**  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码\n\n>   \">>\"（移位运算符）：>>1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　\n\n**我们再来通过例子探究一下`grow()` 方法 ：**\n\n- 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 `hugeCapacity` 方法。数组容量为10，add方法中 return true,size增为1。\n- 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- java 中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 5. `hugeCapacity()` 方法。\n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 \n\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n\n\n## 三 `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n\n### 3.1 `System.arraycopy()` 方法\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = new int[10];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\ta[3] = 3;\n\t\tSystem.arraycopy(a, 2, a, 3, 3);\n\t\ta[2]=99;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\n}\n```\n\n结果：\n\n```\n0 1 99 2 3 0 0 0 0 0 \n```\n\n### 3.2 `Arrays.copyOf()`方法\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[3];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\tint[] b = Arrays.copyOf(a, 10);\n\t\tSystem.out.println(\"b.length\"+b.length);\n\t}\n}\n```\n\n结果：\n\n```\n10\n```\n\n\n### 3.3 两者联系和区别\n\n**联系：** \n\n看两者源代码可以发现 copyOf() 内部实际调用了 `System.arraycopy()` 方法 \n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n\n\n## 四 `ensureCapacity`方法\n\nArrayList 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n\t\tlist = new ArrayList<Object>();\n\t\tlong startTime1 = System.currentTimeMillis();\n\t\tlist.ensureCapacity(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime1 = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n\t}\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法前：4637\n使用ensureCapacity方法后：241\n\n```\n\n通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数\n","source":"_posts/Java/Collection-Framework/ArrayList-Grow.md","raw":"---\ntitle: Java容器——ArrayList扩容源码分析\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n  - array-list\n---\n\n## 一 先从 ArrayList 的构造函数说起\n\n**ArrayList有三种方式来初始化，构造方法源码如下：**\n\n```java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    \n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。 \n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n```\n\n细心的同学一定会发现 ：**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\n\n## 二 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n### 1. 先来看 `add` 方法\n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n### 2. 再来看看 `ensureCapacityInternal()` 方法\n\n可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n**当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。**\n\n### 3. `ensureExplicitCapacity()` 方法 \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为10。此时，`minCapacity - elementData.length > 0 `成立，所以会进入 `grow(minCapacity)` 方法。\n- 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0 ` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。\n\n直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\n\n### 4. `grow()` 方法 \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）**  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码\n\n>   \">>\"（移位运算符）：>>1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　\n\n**我们再来通过例子探究一下`grow()` 方法 ：**\n\n- 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 `hugeCapacity` 方法。数组容量为10，add方法中 return true,size增为1。\n- 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- java 中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 5. `hugeCapacity()` 方法。\n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 \n\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n\n\n## 三 `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n\n### 3.1 `System.arraycopy()` 方法\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = new int[10];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\ta[3] = 3;\n\t\tSystem.arraycopy(a, 2, a, 3, 3);\n\t\ta[2]=99;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\n}\n```\n\n结果：\n\n```\n0 1 99 2 3 0 0 0 0 0 \n```\n\n### 3.2 `Arrays.copyOf()`方法\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[3];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\tint[] b = Arrays.copyOf(a, 10);\n\t\tSystem.out.println(\"b.length\"+b.length);\n\t}\n}\n```\n\n结果：\n\n```\n10\n```\n\n\n### 3.3 两者联系和区别\n\n**联系：** \n\n看两者源代码可以发现 copyOf() 内部实际调用了 `System.arraycopy()` 方法 \n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n\n\n## 四 `ensureCapacity`方法\n\nArrayList 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n\t\tlist = new ArrayList<Object>();\n\t\tlong startTime1 = System.currentTimeMillis();\n\t\tlist.ensureCapacity(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime1 = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n\t}\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法前：4637\n使用ensureCapacity方法后：241\n\n```\n\n通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数\n","slug":"Java/Collection-Framework/ArrayList-Grow","published":1,"date":"2019-11-11T07:59:20.460Z","updated":"2019-11-11T07:59:20.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdu003ilon961a7nj0k","content":"<h2 id=\"一-先从-ArrayList-的构造函数说起\"><a href=\"#一-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"一 先从 ArrayList 的构造函数说起\"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<h2 id=\"二-一步一步分析-ArrayList-扩容机制\"><a href=\"#二-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"二 一步一步分析 ArrayList 扩容机制\"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h3 id=\"1-先来看-add-方法\"><a href=\"#1-先来看-add-方法\" class=\"headerlink\" title=\"1. 先来看 add 方法\"></a>1. 先来看 <code>add</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-再来看看-ensureCapacityInternal-方法\"><a href=\"#2-再来看看-ensureCapacityInternal-方法\" class=\"headerlink\" title=\"2. 再来看看 ensureCapacityInternal() 方法\"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p>\n<h3 id=\"3-ensureExplicitCapacity-方法\"><a href=\"#3-ensureExplicitCapacity-方法\" class=\"headerlink\" title=\"3. ensureExplicitCapacity() 方法\"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li>\n</ul>\n<p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p>\n<h3 id=\"4-grow-方法\"><a href=\"#4-grow-方法\" class=\"headerlink\" title=\"4. grow() 方法\"></a>4. <code>grow()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）</strong>  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码</p>\n<blockquote>\n<p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"5-hugeCapacity-方法。\"><a href=\"#5-hugeCapacity-方法。\" class=\"headerlink\" title=\"5. hugeCapacity() 方法。\"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#三-System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"三 System.arraycopy() 和 Arrays.copyOf()方法\"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h3 id=\"3-1-System-arraycopy-方法\"><a href=\"#3-1-System-arraycopy-方法\" class=\"headerlink\" title=\"3.1 System.arraycopy() 方法\"></a>3.1 <code>System.arraycopy()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArraycopyTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tSystem.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Arrays-copyOf-方法\"><a href=\"#3-2-Arrays-copyOf-方法\" class=\"headerlink\" title=\"3.2 Arrays.copyOf()方法\"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayscopyOfTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"b.length\"</span>+b.length);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-两者联系和区别\"><a href=\"#3-3-两者联系和区别\" class=\"headerlink\" title=\"3.3 两者联系和区别\"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法 </p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h2 id=\"四-ensureCapacity方法\"><a href=\"#四-ensureCapacity方法\" class=\"headerlink\" title=\"四 ensureCapacity方法\"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnsureCapacityTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">10000000</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法前：\"</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tlist.ensureCapacity(N);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法后：\"</span>+(endTime1 - startTime1));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：4637</span><br><span class=\"line\">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure>\n<p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-先从-ArrayList-的构造函数说起\"><a href=\"#一-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"一 先从 ArrayList 的构造函数说起\"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<h2 id=\"二-一步一步分析-ArrayList-扩容机制\"><a href=\"#二-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"二 一步一步分析 ArrayList 扩容机制\"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h3 id=\"1-先来看-add-方法\"><a href=\"#1-先来看-add-方法\" class=\"headerlink\" title=\"1. 先来看 add 方法\"></a>1. 先来看 <code>add</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-再来看看-ensureCapacityInternal-方法\"><a href=\"#2-再来看看-ensureCapacityInternal-方法\" class=\"headerlink\" title=\"2. 再来看看 ensureCapacityInternal() 方法\"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p>\n<h3 id=\"3-ensureExplicitCapacity-方法\"><a href=\"#3-ensureExplicitCapacity-方法\" class=\"headerlink\" title=\"3. ensureExplicitCapacity() 方法\"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li>\n</ul>\n<p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p>\n<h3 id=\"4-grow-方法\"><a href=\"#4-grow-方法\" class=\"headerlink\" title=\"4. grow() 方法\"></a>4. <code>grow()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）</strong>  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码</p>\n<blockquote>\n<p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"5-hugeCapacity-方法。\"><a href=\"#5-hugeCapacity-方法。\" class=\"headerlink\" title=\"5. hugeCapacity() 方法。\"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#三-System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"三 System.arraycopy() 和 Arrays.copyOf()方法\"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h3 id=\"3-1-System-arraycopy-方法\"><a href=\"#3-1-System-arraycopy-方法\" class=\"headerlink\" title=\"3.1 System.arraycopy() 方法\"></a>3.1 <code>System.arraycopy()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArraycopyTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tSystem.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Arrays-copyOf-方法\"><a href=\"#3-2-Arrays-copyOf-方法\" class=\"headerlink\" title=\"3.2 Arrays.copyOf()方法\"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayscopyOfTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"b.length\"</span>+b.length);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-两者联系和区别\"><a href=\"#3-3-两者联系和区别\" class=\"headerlink\" title=\"3.3 两者联系和区别\"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法 </p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h2 id=\"四-ensureCapacity方法\"><a href=\"#四-ensureCapacity方法\" class=\"headerlink\" title=\"四 ensureCapacity方法\"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnsureCapacityTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">10000000</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法前：\"</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tlist.ensureCapacity(N);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法后：\"</span>+(endTime1 - startTime1));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：4637</span><br><span class=\"line\">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure>\n<p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n"},{"title":"Java常见问题汇总-1","_content":"## 一 为什么 Java 中只有值传递？\n\n\n首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\n\n**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**\n\n**下面通过 3 个例子来给大家说明**\n\n### example 1 \n\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果：**\n\n```\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析：**\n\n![example 1 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\n\n### example 2\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(arr[0]);\n\t\tchange(arr);\n\t\tSystem.out.println(arr[0]);\n\t}\n\n\tpublic static void change(int[] array) {\n\t\t// 将数组的第一个元素变为0\n\t\tarray[0] = 0;\n\t}\n```\n\n**结果：**\n\n```\n1\n0\n```\n\n**解析：**\n\n![example 2](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\n**很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。**\n\n\n### example 3\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student(\"小张\");\n\t\tStudent s2 = new Student(\"小李\");\n\t\tTest.swap(s1, s2);\n\t\tSystem.out.println(\"s1:\" + s1.getName());\n\t\tSystem.out.println(\"s2:\" + s2.getName());\n\t}\n\n\tpublic static void swap(Student x, Student y) {\n\t\tStudent temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t\tSystem.out.println(\"x:\" + x.getName());\n\t\tSystem.out.println(\"y:\" + y.getName());\n\t}\n}\n```\n\n**结果：**\n\n```\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析：**\n\n交换之前：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg)\n\n交换之后：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg)\n\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n### 总结\n\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。\n\n下面再总结一下Java中方法参数的使用情况：\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n\n### 参考：\n\n《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节\n\n## 二  ==与equals(重要)\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n-  情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。\n- 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。\n\n\n**举个例子：**\n\n```java\npublic class test1 {\n    public static void main(String[] args) {\n        String a = new String(\"ab\"); // a 为一个引用\n        String b = new String(\"ab\"); // b为另一个引用,对象的内容一样\n        String aa = \"ab\"; // 放在常量池中\n        String bb = \"ab\"; // 从常量池中查找\n        if (aa == bb) // true\n            System.out.println(\"aa==bb\");\n        if (a == b) // false，非同一对象\n            System.out.println(\"a==b\");\n        if (a.equals(b)) // true\n            System.out.println(\"aEQb\");\n        if (42 == 42.0) { // true\n            System.out.println(\"true\");\n        }\n    }\n}\n```\n\n**说明：**\n\n- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。\n- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。\n\n\n\n## 三  hashCode与equals（重要）\n\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\n\n### hashCode（）介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。\n\n```java\n    /**\n     * Returns a hash code value for the object. This method is\n     * supported for the benefit of hash tables such as those provided by\n     * {@link java.util.HashMap}.\n     * <p>\n     * As much as is reasonably practical, the hashCode method defined by\n     * class {@code Object} does return distinct integers for distinct\n     * objects. (This is typically implemented by converting the internal\n     * address of the object into an integer, but this implementation\n     * technique is not required by the\n     * Java&trade; programming language.)\n     *\n     * @return  a hash code value for this object.\n     * @see     java.lang.Object#equals(java.lang.Object)\n     * @see     java.lang.System#identityHashCode\n     */\n    public native int hashCode();\n```\n\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n### 为什么要有hashCode\n\n\n**我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：**\n\n当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。\n\n\n\n### hashCode（）与equals（）的相关规定\n\n1. 如果两个对象相等，则hashcode一定也是相同的\n2. 两个对象相等,对两个对象分别调用equals方法都返回true\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\n4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**\n5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n### 为什么两个对象有相同的hashcode值，它们也不一定是相等的？\n\n在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。\n\n因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 \n\n我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。\n\n参考：\n\n[https://blog.csdn.net/zhzhao999/article/details/53449504](https://blog.csdn.net/zhzhao999/article/details/53449504)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/Eason-S/p/5524837.html](https://www.cnblogs.com/Eason-S/p/5524837.html)\n\n","source":"_posts/Java/Summary/common-questions.md","raw":"---\ntitle: Java常见问题汇总-1\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n## 一 为什么 Java 中只有值传递？\n\n\n首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\n\n**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**\n\n**下面通过 3 个例子来给大家说明**\n\n### example 1 \n\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果：**\n\n```\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析：**\n\n![example 1 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\n\n### example 2\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(arr[0]);\n\t\tchange(arr);\n\t\tSystem.out.println(arr[0]);\n\t}\n\n\tpublic static void change(int[] array) {\n\t\t// 将数组的第一个元素变为0\n\t\tarray[0] = 0;\n\t}\n```\n\n**结果：**\n\n```\n1\n0\n```\n\n**解析：**\n\n![example 2](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\n**很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。**\n\n\n### example 3\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student(\"小张\");\n\t\tStudent s2 = new Student(\"小李\");\n\t\tTest.swap(s1, s2);\n\t\tSystem.out.println(\"s1:\" + s1.getName());\n\t\tSystem.out.println(\"s2:\" + s2.getName());\n\t}\n\n\tpublic static void swap(Student x, Student y) {\n\t\tStudent temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t\tSystem.out.println(\"x:\" + x.getName());\n\t\tSystem.out.println(\"y:\" + y.getName());\n\t}\n}\n```\n\n**结果：**\n\n```\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析：**\n\n交换之前：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg)\n\n交换之后：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg)\n\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n### 总结\n\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。\n\n下面再总结一下Java中方法参数的使用情况：\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n\n### 参考：\n\n《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节\n\n## 二  ==与equals(重要)\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n-  情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。\n- 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。\n\n\n**举个例子：**\n\n```java\npublic class test1 {\n    public static void main(String[] args) {\n        String a = new String(\"ab\"); // a 为一个引用\n        String b = new String(\"ab\"); // b为另一个引用,对象的内容一样\n        String aa = \"ab\"; // 放在常量池中\n        String bb = \"ab\"; // 从常量池中查找\n        if (aa == bb) // true\n            System.out.println(\"aa==bb\");\n        if (a == b) // false，非同一对象\n            System.out.println(\"a==b\");\n        if (a.equals(b)) // true\n            System.out.println(\"aEQb\");\n        if (42 == 42.0) { // true\n            System.out.println(\"true\");\n        }\n    }\n}\n```\n\n**说明：**\n\n- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。\n- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。\n\n\n\n## 三  hashCode与equals（重要）\n\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\n\n### hashCode（）介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。\n\n```java\n    /**\n     * Returns a hash code value for the object. This method is\n     * supported for the benefit of hash tables such as those provided by\n     * {@link java.util.HashMap}.\n     * <p>\n     * As much as is reasonably practical, the hashCode method defined by\n     * class {@code Object} does return distinct integers for distinct\n     * objects. (This is typically implemented by converting the internal\n     * address of the object into an integer, but this implementation\n     * technique is not required by the\n     * Java&trade; programming language.)\n     *\n     * @return  a hash code value for this object.\n     * @see     java.lang.Object#equals(java.lang.Object)\n     * @see     java.lang.System#identityHashCode\n     */\n    public native int hashCode();\n```\n\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n### 为什么要有hashCode\n\n\n**我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：**\n\n当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。\n\n\n\n### hashCode（）与equals（）的相关规定\n\n1. 如果两个对象相等，则hashcode一定也是相同的\n2. 两个对象相等,对两个对象分别调用equals方法都返回true\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\n4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**\n5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n### 为什么两个对象有相同的hashcode值，它们也不一定是相等的？\n\n在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。\n\n因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 \n\n我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。\n\n参考：\n\n[https://blog.csdn.net/zhzhao999/article/details/53449504](https://blog.csdn.net/zhzhao999/article/details/53449504)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/Eason-S/p/5524837.html](https://www.cnblogs.com/Eason-S/p/5524837.html)\n\n","slug":"Java/Summary/common-questions","published":1,"date":"2019-11-11T07:59:20.462Z","updated":"2019-11-11T07:59:20.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdv003klon9w39ijja9","content":"<h2 id=\"一-为什么-Java-中只有值传递？\"><a href=\"#一-为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"一 为什么 Java 中只有值传递？\"></a>一 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>\n<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>\n<p><strong>下面通过 3 个例子来给大家说明</strong></p>\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example 1\"></a>example 1</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num1 = \"</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num2 = \"</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"a = \"</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"b = \"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 10</span><br><span class=\"line\">num1 = 10</span><br><span class=\"line\">num2 = 20</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg\" alt=\"example 1 \"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example 2\"></a>example 2</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tchange(arr);</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">\tarray[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg\" alt=\"example 2\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example 3\"></a>example 3</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tStudent s1 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小张\"</span>);</span><br><span class=\"line\">\t\tStudent s2 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">\t\tTest.swap(s1, s2);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s1:\"</span> + s1.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s2:\"</span> + s2.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Student x, Student y)</span> </span>&#123;</span><br><span class=\"line\">\t\tStudent temp = x;</span><br><span class=\"line\">\t\tx = y;</span><br><span class=\"line\">\t\ty = temp;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"x:\"</span> + x.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"y:\"</span> + y.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p>交换之前：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg\" alt></p>\n<p>交换之后：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg\" alt></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>\n<p>下面再总结一下Java中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>\n<h2 id=\"二-与equals-重要\"><a href=\"#二-与equals-重要\" class=\"headerlink\" title=\"二  ==与equals(重要)\"></a>二  ==与equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<ul>\n<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>\n<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// a 为一个引用</span></span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// b为另一个引用,对象的内容一样</span></span><br><span class=\"line\">        String aa = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 放在常量池中</span></span><br><span class=\"line\">        String bb = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 从常量池中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aa == bb) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aa==bb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a == b) <span class=\"comment\">// false，非同一对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"a==b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.equals(b)) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aEQb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">42</span> == <span class=\"number\">42.0</span>) &#123; <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong></p>\n<ul>\n<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>\n<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>\n</ul>\n<h2 id=\"三-hashCode与equals（重要）\"><a href=\"#三-hashCode与equals（重要）\" class=\"headerlink\" title=\"三  hashCode与equals（重要）\"></a>三  hashCode与equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>\n<h3 id=\"hashCode（）介绍\"><a href=\"#hashCode（）介绍\" class=\"headerlink\" title=\"hashCode（）介绍\"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code value for the object. This method is</span></span><br><span class=\"line\"><span class=\"comment\"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> java.util.HashMap&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class=\"line\"><span class=\"comment\"> * class &#123;<span class=\"doctag\">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class=\"line\"><span class=\"comment\"> * objects. (This is typically implemented by converting the internal</span></span><br><span class=\"line\"><span class=\"comment\"> * address of the object into an integer, but this implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * technique is not required by the</span></span><br><span class=\"line\"><span class=\"comment\"> * Java&amp;trade; programming language.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.System#identityHashCode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<h3 id=\"为什么要有hashCode\"><a href=\"#为什么要有hashCode\" class=\"headerlink\" title=\"为什么要有hashCode\"></a>为什么要有hashCode</h3><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>\n<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>\n<h3 id=\"hashCode（）与equals（）的相关规定\"><a href=\"#hashCode（）与equals（）的相关规定\" class=\"headerlink\" title=\"hashCode（）与equals（）的相关规定\"></a>hashCode（）与equals（）的相关规定</h3><ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>\n</ol>\n<h3 id=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"><a href=\"#为什么两个对象有相同的hashcode值，它们也不一定是相等的？\" class=\"headerlink\" title=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>\n<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>\n<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/zhzhao999/article/details/53449504\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/Eason-S/p/5524837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-为什么-Java-中只有值传递？\"><a href=\"#一-为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"一 为什么 Java 中只有值传递？\"></a>一 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>\n<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>\n<p><strong>下面通过 3 个例子来给大家说明</strong></p>\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example 1\"></a>example 1</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num1 = \"</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num2 = \"</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"a = \"</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"b = \"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 10</span><br><span class=\"line\">num1 = 10</span><br><span class=\"line\">num2 = 20</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg\" alt=\"example 1 \"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example 2\"></a>example 2</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tchange(arr);</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">\tarray[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg\" alt=\"example 2\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example 3\"></a>example 3</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tStudent s1 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小张\"</span>);</span><br><span class=\"line\">\t\tStudent s2 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">\t\tTest.swap(s1, s2);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s1:\"</span> + s1.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s2:\"</span> + s2.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Student x, Student y)</span> </span>&#123;</span><br><span class=\"line\">\t\tStudent temp = x;</span><br><span class=\"line\">\t\tx = y;</span><br><span class=\"line\">\t\ty = temp;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"x:\"</span> + x.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"y:\"</span> + y.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p>交换之前：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg\" alt></p>\n<p>交换之后：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg\" alt></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>\n<p>下面再总结一下Java中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>\n<h2 id=\"二-与equals-重要\"><a href=\"#二-与equals-重要\" class=\"headerlink\" title=\"二  ==与equals(重要)\"></a>二  ==与equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<ul>\n<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>\n<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// a 为一个引用</span></span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// b为另一个引用,对象的内容一样</span></span><br><span class=\"line\">        String aa = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 放在常量池中</span></span><br><span class=\"line\">        String bb = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 从常量池中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aa == bb) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aa==bb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a == b) <span class=\"comment\">// false，非同一对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"a==b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.equals(b)) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aEQb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">42</span> == <span class=\"number\">42.0</span>) &#123; <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong></p>\n<ul>\n<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>\n<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>\n</ul>\n<h2 id=\"三-hashCode与equals（重要）\"><a href=\"#三-hashCode与equals（重要）\" class=\"headerlink\" title=\"三  hashCode与equals（重要）\"></a>三  hashCode与equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>\n<h3 id=\"hashCode（）介绍\"><a href=\"#hashCode（）介绍\" class=\"headerlink\" title=\"hashCode（）介绍\"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code value for the object. This method is</span></span><br><span class=\"line\"><span class=\"comment\"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> java.util.HashMap&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class=\"line\"><span class=\"comment\"> * class &#123;<span class=\"doctag\">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class=\"line\"><span class=\"comment\"> * objects. (This is typically implemented by converting the internal</span></span><br><span class=\"line\"><span class=\"comment\"> * address of the object into an integer, but this implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * technique is not required by the</span></span><br><span class=\"line\"><span class=\"comment\"> * Java&amp;trade; programming language.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.System#identityHashCode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<h3 id=\"为什么要有hashCode\"><a href=\"#为什么要有hashCode\" class=\"headerlink\" title=\"为什么要有hashCode\"></a>为什么要有hashCode</h3><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>\n<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>\n<h3 id=\"hashCode（）与equals（）的相关规定\"><a href=\"#hashCode（）与equals（）的相关规定\" class=\"headerlink\" title=\"hashCode（）与equals（）的相关规定\"></a>hashCode（）与equals（）的相关规定</h3><ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>\n</ol>\n<h3 id=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"><a href=\"#为什么两个对象有相同的hashcode值，它们也不一定是相等的？\" class=\"headerlink\" title=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>\n<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>\n<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/zhzhao999/article/details/53449504\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/Eason-S/p/5524837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>\n"},{"title":"问题梳理-Java多线程","_content":"\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","source":"_posts/Java/Concurrency/questiones-multithread-in-java.md","raw":"---\ntitle: 问题梳理-Java多线程\ncategories:\n  - Java\n  - Concurrency\ntags:\n  - multithread\n  - interview\n\n---\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","slug":"Java/Concurrency/questiones-multithread-in-java","published":1,"date":"2019-11-11T07:59:20.462Z","updated":"2019-11-11T07:59:20.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdw003olon94glqmp3m","content":"<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n"},{"title":"Java常见问题汇总-2","_content":"### String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\n\n####  String和StringBuffer、StringBuilder的区别\n\n**可变性**\n　\n\n简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\n\nStringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\n\nAbstractStringBuilder.java\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    int count;\n    AbstractStringBuilder() {\n    }\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n```\n\n\n**线程安全性**\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　\n\n**性能**\n\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：** \n1. 操作少量的数据 = String\n2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder\n3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer\n\n####  String为什么是不可变的吗？\n简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n####  String真的是不可变的吗？\n我觉得如果别人问这个问题的话，回答不可变就可以了。\n下面只是给大家看两个有代表性的例子：\n\n**1) String不可变但不代表引用不可以变**\n```java\n\t\tString str = \"Hello\";\n\t\tstr = str + \" World\";\n\t\tSystem.out.println(\"str=\" + str);\n```\n结果：\n```\nstr=Hello World\n```\n解析：\n\n实际上，原来String的内容是不变的，只是str由原来指向\"Hello\"的内存地址转为指向\"Hello World\"的内存地址而已，也就是说多开辟了一块内存区域给\"Hello World\"字符串。\n\n**2) 通过反射是可以修改所谓的“不可变”对象**\n\n```java\n\t\t// 创建字符串\"Hello World\"， 并赋给引用s\n\t\tString s = \"Hello World\";\n\n\t\tSystem.out.println(\"s = \" + s); // Hello World\n\n\t\t// 获取String类中的value字段\n\t\tField valueFieldOfString = String.class.getDeclaredField(\"value\");\n\n\t\t// 改变value属性的访问权限\n\t\tvalueFieldOfString.setAccessible(true);\n\n\t\t// 获取s对象上的value属性的值\n\t\tchar[] value = (char[]) valueFieldOfString.get(s);\n\n\t\t// 改变value所引用的数组中的第5个字符\n\t\tvalue[5] = '_';\n\n\t\tSystem.out.println(\"s = \" + s); // Hello_World\n```\n\n结果：\n\n```\ns = Hello World\ns = Hello_World\n```\n\n解析：\n\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n\n### 什么是反射机制？反射机制的应用场景有哪些？\n\n#### 反射机制介绍\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n#### 静态编译和动态编译\n\n- **静态编译：**在编译时确定类型，绑定对象\n- **动态编译：**运行时确定类型，绑定对象\n\n#### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。\n\n#### 反射的应用场景\n\n反射是框架设计的灵魂。\n\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;\n 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\n\n**推荐阅读：**\n\n- [Reflection：Java反射机制的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)\n- [Java基础之—反射（非常重要）](https://blog.csdn.net/sinat_38259539/article/details/71799078)\n### 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\n\n这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。\n\n**JDK:**  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。\n\n**JRE:** 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。\n\n**JVM：** 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。\n\n**区别与联系：**\n\n 1. JDK用于开发，JRE用于运行java程序 ；\n 2. JDK和JRE中都包含JVM ；\n 3. JVM是java编程语言的核心并且具有平台独立性。\n\n### 什么是字节码？采用字节码的最大好处是什么？\n\n**先看下java中的编译器和解释器：** 　　\n\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。\n\n Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。 \n\n**采用字节码的好处：** 　　\n\nJava语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n\n### Java和C++的区别\n\n我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java不提供指针来直接访问内存，程序内存更加安全\n-  Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n-   Java有自动内存管理机制，不需要程序员手动释放无用内存\n\n\n### 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法\n2.  接口中的实例变量默认是final类型的，而抽象类中则不一定 \n3.  一个类可以实现多个接口，但最多只能实现一个抽象类 \n4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定 \n5.  接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n\n注意：Java8 后接口可以有默认实现( default )。\n\n### 成员变量与局部变量的区别有那些？\n\n1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；\n2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存\n3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\n4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。\n\n### 重载和重写的区别\n\n**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　\n\n**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。\n\n### 字符型常量和字符串常量的区别\n1) 形式上:\n字符常量是单引号引起的一个字符 \n字符串常量是双引号引起的若干个字符\n2) 含义上:\n字符常量相当于一个整形值(ASCII值),可以参加表达式运算\n字符串常量代表一个地址值(该字符串在内存中存放位置)\n3) 占内存大小\n字符常量只占一个字节\n字符串常量占若干个字节(至少一个字符结束标志)\n","source":"_posts/Java/Summary/string.md","raw":"---\ntitle: Java常见问题汇总-2\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n### String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\n\n####  String和StringBuffer、StringBuilder的区别\n\n**可变性**\n　\n\n简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\n\nStringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\n\nAbstractStringBuilder.java\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    int count;\n    AbstractStringBuilder() {\n    }\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n```\n\n\n**线程安全性**\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　\n\n**性能**\n\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：** \n1. 操作少量的数据 = String\n2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder\n3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer\n\n####  String为什么是不可变的吗？\n简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n####  String真的是不可变的吗？\n我觉得如果别人问这个问题的话，回答不可变就可以了。\n下面只是给大家看两个有代表性的例子：\n\n**1) String不可变但不代表引用不可以变**\n```java\n\t\tString str = \"Hello\";\n\t\tstr = str + \" World\";\n\t\tSystem.out.println(\"str=\" + str);\n```\n结果：\n```\nstr=Hello World\n```\n解析：\n\n实际上，原来String的内容是不变的，只是str由原来指向\"Hello\"的内存地址转为指向\"Hello World\"的内存地址而已，也就是说多开辟了一块内存区域给\"Hello World\"字符串。\n\n**2) 通过反射是可以修改所谓的“不可变”对象**\n\n```java\n\t\t// 创建字符串\"Hello World\"， 并赋给引用s\n\t\tString s = \"Hello World\";\n\n\t\tSystem.out.println(\"s = \" + s); // Hello World\n\n\t\t// 获取String类中的value字段\n\t\tField valueFieldOfString = String.class.getDeclaredField(\"value\");\n\n\t\t// 改变value属性的访问权限\n\t\tvalueFieldOfString.setAccessible(true);\n\n\t\t// 获取s对象上的value属性的值\n\t\tchar[] value = (char[]) valueFieldOfString.get(s);\n\n\t\t// 改变value所引用的数组中的第5个字符\n\t\tvalue[5] = '_';\n\n\t\tSystem.out.println(\"s = \" + s); // Hello_World\n```\n\n结果：\n\n```\ns = Hello World\ns = Hello_World\n```\n\n解析：\n\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n\n### 什么是反射机制？反射机制的应用场景有哪些？\n\n#### 反射机制介绍\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n#### 静态编译和动态编译\n\n- **静态编译：**在编译时确定类型，绑定对象\n- **动态编译：**运行时确定类型，绑定对象\n\n#### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。\n\n#### 反射的应用场景\n\n反射是框架设计的灵魂。\n\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;\n 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\n\n**推荐阅读：**\n\n- [Reflection：Java反射机制的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)\n- [Java基础之—反射（非常重要）](https://blog.csdn.net/sinat_38259539/article/details/71799078)\n### 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\n\n这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。\n\n**JDK:**  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。\n\n**JRE:** 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。\n\n**JVM：** 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。\n\n**区别与联系：**\n\n 1. JDK用于开发，JRE用于运行java程序 ；\n 2. JDK和JRE中都包含JVM ；\n 3. JVM是java编程语言的核心并且具有平台独立性。\n\n### 什么是字节码？采用字节码的最大好处是什么？\n\n**先看下java中的编译器和解释器：** 　　\n\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。\n\n Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。 \n\n**采用字节码的好处：** 　　\n\nJava语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n\n### Java和C++的区别\n\n我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java不提供指针来直接访问内存，程序内存更加安全\n-  Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n-   Java有自动内存管理机制，不需要程序员手动释放无用内存\n\n\n### 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法\n2.  接口中的实例变量默认是final类型的，而抽象类中则不一定 \n3.  一个类可以实现多个接口，但最多只能实现一个抽象类 \n4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定 \n5.  接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n\n注意：Java8 后接口可以有默认实现( default )。\n\n### 成员变量与局部变量的区别有那些？\n\n1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；\n2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存\n3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\n4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。\n\n### 重载和重写的区别\n\n**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　\n\n**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。\n\n### 字符型常量和字符串常量的区别\n1) 形式上:\n字符常量是单引号引起的一个字符 \n字符串常量是双引号引起的若干个字符\n2) 含义上:\n字符常量相当于一个整形值(ASCII值),可以参加表达式运算\n字符串常量代表一个地址值(该字符串在内存中存放位置)\n3) 占内存大小\n字符常量只占一个字节\n字符串常量占若干个字节(至少一个字符结束标志)\n","slug":"Java/Summary/string","published":1,"date":"2019-11-11T07:59:20.463Z","updated":"2019-11-11T07:59:20.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdy003slon9rb4egxy7","content":"<h3 id=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"><a href=\"#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id=\"String和StringBuffer、StringBuilder的区别\"><a href=\"#String和StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别\"></a>String和StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong>\n　</p>\n<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>\n<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>\n<p>AbstractStringBuilder.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    AbstractStringBuilder() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AbstractStringBuilder(<span class=\"keyword\">int</span> capacity) &#123;</span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线程安全性</strong></p>\n<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　</p>\n<p><strong>性能</strong></p>\n<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong> </p>\n<ol>\n<li>操作少量的数据 = String</li>\n<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>\n<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>\n</ol>\n<h4 id=\"String为什么是不可变的吗？\"><a href=\"#String为什么是不可变的吗？\" class=\"headerlink\" title=\"String为什么是不可变的吗？\"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n<h4 id=\"String真的是不可变的吗？\"><a href=\"#String真的是不可变的吗？\" class=\"headerlink\" title=\"String真的是不可变的吗？\"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p>\n<p><strong>1) String不可变但不代表引用不可以变</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">str = str + <span class=\"string\">\" World\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=Hello World</span><br></pre></td></tr></table></figure></p>\n<p>解析：</p>\n<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>\n<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符串\"Hello World\"， 并赋给引用s</span></span><br><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取String类中的value字段</span></span><br><span class=\"line\">Field valueFieldOfString = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value属性的访问权限</span></span><br><span class=\"line\">valueFieldOfString.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取s对象上的value属性的值</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] value = (<span class=\"keyword\">char</span>[]) valueFieldOfString.get(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value所引用的数组中的第5个字符</span></span><br><span class=\"line\">value[<span class=\"number\">5</span>] = <span class=\"string\">'_'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello_World</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = Hello World</span><br><span class=\"line\">s = Hello_World</span><br></pre></td></tr></table></figure>\n<p>解析：</p>\n<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>\n<h3 id=\"什么是反射机制？反射机制的应用场景有哪些？\"><a href=\"#什么是反射机制？反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"什么是反射机制？反射机制的应用场景有哪些？\"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id=\"反射机制介绍\"><a href=\"#反射机制介绍\" class=\"headerlink\" title=\"反射机制介绍\"></a>反射机制介绍</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\n<h4 id=\"静态编译和动态编译\"><a href=\"#静态编译和动态编译\" class=\"headerlink\" title=\"静态编译和动态编译\"></a>静态编译和动态编译</h4><ul>\n<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>\n<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>\n</ul>\n<h4 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h4><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>\n</ul>\n<h4 id=\"反射的应用场景\"><a href=\"#反射的应用场景\" class=\"headerlink\" title=\"反射的应用场景\"></a>反射的应用场景</h4><p>反射是框架设计的灵魂。</p>\n<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br> 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Reflection：Java反射机制的应用场景</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\" target=\"_blank\" rel=\"noopener\">Java基础之—反射（非常重要）</a><h3 id=\"什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\"><a href=\"#什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\" class=\"headerlink\" title=\"什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\"></a>什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别</h3></li>\n</ul>\n<p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p>\n<p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p>\n<p><strong>JRE:</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p>\n<p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p>\n<p><strong>区别与联系：</strong></p>\n<ol>\n<li>JDK用于开发，JRE用于运行java程序 ；</li>\n<li>JDK和JRE中都包含JVM ；</li>\n<li>JVM是java编程语言的核心并且具有平台独立性。</li>\n</ol>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么？\"><a href=\"#什么是字节码？采用字节码的最大好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么？\"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下java中的编译器和解释器：</strong> 　　</p>\n<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>\n<p> Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p>\n<p><strong>采用字节码的好处：</strong> 　　</p>\n<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>\n<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>\n</ul>\n<h3 id=\"接口和抽象类的区别是什么？\"><a href=\"#接口和抽象类的区别是什么？\" class=\"headerlink\" title=\"接口和抽象类的区别是什么？\"></a>接口和抽象类的区别是什么？</h3><ol>\n<li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>\n<li>接口中的实例变量默认是final类型的，而抽象类中则不一定 </li>\n<li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li>\n<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li>\n<li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>\n</ol>\n<p>注意：Java8 后接口可以有默认实现( default )。</p>\n<h3 id=\"成员变量与局部变量的区别有那些？\"><a href=\"#成员变量与局部变量的区别有那些？\" class=\"headerlink\" title=\"成员变量与局部变量的区别有那些？\"></a>成员变量与局部变量的区别有那些？</h3><ol>\n<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li>\n<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>\n<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>\n<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li>\n</ol>\n<h3 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>\n<p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>\n<h3 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别\"></a>字符型常量和字符串常量的区别</h3><p>1) 形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br>2) 含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br>3) 占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"><a href=\"#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id=\"String和StringBuffer、StringBuilder的区别\"><a href=\"#String和StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别\"></a>String和StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong>\n　</p>\n<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>\n<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>\n<p>AbstractStringBuilder.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    AbstractStringBuilder() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AbstractStringBuilder(<span class=\"keyword\">int</span> capacity) &#123;</span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线程安全性</strong></p>\n<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　</p>\n<p><strong>性能</strong></p>\n<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong> </p>\n<ol>\n<li>操作少量的数据 = String</li>\n<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>\n<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>\n</ol>\n<h4 id=\"String为什么是不可变的吗？\"><a href=\"#String为什么是不可变的吗？\" class=\"headerlink\" title=\"String为什么是不可变的吗？\"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n<h4 id=\"String真的是不可变的吗？\"><a href=\"#String真的是不可变的吗？\" class=\"headerlink\" title=\"String真的是不可变的吗？\"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p>\n<p><strong>1) String不可变但不代表引用不可以变</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">str = str + <span class=\"string\">\" World\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=Hello World</span><br></pre></td></tr></table></figure></p>\n<p>解析：</p>\n<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>\n<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符串\"Hello World\"， 并赋给引用s</span></span><br><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取String类中的value字段</span></span><br><span class=\"line\">Field valueFieldOfString = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value属性的访问权限</span></span><br><span class=\"line\">valueFieldOfString.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取s对象上的value属性的值</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] value = (<span class=\"keyword\">char</span>[]) valueFieldOfString.get(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value所引用的数组中的第5个字符</span></span><br><span class=\"line\">value[<span class=\"number\">5</span>] = <span class=\"string\">'_'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello_World</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = Hello World</span><br><span class=\"line\">s = Hello_World</span><br></pre></td></tr></table></figure>\n<p>解析：</p>\n<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>\n<h3 id=\"什么是反射机制？反射机制的应用场景有哪些？\"><a href=\"#什么是反射机制？反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"什么是反射机制？反射机制的应用场景有哪些？\"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id=\"反射机制介绍\"><a href=\"#反射机制介绍\" class=\"headerlink\" title=\"反射机制介绍\"></a>反射机制介绍</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\n<h4 id=\"静态编译和动态编译\"><a href=\"#静态编译和动态编译\" class=\"headerlink\" title=\"静态编译和动态编译\"></a>静态编译和动态编译</h4><ul>\n<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>\n<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>\n</ul>\n<h4 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h4><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>\n</ul>\n<h4 id=\"反射的应用场景\"><a href=\"#反射的应用场景\" class=\"headerlink\" title=\"反射的应用场景\"></a>反射的应用场景</h4><p>反射是框架设计的灵魂。</p>\n<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br> 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Reflection：Java反射机制的应用场景</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\" target=\"_blank\" rel=\"noopener\">Java基础之—反射（非常重要）</a><h3 id=\"什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\"><a href=\"#什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\" class=\"headerlink\" title=\"什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\"></a>什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别</h3></li>\n</ul>\n<p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p>\n<p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p>\n<p><strong>JRE:</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p>\n<p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p>\n<p><strong>区别与联系：</strong></p>\n<ol>\n<li>JDK用于开发，JRE用于运行java程序 ；</li>\n<li>JDK和JRE中都包含JVM ；</li>\n<li>JVM是java编程语言的核心并且具有平台独立性。</li>\n</ol>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么？\"><a href=\"#什么是字节码？采用字节码的最大好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么？\"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下java中的编译器和解释器：</strong> 　　</p>\n<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>\n<p> Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p>\n<p><strong>采用字节码的好处：</strong> 　　</p>\n<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>\n<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>\n</ul>\n<h3 id=\"接口和抽象类的区别是什么？\"><a href=\"#接口和抽象类的区别是什么？\" class=\"headerlink\" title=\"接口和抽象类的区别是什么？\"></a>接口和抽象类的区别是什么？</h3><ol>\n<li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>\n<li>接口中的实例变量默认是final类型的，而抽象类中则不一定 </li>\n<li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li>\n<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li>\n<li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>\n</ol>\n<p>注意：Java8 后接口可以有默认实现( default )。</p>\n<h3 id=\"成员变量与局部变量的区别有那些？\"><a href=\"#成员变量与局部变量的区别有那些？\" class=\"headerlink\" title=\"成员变量与局部变量的区别有那些？\"></a>成员变量与局部变量的区别有那些？</h3><ol>\n<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li>\n<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>\n<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>\n<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li>\n</ol>\n<h3 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>\n<p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>\n<h3 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别\"></a>字符型常量和字符串常量的区别</h3><p>1) 形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br>2) 含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br>3) 占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>\n"},{"title":"Java常见问题汇总-Thread","_content":"<!-- toc -->\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","source":"_posts/Java/Summary/thread.md","raw":"---\ntitle: Java常见问题汇总-thread\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n<!-- toc -->\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","slug":"Java/Summary/thread","published":1,"date":"2019-11-11T07:59:20.463Z","updated":"2019-11-11T07:59:20.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzrdz003ulon9f7ao6j52","content":"<!-- toc -->\n<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<!-- toc -->\n<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n"},{"title":"Java容器——LinkedList","_content":"\n<!-- MarkdownTOC -->\n\n- [简介](#简介)\n- [内部结构分析](#内部结构分析)\n- [LinkedList源码分析](#linkedlist源码分析)\n    - [构造方法](#构造方法)\n    - [添加（add）方法](#add方法)\n    - [根据位置取数据的方法](#根据位置取数据的方法)\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\n    - [检查链表是否包含某对象的方法：](#检查链表是否包含某对象的方法：)\n    - [删除（remove/pop）方法](#删除方法)\n- [LinkedList类常用方法测试：](#linkedlist类常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n## <font face=\"楷体\" id=\"1\">简介</font>\n<font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。 \nLinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\nLinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法： \n```java\nList list=Collections.synchronizedList(new LinkedList(...));\n```\n## <font face=\"楷体\" id=\"2\">内部结构分析</font>\n**如下图所示：**\n![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)\n看完了图之后，我们再看LinkedList类中的一个<font color=\"red\">**内部私有类Node**</font>就很好理解了：\n```java\nprivate static class Node<E> {\n        E item;//节点值\n        Node<E> next;//后继节点\n        Node<E> prev;//前驱节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\n\n## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font>\n### <font face=\"楷体\" id=\"3.1\">构造方法</font>\n**空构造方法：**\n```java\n    public LinkedList() {\n    }\n```\n**用已有的集合创建链表的构造方法：**\n```java\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\n### <font face=\"楷体\" id=\"3.2\">add方法</font>\n**add(E e)** 方法：将元素添加到链表尾部\n```java\npublic boolean add(E e) {\n        linkLast(e);//这里就只调用了这一个方法\n        return true;\n    }\n```\n\n```java\n   /**\n     * 链接使e作为最后一个元素。\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;//新建节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;//指向后继元素也就是指向下一个元素\n        size++;\n        modCount++;\n    }\n```\n**add(int index,E e)**：在指定位置添加元素\n```java\npublic void add(int index, E element) {\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\n\n        if (index == size)//添加在链表尾部\n            linkLast(element);\n        else//添加在链表中间\n            linkBefore(element, node(index));\n    }\n```\n<font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n**addAll(Collection  c )：将集合插入到链表尾部**\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n```\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n        //1:检查index范围是否在size之内\n        checkPositionIndex(index);\n\n        //2:toArray()方法把集合的数据存到对象数组中\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        //3：得到插入位置的前驱节点和后继节点\n        Node<E> pred, succ;\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\n        if (index == size) {\n            succ = null;\n            pred = last;\n        }\n        //否则，调用node()方法得到后继节点，再得到前驱节点\n        else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 4：遍历数据将数据插入\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果插入位置在链表头部\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        //如果插入位置在尾部，重置last节点\n        if (succ == null) {\n            last = pred;\n        }\n        //否则，将插入的链表与先前链表连接起来\n        else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }    \n```\n上面可以看出addAll方法通常包括下面四个步骤：\n1. 检查index范围是否在size之内\n2. toArray()方法把集合的数据存到对象数组中\n3. 得到插入位置的前驱和后继节点\n4. 遍历数据，将数据插入到指定位置\n\n**addFirst(E e)：** 将元素添加到链表头部\n```java\n public void addFirst(E e) {\n        linkFirst(e);\n    }\n```\n```java\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\n        first = newNode;\n        //如果链表为空，last节点也指向该节点\n        if (f == null)\n            last = newNode;\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\n```java\npublic void addLast(E e) {\n        linkLast(e);\n    }\n```\n### <font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font>\n**get(int index)：** 根据指定索引返回数据\n```java\npublic E get(int index) {\n        //检查index范围是否在size之内\n        checkElementIndex(index);\n        //调用Node(index)去找到index对应的node然后返回它的值\n        return node(index).item;\n    }\n```\n**获取头节点（index=0）数据方法:**\n```java\npublic E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\npublic E element() {\n        return getFirst();\n    }\npublic E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\npublic E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n```\n**区别：**\ngetFirst(),element(),peek(),peekFirst()\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\n\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \n**获取尾节点（index=-1）数据方法:**\n```java\n public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n```\n**两者区别：**\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\n### <font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font>\n**int indexOf(Object o)：** 从头遍历找\n```java\npublic int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n**int lastIndexOf(Object o)：** 从尾遍历找\n```java\npublic int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font>\n**contains(Object o)：** 检查对象o是否存在于链表中\n```java\n public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.6\">删除方法</font>\n**remove()** ,**removeFirst(),pop():** 删除头节点\n```\npublic E pop() {\n        return removeFirst();\n    }\npublic E remove() {\n        return removeFirst();\n    }\npublic E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n```\n**removeLast(),pollLast():** 删除尾节点\n```java\npublic E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\npublic E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n```\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\n\n**remove(Object o):** 删除指定元素\n```java\npublic boolean remove(Object o) {\n        //如果删除对象为null\n        if (o == null) {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (x.item == null) {\n                   //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (o.equals(x.item)) {\n                    //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\n\nunlink(Node<E> x) 方法：\n```java\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;//得到后继节点\n        final Node<E> prev = x.prev;//得到前驱节点\n\n        //删除前驱指针\n        if (prev == null) {\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\n        } else {\n            prev.next = next;//将前驱节点的后继节点指向后继节点\n            x.prev = null;\n        }\n\n        //删除后继指针\n        if (next == null) {\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n**remove(int index)**：删除指定位置的元素\n```java\npublic E remove(int index) {\n        //检查index范围\n        checkElementIndex(index);\n        //将节点删除\n        return unlink(node(index));\n    }\n```\n## <font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font>\n\n```java\npackage list;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] srgs) {\n        //创建存放int类型的linkedList\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        /************************** linkedList的基本操作 ************************/\n        linkedList.addFirst(0); // 添加元素到列表开头\n        linkedList.add(1); // 在列表结尾添加元素\n        linkedList.add(2, 2); // 在指定位置添加元素\n        linkedList.addLast(3); // 添加元素到列表结尾\n        \n        System.out.println(\"LinkedList（直接输出的）: \" + linkedList);\n\n        System.out.println(\"getFirst()获得第一个元素: \" + linkedList.getFirst()); // 返回此列表的第一个元素\n        System.out.println(\"getLast()获得第最后一个元素: \" + linkedList.getLast()); // 返回此列表的最后一个元素\n        System.out.println(\"removeFirst()删除第一个元素并返回: \" + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\n        System.out.println(\"removeLast()删除最后一个元素并返回: \" + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\n        System.out.println(\"After remove:\" + linkedList);\n        System.out.println(\"contains()方法判断列表是否包含1这个元素:\" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\n        System.out.println(\"该linkedList的大小 : \" + linkedList.size()); // 返回此列表的元素个数\n\n        /************************** 位置访问操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\n        System.out.println(\"After set(1, 3):\" + linkedList);\n        System.out.println(\"get(1)获得指定位置（这里为1）的元素: \" + linkedList.get(1)); // 返回此列表中指定位置处的元素\n\n        /************************** Search操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.add(3);\n        System.out.println(\"indexOf(3): \" + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\n        System.out.println(\"lastIndexOf(3): \" + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\n\n        /************************** Queue操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        System.out.println(\"peek(): \" + linkedList.peek()); // 获取但不移除此列表的头\n        System.out.println(\"element(): \" + linkedList.element()); // 获取但不移除此列表的头\n        linkedList.poll(); // 获取并移除此列表的头\n        System.out.println(\"After poll():\" + linkedList);\n        linkedList.remove();\n        System.out.println(\"After remove():\" + linkedList); // 获取并移除此列表的头\n        linkedList.offer(4);\n        System.out.println(\"After offer(4):\" + linkedList); // 将指定元素添加到此列表的末尾\n\n        /************************** Deque操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\n        System.out.println(\"After offerFirst(2):\" + linkedList);\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\n        System.out.println(\"After offerLast(5):\" + linkedList);\n        System.out.println(\"peekFirst(): \" + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\n        System.out.println(\"peekLast(): \" + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\n        System.out.println(\"After pollFirst():\" + linkedList);\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\n        System.out.println(\"After pollLast():\" + linkedList);\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\n        System.out.println(\"After push(2):\" + linkedList);\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\n        System.out.println(\"After pop():\" + linkedList);\n        linkedList.add(3);\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n\n        /************************** 遍历操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.clear();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        // 迭代器遍历\n        long start = System.currentTimeMillis();\n        Iterator<Integer> iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            iterator.next();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"Iterator：\" + (end - start) + \" ms\");\n\n        // 顺序遍历(随机遍历)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedList.get(i);\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"for：\" + (end - start) + \" ms\");\n\n        // 另一种for循环遍历\n        start = System.currentTimeMillis();\n        for (Integer i : linkedList)\n            ;\n        end = System.currentTimeMillis();\n        System.out.println(\"for2：\" + (end - start) + \" ms\");\n\n        // 通过pollFirst()或pollLast()来遍历LinkedList\n        LinkedList<Integer> temp1 = new LinkedList<>();\n        temp1.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp1.size() != 0) {\n            temp1.pollFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"pollFirst()或pollLast()：\" + (end - start) + \" ms\");\n\n        // 通过removeFirst()或removeLast()来遍历LinkedList\n        LinkedList<Integer> temp2 = new LinkedList<>();\n        temp2.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp2.size() != 0) {\n            temp2.removeFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"removeFirst()或removeLast()：\" + (end - start) + \" ms\");\n    }\n}\n```\n","source":"_posts/Java/Collection-Framework/LinkedList.md","raw":"---\ntitle: Java容器——LinkedList\ncategories:\n  - Java\n  - Collection-Framework\ntags: \n- linked-list\n---\n\n<!-- MarkdownTOC -->\n\n- [简介](#简介)\n- [内部结构分析](#内部结构分析)\n- [LinkedList源码分析](#linkedlist源码分析)\n    - [构造方法](#构造方法)\n    - [添加（add）方法](#add方法)\n    - [根据位置取数据的方法](#根据位置取数据的方法)\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\n    - [检查链表是否包含某对象的方法：](#检查链表是否包含某对象的方法：)\n    - [删除（remove/pop）方法](#删除方法)\n- [LinkedList类常用方法测试：](#linkedlist类常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n## <font face=\"楷体\" id=\"1\">简介</font>\n<font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。 \nLinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\nLinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法： \n```java\nList list=Collections.synchronizedList(new LinkedList(...));\n```\n## <font face=\"楷体\" id=\"2\">内部结构分析</font>\n**如下图所示：**\n![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)\n看完了图之后，我们再看LinkedList类中的一个<font color=\"red\">**内部私有类Node**</font>就很好理解了：\n```java\nprivate static class Node<E> {\n        E item;//节点值\n        Node<E> next;//后继节点\n        Node<E> prev;//前驱节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\n\n## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font>\n### <font face=\"楷体\" id=\"3.1\">构造方法</font>\n**空构造方法：**\n```java\n    public LinkedList() {\n    }\n```\n**用已有的集合创建链表的构造方法：**\n```java\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\n### <font face=\"楷体\" id=\"3.2\">add方法</font>\n**add(E e)** 方法：将元素添加到链表尾部\n```java\npublic boolean add(E e) {\n        linkLast(e);//这里就只调用了这一个方法\n        return true;\n    }\n```\n\n```java\n   /**\n     * 链接使e作为最后一个元素。\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;//新建节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;//指向后继元素也就是指向下一个元素\n        size++;\n        modCount++;\n    }\n```\n**add(int index,E e)**：在指定位置添加元素\n```java\npublic void add(int index, E element) {\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\n\n        if (index == size)//添加在链表尾部\n            linkLast(element);\n        else//添加在链表中间\n            linkBefore(element, node(index));\n    }\n```\n<font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n**addAll(Collection  c )：将集合插入到链表尾部**\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n```\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n        //1:检查index范围是否在size之内\n        checkPositionIndex(index);\n\n        //2:toArray()方法把集合的数据存到对象数组中\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        //3：得到插入位置的前驱节点和后继节点\n        Node<E> pred, succ;\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\n        if (index == size) {\n            succ = null;\n            pred = last;\n        }\n        //否则，调用node()方法得到后继节点，再得到前驱节点\n        else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 4：遍历数据将数据插入\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果插入位置在链表头部\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        //如果插入位置在尾部，重置last节点\n        if (succ == null) {\n            last = pred;\n        }\n        //否则，将插入的链表与先前链表连接起来\n        else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }    \n```\n上面可以看出addAll方法通常包括下面四个步骤：\n1. 检查index范围是否在size之内\n2. toArray()方法把集合的数据存到对象数组中\n3. 得到插入位置的前驱和后继节点\n4. 遍历数据，将数据插入到指定位置\n\n**addFirst(E e)：** 将元素添加到链表头部\n```java\n public void addFirst(E e) {\n        linkFirst(e);\n    }\n```\n```java\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\n        first = newNode;\n        //如果链表为空，last节点也指向该节点\n        if (f == null)\n            last = newNode;\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\n```java\npublic void addLast(E e) {\n        linkLast(e);\n    }\n```\n### <font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font>\n**get(int index)：** 根据指定索引返回数据\n```java\npublic E get(int index) {\n        //检查index范围是否在size之内\n        checkElementIndex(index);\n        //调用Node(index)去找到index对应的node然后返回它的值\n        return node(index).item;\n    }\n```\n**获取头节点（index=0）数据方法:**\n```java\npublic E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\npublic E element() {\n        return getFirst();\n    }\npublic E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\npublic E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n```\n**区别：**\ngetFirst(),element(),peek(),peekFirst()\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\n\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \n**获取尾节点（index=-1）数据方法:**\n```java\n public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n```\n**两者区别：**\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\n### <font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font>\n**int indexOf(Object o)：** 从头遍历找\n```java\npublic int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n**int lastIndexOf(Object o)：** 从尾遍历找\n```java\npublic int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font>\n**contains(Object o)：** 检查对象o是否存在于链表中\n```java\n public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.6\">删除方法</font>\n**remove()** ,**removeFirst(),pop():** 删除头节点\n```\npublic E pop() {\n        return removeFirst();\n    }\npublic E remove() {\n        return removeFirst();\n    }\npublic E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n```\n**removeLast(),pollLast():** 删除尾节点\n```java\npublic E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\npublic E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n```\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\n\n**remove(Object o):** 删除指定元素\n```java\npublic boolean remove(Object o) {\n        //如果删除对象为null\n        if (o == null) {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (x.item == null) {\n                   //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (o.equals(x.item)) {\n                    //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\n\nunlink(Node<E> x) 方法：\n```java\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;//得到后继节点\n        final Node<E> prev = x.prev;//得到前驱节点\n\n        //删除前驱指针\n        if (prev == null) {\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\n        } else {\n            prev.next = next;//将前驱节点的后继节点指向后继节点\n            x.prev = null;\n        }\n\n        //删除后继指针\n        if (next == null) {\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n**remove(int index)**：删除指定位置的元素\n```java\npublic E remove(int index) {\n        //检查index范围\n        checkElementIndex(index);\n        //将节点删除\n        return unlink(node(index));\n    }\n```\n## <font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font>\n\n```java\npackage list;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] srgs) {\n        //创建存放int类型的linkedList\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        /************************** linkedList的基本操作 ************************/\n        linkedList.addFirst(0); // 添加元素到列表开头\n        linkedList.add(1); // 在列表结尾添加元素\n        linkedList.add(2, 2); // 在指定位置添加元素\n        linkedList.addLast(3); // 添加元素到列表结尾\n        \n        System.out.println(\"LinkedList（直接输出的）: \" + linkedList);\n\n        System.out.println(\"getFirst()获得第一个元素: \" + linkedList.getFirst()); // 返回此列表的第一个元素\n        System.out.println(\"getLast()获得第最后一个元素: \" + linkedList.getLast()); // 返回此列表的最后一个元素\n        System.out.println(\"removeFirst()删除第一个元素并返回: \" + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\n        System.out.println(\"removeLast()删除最后一个元素并返回: \" + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\n        System.out.println(\"After remove:\" + linkedList);\n        System.out.println(\"contains()方法判断列表是否包含1这个元素:\" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\n        System.out.println(\"该linkedList的大小 : \" + linkedList.size()); // 返回此列表的元素个数\n\n        /************************** 位置访问操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\n        System.out.println(\"After set(1, 3):\" + linkedList);\n        System.out.println(\"get(1)获得指定位置（这里为1）的元素: \" + linkedList.get(1)); // 返回此列表中指定位置处的元素\n\n        /************************** Search操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.add(3);\n        System.out.println(\"indexOf(3): \" + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\n        System.out.println(\"lastIndexOf(3): \" + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\n\n        /************************** Queue操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        System.out.println(\"peek(): \" + linkedList.peek()); // 获取但不移除此列表的头\n        System.out.println(\"element(): \" + linkedList.element()); // 获取但不移除此列表的头\n        linkedList.poll(); // 获取并移除此列表的头\n        System.out.println(\"After poll():\" + linkedList);\n        linkedList.remove();\n        System.out.println(\"After remove():\" + linkedList); // 获取并移除此列表的头\n        linkedList.offer(4);\n        System.out.println(\"After offer(4):\" + linkedList); // 将指定元素添加到此列表的末尾\n\n        /************************** Deque操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\n        System.out.println(\"After offerFirst(2):\" + linkedList);\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\n        System.out.println(\"After offerLast(5):\" + linkedList);\n        System.out.println(\"peekFirst(): \" + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\n        System.out.println(\"peekLast(): \" + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\n        System.out.println(\"After pollFirst():\" + linkedList);\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\n        System.out.println(\"After pollLast():\" + linkedList);\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\n        System.out.println(\"After push(2):\" + linkedList);\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\n        System.out.println(\"After pop():\" + linkedList);\n        linkedList.add(3);\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n\n        /************************** 遍历操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.clear();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        // 迭代器遍历\n        long start = System.currentTimeMillis();\n        Iterator<Integer> iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            iterator.next();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"Iterator：\" + (end - start) + \" ms\");\n\n        // 顺序遍历(随机遍历)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedList.get(i);\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"for：\" + (end - start) + \" ms\");\n\n        // 另一种for循环遍历\n        start = System.currentTimeMillis();\n        for (Integer i : linkedList)\n            ;\n        end = System.currentTimeMillis();\n        System.out.println(\"for2：\" + (end - start) + \" ms\");\n\n        // 通过pollFirst()或pollLast()来遍历LinkedList\n        LinkedList<Integer> temp1 = new LinkedList<>();\n        temp1.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp1.size() != 0) {\n            temp1.pollFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"pollFirst()或pollLast()：\" + (end - start) + \" ms\");\n\n        // 通过removeFirst()或removeLast()来遍历LinkedList\n        LinkedList<Integer> temp2 = new LinkedList<>();\n        temp2.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp2.size() != 0) {\n            temp2.removeFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"removeFirst()或removeLast()：\" + (end - start) + \" ms\");\n    }\n}\n```\n","slug":"Java/Collection-Framework/LinkedList","published":1,"date":"2019-11-11T07:59:20.461Z","updated":"2019-11-11T07:59:20.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzre5004llon9enuioxnw","content":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#简介\">简介</a></li>\n<li><a href=\"#内部结构分析\">内部结构分析</a></li>\n<li><a href=\"#linkedlist源码分析\">LinkedList源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#add方法\">添加（add）方法</a></li>\n<li><a href=\"#根据位置取数据的方法\">根据位置取数据的方法</a></li>\n<li><a href=\"#根据对象得到索引的方法\">根据对象得到索引的方法</a></li>\n<li><a href=\"#检查链表是否包含某对象的方法：\">检查链表是否包含某对象的方法：</a></li>\n<li><a href=\"#删除方法\">删除（remove/pop）方法</a></li>\n</ul>\n</li>\n<li><a href=\"#linkedlist类常用方法测试\">LinkedList类常用方法测试：</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font face=\"楷体\" id=\"1\">简介</font></h2><font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。<br>LinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><br><br>## <font face=\"楷体\" id=\"2\">内部结构分析</font><br><strong>如下图所示：</strong><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&amp;h=481&amp;f=jpeg&amp;s=18502\" alt=\"LinkedList内部结构\"><br>看完了图之后，我们再看LinkedList类中的一个<font color=\"red\"><strong>内部私有类Node</strong></font>就很好理解了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        E item;<span class=\"comment\">//节点值</span></span><br><span class=\"line\">        Node&lt;E&gt; next;<span class=\"comment\">//后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; prev;<span class=\"comment\">//前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。<br><br>## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font><br>### <font face=\"楷体\" id=\"3.1\">构造方法</font><br><strong>空构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>用已有的集合创建链表的构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>### <font face=\"楷体\" id=\"3.2\">add方法</font><br><strong>add(E e)</strong> 方法：将元素添加到链表尾部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);<span class=\"comment\">//这里就只调用了这一个方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 链接使e作为最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">     last = newNode;<span class=\"comment\">//新建节点</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">         first = newNode;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">         l.next = newNode;<span class=\"comment\">//指向后继元素也就是指向下一个元素</span></span><br><span class=\"line\">     size++;</span><br><span class=\"line\">     modCount++;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br><br><strong>add(int index,E e)</strong>：在指定位置添加元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index); <span class=\"comment\">//检查索引是否处于[0-size]之间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//添加在链表尾部</span></span><br><span class=\"line\">            linkLast(element);</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//添加在链表中间</span></span><br><span class=\"line\">            linkBefore(element, node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n<p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1:检查index范围是否在size之内</span></span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">            succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            pred = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            succ = node(index);</span><br><span class=\"line\">            pred = succ.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4：遍历数据将数据插入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">            <span class=\"comment\">//创建新节点</span></span><br><span class=\"line\">            Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">//如果插入位置在链表头部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                first = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                pred.next = newNode;</span><br><span class=\"line\">            pred = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置在尾部，重置last节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将插入的链表与先前链表连接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pred.next = succ;</span><br><span class=\"line\">            succ.prev = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看出addAll方法通常包括下面四个步骤：</p>\n<ol>\n<li>检查index范围是否在size之内</li>\n<li>toArray()方法把集合的数据存到对象数组中</li>\n<li>得到插入位置的前驱和后继节点</li>\n<li>遍历数据，将数据插入到指定位置</li>\n</ol>\n<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       linkFirst(e);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);<span class=\"comment\">//新建节点，以头节点为后继节点</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表为空，last节点也指向该节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            last = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.prev = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"根据位置取数据的方法\"><a href=\"#根据位置取数据的方法\" class=\"headerlink\" title=\"根据位置取数据的方法\"></a><font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围是否在size之内</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>获取头节点（index=0）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>\n<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : l.item;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>\n<h3 id=\"根据对象得到索引的方法\"><a href=\"#根据对象得到索引的方法\" class=\"headerlink\" title=\"根据对象得到索引的方法\"></a><font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"检查链表是否包含某对象的方法：\"><a href=\"#检查链表是否包含某对象的方法：\" class=\"headerlink\" title=\"检查链表是否包含某对象的方法：\"></a><font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除方法\"><a href=\"#删除方法\" class=\"headerlink\" title=\"删除方法\"></a><font face=\"楷体\" id=\"3.6\">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E pop() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E remove() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E removeFirst() &#123;</span><br><span class=\"line\">        final Node&lt;E&gt; f = first;</span><br><span class=\"line\">        if (f == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        return unlinkFirst(f);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>removeLast(),pollLast():</strong> 删除尾节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>\n<p><strong>remove(Object o):</strong> 删除指定元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果删除对象为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p>\n<p>unlink(Node<e> x) 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;<span class=\"comment\">//得到后继节点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;<span class=\"comment\">//得到前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除前驱指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = next;<span class=\"comment\">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev.next = next;<span class=\"comment\">//将前驱节点的后继节点指向后继节点</span></span><br><span class=\"line\">            x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除后继指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = prev;<span class=\"comment\">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next.prev = prev;</span><br><span class=\"line\">            x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></e></p>\n<p><strong>remove(int index)</strong>：删除指定位置的元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//将节点删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"LinkedList类常用方法测试\"><a href=\"#LinkedList类常用方法测试\" class=\"headerlink\" title=\"LinkedList类常用方法测试\"></a><font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedListDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建存放int类型的linkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">/************************** linkedList的基本操作 ************************/</span></span><br><span class=\"line\">        linkedList.addFirst(<span class=\"number\">0</span>); <span class=\"comment\">// 添加元素到列表开头</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">1</span>); <span class=\"comment\">// 在列表结尾添加元素</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">        linkedList.addLast(<span class=\"number\">3</span>); <span class=\"comment\">// 添加元素到列表结尾</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"LinkedList（直接输出的）: \"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getFirst()获得第一个元素: \"</span> + linkedList.getFirst()); <span class=\"comment\">// 返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getLast()获得第最后一个元素: \"</span> + linkedList.getLast()); <span class=\"comment\">// 返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()删除第一个元素并返回: \"</span> + linkedList.removeFirst()); <span class=\"comment\">// 移除并返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeLast()删除最后一个元素并返回: \"</span> + linkedList.removeLast()); <span class=\"comment\">// 移除并返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove:\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"contains()方法判断列表是否包含1这个元素:\"</span> + linkedList.contains(<span class=\"number\">1</span>)); <span class=\"comment\">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该linkedList的大小 : \"</span> + linkedList.size()); <span class=\"comment\">// 返回此列表的元素个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 位置访问操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.set(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After set(1, 3):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"get(1)获得指定位置（这里为1）的元素: \"</span> + linkedList.get(<span class=\"number\">1</span>)); <span class=\"comment\">// 返回此列表中指定位置处的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Search操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"indexOf(3): \"</span> + linkedList.indexOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lastIndexOf(3): \"</span> + linkedList.lastIndexOf(<span class=\"number\">3</span>));<span class=\"comment\">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Queue操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peek(): \"</span> + linkedList.peek()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"element(): \"</span> + linkedList.element()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        linkedList.poll(); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After poll():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.remove();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove():\"</span> + linkedList); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        linkedList.offer(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offer(4):\"</span> + linkedList); <span class=\"comment\">// 将指定元素添加到此列表的末尾</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Deque操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.offerFirst(<span class=\"number\">2</span>); <span class=\"comment\">// 在此列表的开头插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerFirst(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.offerLast(<span class=\"number\">5</span>); <span class=\"comment\">// 在此列表末尾插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerLast(5):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekFirst(): \"</span> + linkedList.peekFirst()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekLast(): \"</span> + linkedList.peekLast()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        linkedList.pollFirst(); <span class=\"comment\">// 获取并移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollFirst():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pollLast(); <span class=\"comment\">// 获取并移除此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollLast():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.push(<span class=\"number\">2</span>); <span class=\"comment\">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After push(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pop(); <span class=\"comment\">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pop():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        linkedList.removeFirstOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.removeLastOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 遍历操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">            linkedList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代器遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            iterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Iterator：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顺序遍历(随机遍历)</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class=\"line\">            linkedList.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 另一种for循环遍历</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : linkedList)</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for2：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp1.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp1.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"pollFirst()或pollLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp2.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp2.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp2.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()或removeLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#简介\">简介</a></li>\n<li><a href=\"#内部结构分析\">内部结构分析</a></li>\n<li><a href=\"#linkedlist源码分析\">LinkedList源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#add方法\">添加（add）方法</a></li>\n<li><a href=\"#根据位置取数据的方法\">根据位置取数据的方法</a></li>\n<li><a href=\"#根据对象得到索引的方法\">根据对象得到索引的方法</a></li>\n<li><a href=\"#检查链表是否包含某对象的方法：\">检查链表是否包含某对象的方法：</a></li>\n<li><a href=\"#删除方法\">删除（remove/pop）方法</a></li>\n</ul>\n</li>\n<li><a href=\"#linkedlist类常用方法测试\">LinkedList类常用方法测试：</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font face=\"楷体\" id=\"1\">简介</font></h2><font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。<br>LinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><br><br>## <font face=\"楷体\" id=\"2\">内部结构分析</font><br><strong>如下图所示：</strong><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&amp;h=481&amp;f=jpeg&amp;s=18502\" alt=\"LinkedList内部结构\"><br>看完了图之后，我们再看LinkedList类中的一个<font color=\"red\"><strong>内部私有类Node</strong></font>就很好理解了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        E item;<span class=\"comment\">//节点值</span></span><br><span class=\"line\">        Node&lt;E&gt; next;<span class=\"comment\">//后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; prev;<span class=\"comment\">//前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。<br><br>## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font><br>### <font face=\"楷体\" id=\"3.1\">构造方法</font><br><strong>空构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>用已有的集合创建链表的构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>### <font face=\"楷体\" id=\"3.2\">add方法</font><br><strong>add(E e)</strong> 方法：将元素添加到链表尾部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);<span class=\"comment\">//这里就只调用了这一个方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 链接使e作为最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">     last = newNode;<span class=\"comment\">//新建节点</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">         first = newNode;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">         l.next = newNode;<span class=\"comment\">//指向后继元素也就是指向下一个元素</span></span><br><span class=\"line\">     size++;</span><br><span class=\"line\">     modCount++;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br><br><strong>add(int index,E e)</strong>：在指定位置添加元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index); <span class=\"comment\">//检查索引是否处于[0-size]之间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//添加在链表尾部</span></span><br><span class=\"line\">            linkLast(element);</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//添加在链表中间</span></span><br><span class=\"line\">            linkBefore(element, node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n<p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1:检查index范围是否在size之内</span></span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">            succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            pred = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            succ = node(index);</span><br><span class=\"line\">            pred = succ.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4：遍历数据将数据插入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">            <span class=\"comment\">//创建新节点</span></span><br><span class=\"line\">            Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">//如果插入位置在链表头部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                first = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                pred.next = newNode;</span><br><span class=\"line\">            pred = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置在尾部，重置last节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将插入的链表与先前链表连接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pred.next = succ;</span><br><span class=\"line\">            succ.prev = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看出addAll方法通常包括下面四个步骤：</p>\n<ol>\n<li>检查index范围是否在size之内</li>\n<li>toArray()方法把集合的数据存到对象数组中</li>\n<li>得到插入位置的前驱和后继节点</li>\n<li>遍历数据，将数据插入到指定位置</li>\n</ol>\n<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       linkFirst(e);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);<span class=\"comment\">//新建节点，以头节点为后继节点</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表为空，last节点也指向该节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            last = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.prev = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"根据位置取数据的方法\"><a href=\"#根据位置取数据的方法\" class=\"headerlink\" title=\"根据位置取数据的方法\"></a><font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围是否在size之内</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>获取头节点（index=0）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>\n<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : l.item;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>\n<h3 id=\"根据对象得到索引的方法\"><a href=\"#根据对象得到索引的方法\" class=\"headerlink\" title=\"根据对象得到索引的方法\"></a><font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"检查链表是否包含某对象的方法：\"><a href=\"#检查链表是否包含某对象的方法：\" class=\"headerlink\" title=\"检查链表是否包含某对象的方法：\"></a><font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除方法\"><a href=\"#删除方法\" class=\"headerlink\" title=\"删除方法\"></a><font face=\"楷体\" id=\"3.6\">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E pop() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E remove() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E removeFirst() &#123;</span><br><span class=\"line\">        final Node&lt;E&gt; f = first;</span><br><span class=\"line\">        if (f == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        return unlinkFirst(f);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>removeLast(),pollLast():</strong> 删除尾节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>\n<p><strong>remove(Object o):</strong> 删除指定元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果删除对象为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p>\n<p>unlink(Node<e> x) 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;<span class=\"comment\">//得到后继节点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;<span class=\"comment\">//得到前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除前驱指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = next;<span class=\"comment\">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev.next = next;<span class=\"comment\">//将前驱节点的后继节点指向后继节点</span></span><br><span class=\"line\">            x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除后继指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = prev;<span class=\"comment\">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next.prev = prev;</span><br><span class=\"line\">            x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></e></p>\n<p><strong>remove(int index)</strong>：删除指定位置的元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//将节点删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"LinkedList类常用方法测试\"><a href=\"#LinkedList类常用方法测试\" class=\"headerlink\" title=\"LinkedList类常用方法测试\"></a><font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedListDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建存放int类型的linkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">/************************** linkedList的基本操作 ************************/</span></span><br><span class=\"line\">        linkedList.addFirst(<span class=\"number\">0</span>); <span class=\"comment\">// 添加元素到列表开头</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">1</span>); <span class=\"comment\">// 在列表结尾添加元素</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">        linkedList.addLast(<span class=\"number\">3</span>); <span class=\"comment\">// 添加元素到列表结尾</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"LinkedList（直接输出的）: \"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getFirst()获得第一个元素: \"</span> + linkedList.getFirst()); <span class=\"comment\">// 返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getLast()获得第最后一个元素: \"</span> + linkedList.getLast()); <span class=\"comment\">// 返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()删除第一个元素并返回: \"</span> + linkedList.removeFirst()); <span class=\"comment\">// 移除并返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeLast()删除最后一个元素并返回: \"</span> + linkedList.removeLast()); <span class=\"comment\">// 移除并返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove:\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"contains()方法判断列表是否包含1这个元素:\"</span> + linkedList.contains(<span class=\"number\">1</span>)); <span class=\"comment\">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该linkedList的大小 : \"</span> + linkedList.size()); <span class=\"comment\">// 返回此列表的元素个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 位置访问操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.set(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After set(1, 3):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"get(1)获得指定位置（这里为1）的元素: \"</span> + linkedList.get(<span class=\"number\">1</span>)); <span class=\"comment\">// 返回此列表中指定位置处的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Search操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"indexOf(3): \"</span> + linkedList.indexOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lastIndexOf(3): \"</span> + linkedList.lastIndexOf(<span class=\"number\">3</span>));<span class=\"comment\">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Queue操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peek(): \"</span> + linkedList.peek()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"element(): \"</span> + linkedList.element()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        linkedList.poll(); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After poll():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.remove();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove():\"</span> + linkedList); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        linkedList.offer(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offer(4):\"</span> + linkedList); <span class=\"comment\">// 将指定元素添加到此列表的末尾</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Deque操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.offerFirst(<span class=\"number\">2</span>); <span class=\"comment\">// 在此列表的开头插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerFirst(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.offerLast(<span class=\"number\">5</span>); <span class=\"comment\">// 在此列表末尾插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerLast(5):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekFirst(): \"</span> + linkedList.peekFirst()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekLast(): \"</span> + linkedList.peekLast()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        linkedList.pollFirst(); <span class=\"comment\">// 获取并移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollFirst():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pollLast(); <span class=\"comment\">// 获取并移除此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollLast():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.push(<span class=\"number\">2</span>); <span class=\"comment\">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After push(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pop(); <span class=\"comment\">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pop():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        linkedList.removeFirstOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.removeLastOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 遍历操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">            linkedList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代器遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            iterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Iterator：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顺序遍历(随机遍历)</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class=\"line\">            linkedList.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 另一种for循环遍历</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : linkedList)</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for2：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp1.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp1.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"pollFirst()或pollLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp2.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp2.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp2.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()或removeLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java容器——HashMap","_content":"<!-- MarkdownTOC -->\n\n- [HashMap 简介](#hashmap-简介)\n- [底层数据结构分析](#底层数据结构分析)\n  - [JDK1.8之前](#jdk18之前)\n  - [JDK1.8之后](#jdk18之后)\n- [HashMap源码分析](#hashmap源码分析)\n  - [构造方法](#构造方法)\n  - [put方法](#put方法)\n  - [get方法](#get方法)\n  - [resize方法](#resize方法)\n- [HashMap常用方法测试](#hashmap常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\n\n## HashMap 简介\nHashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 \n\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。\n\n## 底层数据结构分析\n### JDK1.8之前\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\n\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n  ```java\n      static final int hash(Object key) {\n        int h;\n        // key.hashCode()：返回散列值也就是hashcode\n        // ^ ：按位异或\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n  ```\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\n\n### JDK1.8之后\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\n\n**类的属性：**\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n}\n```\n- **loadFactor加载因子**\n\n  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n\n  **loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值**。 \n  \n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n- **threshold**\n\n  **threshold = capacity * loadFactor**，**当Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\n\n**Node节点类源码:**\n\n```java\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n**树节点类源码:**\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n```\n## HashMap源码分析\n### 构造方法\n![四个构造方法](https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&h=90&f=jpeg&s=26744)\n```java\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n     \n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);//下面会分析到这个方法\n     }\n     \n     // 指定“容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n     \n     // 指定“容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n```\n\n**putMapEntries方法：**\n\n```java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的t大于阈值，则初始化阈值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n### put方法\nHashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。\n\n**对putVal方法添加元素的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入。\n\n\n\n![put方法](https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&h=679&f=png&s=54486)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n} \n```\n\n**我们再来对比一下 JDK1.7 put方法的代码**\n\n**对于put方法的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。\n\n```java\npublic V put(K key, V value)\n    if (table == EMPTY_TABLE) { \n    inflateTable(threshold); \n}  \n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue; \n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);  // 再插入\n    return null;\n}\n```\n\n\n\n### get方法\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n### resize方法\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else { \n        // signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算新的resize上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n## HashMap常用方法测试\n```java\npackage map;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class HashMapDemo {\n\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        // 键不能重复，值可以重复\n        map.put(\"san\", \"张三\");\n        map.put(\"si\", \"李四\");\n        map.put(\"wu\", \"王五\");\n        map.put(\"wang\", \"老王\");\n        map.put(\"wang\", \"老王2\");// 老王被覆盖\n        map.put(\"lao\", \"老王\");\n        System.out.println(\"-------直接输出hashmap:-------\");\n        System.out.println(map);\n        /**\n         * 遍历HashMap\n         */\n        // 1.获取Map中的所有键\n        System.out.println(\"-------foreach获取Map中所有的键:------\");\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            System.out.print(key+\"  \");\n        }\n        System.out.println();//换行\n        // 2.获取Map中所有值\n        System.out.println(\"-------foreach获取Map中所有的值:------\");\n        Collection<String> values = map.values();\n        for (String value : values) {\n            System.out.print(value+\"  \");\n        }\n        System.out.println();//换行\n        // 3.得到key的值的同时得到key所对应的值\n        System.out.println(\"-------得到key的值的同时得到key所对应的值:-------\");\n        Set<String> keys2 = map.keySet();\n        for (String key : keys2) {\n            System.out.print(key + \"：\" + map.get(key)+\"   \");\n\n        }\n        /**\n         * 另外一种不常用的遍历方式\n         */\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\n        for (java.util.Map.Entry<String, String> entry : entrys) {\n            System.out.println(entry.getKey() + \"--\" + entry.getValue());\n        }\n        \n        /**\n         * HashMap其他常用方法\n         */\n        System.out.println(\"after map.size()：\"+map.size());\n        System.out.println(\"after map.isEmpty()：\"+map.isEmpty());\n        System.out.println(map.remove(\"san\"));\n        System.out.println(\"after map.remove()：\"+map);\n        System.out.println(\"after map.get(si)：\"+map.get(\"si\"));\n        System.out.println(\"after map.containsKey(si)：\"+map.containsKey(\"si\"));\n        System.out.println(\"after containsValue(李四)：\"+map.containsValue(\"李四\"));\n        System.out.println(map.replace(\"si\", \"李四2\"));\n        System.out.println(\"after map.replace(si, 李四2):\"+map);\n    }\n\n}\n\n```\n","source":"_posts/Java/Collection-Framework/HashMap.md","raw":"---\ntitle: Java容器——HashMap\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n- map\n- hashmap\n---\n<!-- MarkdownTOC -->\n\n- [HashMap 简介](#hashmap-简介)\n- [底层数据结构分析](#底层数据结构分析)\n  - [JDK1.8之前](#jdk18之前)\n  - [JDK1.8之后](#jdk18之后)\n- [HashMap源码分析](#hashmap源码分析)\n  - [构造方法](#构造方法)\n  - [put方法](#put方法)\n  - [get方法](#get方法)\n  - [resize方法](#resize方法)\n- [HashMap常用方法测试](#hashmap常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\n\n## HashMap 简介\nHashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 \n\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。\n\n## 底层数据结构分析\n### JDK1.8之前\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\n\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n  ```java\n      static final int hash(Object key) {\n        int h;\n        // key.hashCode()：返回散列值也就是hashcode\n        // ^ ：按位异或\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n  ```\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\n\n### JDK1.8之后\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\n\n**类的属性：**\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n}\n```\n- **loadFactor加载因子**\n\n  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n\n  **loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值**。 \n  \n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n- **threshold**\n\n  **threshold = capacity * loadFactor**，**当Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\n\n**Node节点类源码:**\n\n```java\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n**树节点类源码:**\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n```\n## HashMap源码分析\n### 构造方法\n![四个构造方法](https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&h=90&f=jpeg&s=26744)\n```java\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n     \n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);//下面会分析到这个方法\n     }\n     \n     // 指定“容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n     \n     // 指定“容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n```\n\n**putMapEntries方法：**\n\n```java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的t大于阈值，则初始化阈值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n### put方法\nHashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。\n\n**对putVal方法添加元素的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入。\n\n\n\n![put方法](https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&h=679&f=png&s=54486)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n} \n```\n\n**我们再来对比一下 JDK1.7 put方法的代码**\n\n**对于put方法的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。\n\n```java\npublic V put(K key, V value)\n    if (table == EMPTY_TABLE) { \n    inflateTable(threshold); \n}  \n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue; \n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);  // 再插入\n    return null;\n}\n```\n\n\n\n### get方法\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n### resize方法\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else { \n        // signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算新的resize上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n## HashMap常用方法测试\n```java\npackage map;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class HashMapDemo {\n\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        // 键不能重复，值可以重复\n        map.put(\"san\", \"张三\");\n        map.put(\"si\", \"李四\");\n        map.put(\"wu\", \"王五\");\n        map.put(\"wang\", \"老王\");\n        map.put(\"wang\", \"老王2\");// 老王被覆盖\n        map.put(\"lao\", \"老王\");\n        System.out.println(\"-------直接输出hashmap:-------\");\n        System.out.println(map);\n        /**\n         * 遍历HashMap\n         */\n        // 1.获取Map中的所有键\n        System.out.println(\"-------foreach获取Map中所有的键:------\");\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            System.out.print(key+\"  \");\n        }\n        System.out.println();//换行\n        // 2.获取Map中所有值\n        System.out.println(\"-------foreach获取Map中所有的值:------\");\n        Collection<String> values = map.values();\n        for (String value : values) {\n            System.out.print(value+\"  \");\n        }\n        System.out.println();//换行\n        // 3.得到key的值的同时得到key所对应的值\n        System.out.println(\"-------得到key的值的同时得到key所对应的值:-------\");\n        Set<String> keys2 = map.keySet();\n        for (String key : keys2) {\n            System.out.print(key + \"：\" + map.get(key)+\"   \");\n\n        }\n        /**\n         * 另外一种不常用的遍历方式\n         */\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\n        for (java.util.Map.Entry<String, String> entry : entrys) {\n            System.out.println(entry.getKey() + \"--\" + entry.getValue());\n        }\n        \n        /**\n         * HashMap其他常用方法\n         */\n        System.out.println(\"after map.size()：\"+map.size());\n        System.out.println(\"after map.isEmpty()：\"+map.isEmpty());\n        System.out.println(map.remove(\"san\"));\n        System.out.println(\"after map.remove()：\"+map);\n        System.out.println(\"after map.get(si)：\"+map.get(\"si\"));\n        System.out.println(\"after map.containsKey(si)：\"+map.containsKey(\"si\"));\n        System.out.println(\"after containsValue(李四)：\"+map.containsValue(\"李四\"));\n        System.out.println(map.replace(\"si\", \"李四2\"));\n        System.out.println(\"after map.replace(si, 李四2):\"+map);\n    }\n\n}\n\n```\n","slug":"Java/Collection-Framework/HashMap","published":1,"date":"2019-11-11T07:59:20.461Z","updated":"2019-11-11T07:59:20.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzre5004mlon9mdauusio","content":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#hashmap-简介\">HashMap 简介</a></li>\n<li><a href=\"#底层数据结构分析\">底层数据结构分析</a><ul>\n<li><a href=\"#jdk18之前\">JDK1.8之前</a></li>\n<li><a href=\"#jdk18之后\">JDK1.8之后</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap源码分析\">HashMap源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#put方法\">put方法</a></li>\n<li><a href=\"#get方法\">get方法</a></li>\n<li><a href=\"#resize方法\">resize方法</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap常用方法测试\">HashMap常用方法测试</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<blockquote>\n<p>感谢 <a href=\"https://github.com/changfubai\" target=\"_blank\" rel=\"noopener\">changfubai</a> 对本文的改进做出的贡献！</p>\n</blockquote>\n<h2 id=\"HashMap-简介\"><a href=\"#HashMap-简介\" class=\"headerlink\" title=\"HashMap 简介\"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 </p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<h2 id=\"底层数据结构分析\"><a href=\"#底层数据结构分析\" class=\"headerlink\" title=\"底层数据结构分析\"></a>底层数据结构分析</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class=\"line\">    <span class=\"comment\">// ^ ：按位异或</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">    <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">    <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&amp;h=427&amp;f=png&amp;s=10991\" alt=\"jdk1.8之前的内部结构\"></p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg\" alt=\"JDK1.8之后的HashMap底层数据结构\"></p>\n<p><strong>类的属性：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 序列号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    </span><br><span class=\"line\">    <span class=\"comment\">// 默认的初始容量是16</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   </span><br><span class=\"line\">    <span class=\"comment\">// 最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 默认的填充因子</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class=\"line\">    <span class=\"comment\">// 存放具体元素的集</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class=\"line\">    <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 每次扩容和更改map结构的计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   </span><br><span class=\"line\">    <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"comment\">// 加载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>loadFactor加载因子</strong></p>\n<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。 </p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li><p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node节点类源码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;<span class=\"comment\">//键</span></span><br><span class=\"line\">       V value;<span class=\"comment\">//值</span></span><br><span class=\"line\">       <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">       Node&lt;K,V&gt; next;</span><br><span class=\"line\">       Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写hashCode()方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">            V oldValue = value;</span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写 equals() 方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                    Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>树节点类源码:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 父</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;    <span class=\"comment\">// 左</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;   <span class=\"comment\">// 右</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;           <span class=\"comment\">// 判断颜色</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap源码分析\"><a href=\"#HashMap源码分析\" class=\"headerlink\" title=\"HashMap源码分析\"></a>HashMap源码分析</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&amp;h=90&amp;f=jpeg&amp;s=26744\" alt=\"四个构造方法\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造函数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all   other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 包含另一个“Map”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">     putMapEntries(m, <span class=\"keyword\">false</span>);<span class=\"comment\">//下面会分析到这个方法</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> + initialCapacity);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + loadFactor);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>putMapEntries方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断table是否已经初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// pre-size</span></span><br><span class=\"line\">            <span class=\"comment\">// 未初始化，s为m的实际元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                    (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"comment\">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"comment\">// 将m中的所有元素添加至HashMap中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对putVal方法添加元素的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&amp;h=679&amp;f=png&amp;s=54486\" alt=\"put方法\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 结点数量达到阈值，转化为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>\n<p><strong>对于put方法的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"params\">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class=\"line\">    inflateTable(threshold); </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123; <span class=\"comment\">// 先遍历</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    addEntry(hash, key, value, i);  <span class=\"comment\">// 再插入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 数组元素相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">// 桶中不止一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在树中get</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中get</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算新的resize上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ? (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把每个bucket都移动到新的buckets中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引+oldCap放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap常用方法测试\"><a href=\"#HashMap常用方法测试\" class=\"headerlink\" title=\"HashMap常用方法测试\"></a>HashMap常用方法测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 键不能重复，值可以重复</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"san\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wu\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王2\"</span>);<span class=\"comment\">// 老王被覆盖</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"lao\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------直接输出hashmap:-------\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 遍历HashMap</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 1.获取Map中的所有键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的键:------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            System.out.print(key+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取Map中所有值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的值:------\"</span>);</span><br><span class=\"line\">        Collection&lt;String&gt; values = map.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String value : values) &#123;</span><br><span class=\"line\">            System.out.print(value+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------得到key的值的同时得到key所对应的值:-------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys2) &#123;</span><br><span class=\"line\">            System.out.print(key + <span class=\"string\">\"：\"</span> + map.get(key)+<span class=\"string\">\"   \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 另外一种不常用的遍历方式</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class=\"line\">        <span class=\"comment\">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class=\"line\">        <span class=\"comment\">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class=\"line\">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"--\"</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * HashMap其他常用方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.size()：\"</span>+map.size());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.isEmpty()：\"</span>+map.isEmpty());</span><br><span class=\"line\">        System.out.println(map.remove(<span class=\"string\">\"san\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.remove()：\"</span>+map);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.get(si)：\"</span>+map.get(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.containsKey(si)：\"</span>+map.containsKey(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after containsValue(李四)：\"</span>+map.containsValue(<span class=\"string\">\"李四\"</span>));</span><br><span class=\"line\">        System.out.println(map.replace(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四2\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.replace(si, 李四2):\"</span>+map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#hashmap-简介\">HashMap 简介</a></li>\n<li><a href=\"#底层数据结构分析\">底层数据结构分析</a><ul>\n<li><a href=\"#jdk18之前\">JDK1.8之前</a></li>\n<li><a href=\"#jdk18之后\">JDK1.8之后</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap源码分析\">HashMap源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#put方法\">put方法</a></li>\n<li><a href=\"#get方法\">get方法</a></li>\n<li><a href=\"#resize方法\">resize方法</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap常用方法测试\">HashMap常用方法测试</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<blockquote>\n<p>感谢 <a href=\"https://github.com/changfubai\" target=\"_blank\" rel=\"noopener\">changfubai</a> 对本文的改进做出的贡献！</p>\n</blockquote>\n<h2 id=\"HashMap-简介\"><a href=\"#HashMap-简介\" class=\"headerlink\" title=\"HashMap 简介\"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 </p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<h2 id=\"底层数据结构分析\"><a href=\"#底层数据结构分析\" class=\"headerlink\" title=\"底层数据结构分析\"></a>底层数据结构分析</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class=\"line\">    <span class=\"comment\">// ^ ：按位异或</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">    <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">    <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&amp;h=427&amp;f=png&amp;s=10991\" alt=\"jdk1.8之前的内部结构\"></p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg\" alt=\"JDK1.8之后的HashMap底层数据结构\"></p>\n<p><strong>类的属性：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 序列号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    </span><br><span class=\"line\">    <span class=\"comment\">// 默认的初始容量是16</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   </span><br><span class=\"line\">    <span class=\"comment\">// 最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 默认的填充因子</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class=\"line\">    <span class=\"comment\">// 存放具体元素的集</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class=\"line\">    <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 每次扩容和更改map结构的计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   </span><br><span class=\"line\">    <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"comment\">// 加载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>loadFactor加载因子</strong></p>\n<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。 </p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li><p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node节点类源码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;<span class=\"comment\">//键</span></span><br><span class=\"line\">       V value;<span class=\"comment\">//值</span></span><br><span class=\"line\">       <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">       Node&lt;K,V&gt; next;</span><br><span class=\"line\">       Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写hashCode()方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">            V oldValue = value;</span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写 equals() 方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                    Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>树节点类源码:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 父</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;    <span class=\"comment\">// 左</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;   <span class=\"comment\">// 右</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;           <span class=\"comment\">// 判断颜色</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap源码分析\"><a href=\"#HashMap源码分析\" class=\"headerlink\" title=\"HashMap源码分析\"></a>HashMap源码分析</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&amp;h=90&amp;f=jpeg&amp;s=26744\" alt=\"四个构造方法\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造函数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all   other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 包含另一个“Map”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">     putMapEntries(m, <span class=\"keyword\">false</span>);<span class=\"comment\">//下面会分析到这个方法</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> + initialCapacity);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + loadFactor);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>putMapEntries方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断table是否已经初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// pre-size</span></span><br><span class=\"line\">            <span class=\"comment\">// 未初始化，s为m的实际元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                    (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"comment\">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"comment\">// 将m中的所有元素添加至HashMap中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对putVal方法添加元素的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&amp;h=679&amp;f=png&amp;s=54486\" alt=\"put方法\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 结点数量达到阈值，转化为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>\n<p><strong>对于put方法的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"params\">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class=\"line\">    inflateTable(threshold); </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123; <span class=\"comment\">// 先遍历</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    addEntry(hash, key, value, i);  <span class=\"comment\">// 再插入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 数组元素相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">// 桶中不止一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在树中get</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中get</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算新的resize上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ? (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把每个bucket都移动到新的buckets中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引+oldCap放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap常用方法测试\"><a href=\"#HashMap常用方法测试\" class=\"headerlink\" title=\"HashMap常用方法测试\"></a>HashMap常用方法测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 键不能重复，值可以重复</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"san\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wu\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王2\"</span>);<span class=\"comment\">// 老王被覆盖</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"lao\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------直接输出hashmap:-------\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 遍历HashMap</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 1.获取Map中的所有键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的键:------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            System.out.print(key+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取Map中所有值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的值:------\"</span>);</span><br><span class=\"line\">        Collection&lt;String&gt; values = map.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String value : values) &#123;</span><br><span class=\"line\">            System.out.print(value+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------得到key的值的同时得到key所对应的值:-------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys2) &#123;</span><br><span class=\"line\">            System.out.print(key + <span class=\"string\">\"：\"</span> + map.get(key)+<span class=\"string\">\"   \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 另外一种不常用的遍历方式</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class=\"line\">        <span class=\"comment\">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class=\"line\">        <span class=\"comment\">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class=\"line\">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"--\"</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * HashMap其他常用方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.size()：\"</span>+map.size());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.isEmpty()：\"</span>+map.isEmpty());</span><br><span class=\"line\">        System.out.println(map.remove(<span class=\"string\">\"san\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.remove()：\"</span>+map);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.get(si)：\"</span>+map.get(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.containsKey(si)：\"</span>+map.containsKey(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after containsValue(李四)：\"</span>+map.containsValue(<span class=\"string\">\"李四\"</span>));</span><br><span class=\"line\">        System.out.println(map.replace(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四2\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.replace(si, 李四2):\"</span>+map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java容器——ArrayList","_content":"\n## ArrayList简介\n\n　　`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 `ensureCapacity` 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\n　　它继承于 **AbstractList**，实现了 **List**, **RandomAccess**, **Cloneable**, **java.io.Serializable** 这些接口。\n　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n　　- ArrayList 实现了**RandomAccess 接口**。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n　　- ArrayList 实现了**Cloneable 接口**。即覆盖了函数 clone()，**能被克隆**。\n　　- ArrayList 实现**java.io.Serializable 接口**。这意味着ArrayList**支持序列化**，**能通过序列化去传输**。\n\n　　和 Vector 不同，**`ArrayList` 中的操作不是线程安全的！**所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 `Vector` 或者 ` CopyOnWriteArrayList`。\n　　\n\n## ArrayList核心源码\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //\n        elementData = c.toArray();\n        //如果指定集合元素个数不为0\n        if ((size = elementData.length) != 0) {\n            // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，\n            //这里用到了反射里面的getClass()方法\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 \n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。 \n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） \n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; \n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 \n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 \n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） \n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。 \n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 \n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素 \n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。 \n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。 \n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 \n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 \n     *返回的列表迭代器是fail-fast 。 \n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。 \n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。 \n     *返回的迭代器是fail-fast 。 \n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n  \n```\n### <font face=\"楷体\" id=\"1\" id=\"5\">ArrayList源码分析</font>\n####  System.arraycopy()和Arrays.copyOf()方法\n　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:\n```java \n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n又如toArray()方法中用到了copyOf()方法\n```java\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n##### 两者联系与区别\n**联系：**\n看两者源代码可以发现`copyOf()`内部调用了`System.arraycopy()`方法\n**区别：**\n\n1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n2. copyOf()是系统自动在内部新建一个数组，并返回该数组。\n#### ArrayList 核心扩容技术\n```java\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容,上面两个方法都要调用\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。\n        //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n```java\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n       //elementData为保存ArrayList数据的数组\n       ///elementData.length求数组长度elementData.size是求数组中的元素个数\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    \n```\n　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：**移位运算符**\n　　**简介**：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\"><<(左移)</font>、<font color=\"red\">>>(带符号右移)</font>和<font color=\"red\">>>>(无符号右移)</font>。\n　　**作用**：**对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源**\n　　比如这里：int newCapacity = oldCapacity + (oldCapacity >> 1);\n右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。\n\n**另外需要注意的是：**\n\n1. java 中的**length 属性**是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n\n2. java 中的**length()方法**是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.\n\n3. .java 中的**size()方法**是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n\n#### 内部类\n```java\n    (1)private class Itr implements Iterator<E>  \n    (2)private class ListItr extends Itr implements ListIterator<E>  \n    (3)private class SubList extends AbstractList<E> implements RandomAccess  \n    (4)static final class ArrayListSpliterator<E> implements Spliterator<E>  \n```\n　　ArrayList有四个内部类，其中的**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**，**next()**，**remove()**等方法；其中的**ListItr**继承**Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**，**nextIndex()**，**previousIndex()**，**previous()**，**set(E e)**，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。\n### <font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font>\n\n```java\npackage list;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class ArrayListDemo {\n\n    public static void main(String[] srgs){\n         ArrayList<Integer> arrayList = new ArrayList<Integer>();\n\n         System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size());\n\n         arrayList.add(1);\n         arrayList.add(3);\n         arrayList.add(5);\n         arrayList.add(7);\n         arrayList.add(9);\n         System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size());\n\n         System.out.println(\"Printing elements of arrayList\");\n         // 三种遍历方式打印元素\n         // 第一种：通过迭代器遍历\n         System.out.print(\"通过迭代器遍历:\");\n         Iterator<Integer> it = arrayList.iterator();\n         while(it.hasNext()){\n             System.out.print(it.next() + \" \");\n         }\n         System.out.println();\n\n         // 第二种：通过索引值遍历\n         System.out.print(\"通过索引值遍历:\");\n         for(int i = 0; i < arrayList.size(); i++){\n             System.out.print(arrayList.get(i) + \" \");\n         }\n         System.out.println();\n\n         // 第三种：for循环遍历\n         System.out.print(\"for循环遍历:\");\n         for(Integer number : arrayList){\n             System.out.print(number + \" \");\n         }\n\n         // toArray用法\n         // 第一种方式(最常用)\n         Integer[] integer = arrayList.toArray(new Integer[0]);\n\n         // 第二种方式(容易理解)\n         Integer[] integer1 = new Integer[arrayList.size()];\n         arrayList.toArray(integer1);\n\n         // 抛出异常，java不支持向下转型\n         //Integer[] integer2 = new Integer[arrayList.size()];\n         //integer2 = arrayList.toArray();\n         System.out.println();\n\n         // 在指定位置添加元素\n         arrayList.add(2,2);\n         // 删除指定位置上的元素\n         arrayList.remove(2);    \n         // 删除指定元素\n         arrayList.remove((Object)3);\n         // 判断arrayList是否包含5\n         System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5));\n\n         // 清空ArrayList\n         arrayList.clear();\n         // 判断ArrayList是否为空\n         System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty());\n    }\n}\n```\n\n","source":"_posts/Java/Collection-Framework/ArrayList.md","raw":"---\ntitle: Java容器——ArrayList\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n  - array-list\n---\n\n## ArrayList简介\n\n　　`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 `ensureCapacity` 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\n　　它继承于 **AbstractList**，实现了 **List**, **RandomAccess**, **Cloneable**, **java.io.Serializable** 这些接口。\n　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n　　- ArrayList 实现了**RandomAccess 接口**。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n　　- ArrayList 实现了**Cloneable 接口**。即覆盖了函数 clone()，**能被克隆**。\n　　- ArrayList 实现**java.io.Serializable 接口**。这意味着ArrayList**支持序列化**，**能通过序列化去传输**。\n\n　　和 Vector 不同，**`ArrayList` 中的操作不是线程安全的！**所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 `Vector` 或者 ` CopyOnWriteArrayList`。\n　　\n\n## ArrayList核心源码\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //\n        elementData = c.toArray();\n        //如果指定集合元素个数不为0\n        if ((size = elementData.length) != 0) {\n            // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，\n            //这里用到了反射里面的getClass()方法\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 \n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。 \n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） \n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; \n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 \n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 \n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） \n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。 \n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 \n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素 \n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。 \n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。 \n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 \n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 \n     *返回的列表迭代器是fail-fast 。 \n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。 \n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。 \n     *返回的迭代器是fail-fast 。 \n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n  \n```\n### <font face=\"楷体\" id=\"1\" id=\"5\">ArrayList源码分析</font>\n####  System.arraycopy()和Arrays.copyOf()方法\n　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:\n```java \n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n又如toArray()方法中用到了copyOf()方法\n```java\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n##### 两者联系与区别\n**联系：**\n看两者源代码可以发现`copyOf()`内部调用了`System.arraycopy()`方法\n**区别：**\n\n1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n2. copyOf()是系统自动在内部新建一个数组，并返回该数组。\n#### ArrayList 核心扩容技术\n```java\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容,上面两个方法都要调用\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。\n        //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n```java\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n       //elementData为保存ArrayList数据的数组\n       ///elementData.length求数组长度elementData.size是求数组中的元素个数\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    \n```\n　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：**移位运算符**\n　　**简介**：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\"><<(左移)</font>、<font color=\"red\">>>(带符号右移)</font>和<font color=\"red\">>>>(无符号右移)</font>。\n　　**作用**：**对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源**\n　　比如这里：int newCapacity = oldCapacity + (oldCapacity >> 1);\n右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。\n\n**另外需要注意的是：**\n\n1. java 中的**length 属性**是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n\n2. java 中的**length()方法**是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.\n\n3. .java 中的**size()方法**是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n\n#### 内部类\n```java\n    (1)private class Itr implements Iterator<E>  \n    (2)private class ListItr extends Itr implements ListIterator<E>  \n    (3)private class SubList extends AbstractList<E> implements RandomAccess  \n    (4)static final class ArrayListSpliterator<E> implements Spliterator<E>  \n```\n　　ArrayList有四个内部类，其中的**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**，**next()**，**remove()**等方法；其中的**ListItr**继承**Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**，**nextIndex()**，**previousIndex()**，**previous()**，**set(E e)**，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。\n### <font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font>\n\n```java\npackage list;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class ArrayListDemo {\n\n    public static void main(String[] srgs){\n         ArrayList<Integer> arrayList = new ArrayList<Integer>();\n\n         System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size());\n\n         arrayList.add(1);\n         arrayList.add(3);\n         arrayList.add(5);\n         arrayList.add(7);\n         arrayList.add(9);\n         System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size());\n\n         System.out.println(\"Printing elements of arrayList\");\n         // 三种遍历方式打印元素\n         // 第一种：通过迭代器遍历\n         System.out.print(\"通过迭代器遍历:\");\n         Iterator<Integer> it = arrayList.iterator();\n         while(it.hasNext()){\n             System.out.print(it.next() + \" \");\n         }\n         System.out.println();\n\n         // 第二种：通过索引值遍历\n         System.out.print(\"通过索引值遍历:\");\n         for(int i = 0; i < arrayList.size(); i++){\n             System.out.print(arrayList.get(i) + \" \");\n         }\n         System.out.println();\n\n         // 第三种：for循环遍历\n         System.out.print(\"for循环遍历:\");\n         for(Integer number : arrayList){\n             System.out.print(number + \" \");\n         }\n\n         // toArray用法\n         // 第一种方式(最常用)\n         Integer[] integer = arrayList.toArray(new Integer[0]);\n\n         // 第二种方式(容易理解)\n         Integer[] integer1 = new Integer[arrayList.size()];\n         arrayList.toArray(integer1);\n\n         // 抛出异常，java不支持向下转型\n         //Integer[] integer2 = new Integer[arrayList.size()];\n         //integer2 = arrayList.toArray();\n         System.out.println();\n\n         // 在指定位置添加元素\n         arrayList.add(2,2);\n         // 删除指定位置上的元素\n         arrayList.remove(2);    \n         // 删除指定元素\n         arrayList.remove((Object)3);\n         // 判断arrayList是否包含5\n         System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5));\n\n         // 清空ArrayList\n         arrayList.clear();\n         // 判断ArrayList是否为空\n         System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty());\n    }\n}\n```\n\n","slug":"Java/Collection-Framework/ArrayList","published":1,"date":"2019-11-11T07:59:20.460Z","updated":"2019-11-11T07:59:20.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3mrzre7004wlon9u1yf9yj3","content":"<h2 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h2><p>　　<code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>　　它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。<br>　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>　　- ArrayList 实现了<strong>RandomAccess 接口</strong>。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。<br>　　- ArrayList 实现了<strong>Cloneable 接口</strong>。即覆盖了函数 clone()，<strong>能被克隆</strong>。<br>　　- ArrayList 实现<strong>java.io.Serializable 接口</strong>。这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>\n<p>　　和 Vector 不同，<strong><code>ArrayList</code> 中的操作不是线程安全的！</strong>所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 <code>Vector</code> 或者 <code>CopyOnWriteArrayList</code>。\n　　</p>\n<h2 id=\"ArrayList核心源码\"><a href=\"#ArrayList核心源码\" class=\"headerlink\" title=\"ArrayList核心源码\"></a>ArrayList核心源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.UnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">      <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果指定集合元素个数不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class=\"line\">            <span class=\"comment\">//这里用到了反射里面的getClass()方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用空数组代替</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">              ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">              : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中的元素数。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class=\"line\"><span class=\"comment\">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">            <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">      <span class=\"comment\">//从列表中删除的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     *返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private remove method that skips bounds checking and does not</span></span><br><span class=\"line\"><span class=\"comment\">     * return the value removed.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span>+index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList源码分析\"><a href=\"#ArrayList源码分析\" class=\"headerlink\" title=\"ArrayList源码分析\"></a><font face=\"楷体\" id=\"1\">ArrayList源码分析</font></h3><h4 id=\"System-arraycopy-和Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy()和Arrays.copyOf()方法\"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又如toArray()方法中用到了copyOf()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\"> *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\"> *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"><span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两者联系与区别\"><a href=\"#两者联系与区别\" class=\"headerlink\" title=\"两者联系与区别\"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p>\n<ol>\n<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>\n<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。<h4 id=\"ArrayList-核心扩容技术\"><a href=\"#ArrayList-核心扩容技术\" class=\"headerlink\" title=\"ArrayList 核心扩容技术\"></a>ArrayList 核心扩容技术</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class=\"line\">        <span class=\"comment\">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//elementData为保存ArrayList数据的数组</span></span><br><span class=\"line\">   <span class=\"comment\">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">    <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\">&lt;&lt;(左移)</font>、<font color=\"red\">&gt;&gt;(带符号右移)</font>和<font color=\"red\">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p>\n<p><strong>另外需要注意的是：</strong></p>\n<ol>\n<li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p>\n</li>\n<li><p>java 中的<strong>length()方法</strong>是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p>\n</li>\n<li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>\n</li>\n</ol>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(3)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>  </span></span><br><span class=\"line\"><span class=\"class\">(4)<span class=\"title\">static</span> <span class=\"title\">final</span> <span class=\"title\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>　　ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>\n<h3 id=\"ArrayList经典Demo\"><a href=\"#ArrayList经典Demo\" class=\"headerlink\" title=\" ArrayList经典Demo\"></a><font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span></span>&#123;</span><br><span class=\"line\">         ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"Before add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">7</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">9</span>);</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"After add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"Printing elements of arrayList\"</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 三种遍历方式打印元素</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种：通过迭代器遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class=\"line\">         <span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">             System.out.print(it.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种：通过索引值遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过索引值遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class=\"line\">             System.out.print(arrayList.get(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第三种：for循环遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"for循环遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(Integer number : arrayList)&#123;</span><br><span class=\"line\">             System.out.print(number + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// toArray用法</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种方式(最常用)</span></span><br><span class=\"line\">         Integer[] integer = arrayList.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种方式(容易理解)</span></span><br><span class=\"line\">         Integer[] integer1 = <span class=\"keyword\">new</span> Integer[arrayList.size()];</span><br><span class=\"line\">         arrayList.toArray(integer1);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 抛出异常，java不支持向下转型</span></span><br><span class=\"line\">         <span class=\"comment\">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class=\"line\">         <span class=\"comment\">//integer2 = arrayList.toArray();</span></span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 删除指定位置上的元素</span></span><br><span class=\"line\">         arrayList.remove(<span class=\"number\">2</span>);    </span><br><span class=\"line\">         <span class=\"comment\">// 删除指定元素</span></span><br><span class=\"line\">         arrayList.remove((Object)<span class=\"number\">3</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 判断arrayList是否包含5</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList contains 5 is: \"</span> + arrayList.contains(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 清空ArrayList</span></span><br><span class=\"line\">         arrayList.clear();</span><br><span class=\"line\">         <span class=\"comment\">// 判断ArrayList是否为空</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList is empty: \"</span> + arrayList.isEmpty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h2><p>　　<code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>　　它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。<br>　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>　　- ArrayList 实现了<strong>RandomAccess 接口</strong>。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。<br>　　- ArrayList 实现了<strong>Cloneable 接口</strong>。即覆盖了函数 clone()，<strong>能被克隆</strong>。<br>　　- ArrayList 实现<strong>java.io.Serializable 接口</strong>。这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>\n<p>　　和 Vector 不同，<strong><code>ArrayList</code> 中的操作不是线程安全的！</strong>所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 <code>Vector</code> 或者 <code>CopyOnWriteArrayList</code>。\n　　</p>\n<h2 id=\"ArrayList核心源码\"><a href=\"#ArrayList核心源码\" class=\"headerlink\" title=\"ArrayList核心源码\"></a>ArrayList核心源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.UnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">      <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果指定集合元素个数不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class=\"line\">            <span class=\"comment\">//这里用到了反射里面的getClass()方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用空数组代替</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">              ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">              : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中的元素数。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class=\"line\"><span class=\"comment\">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">            <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">      <span class=\"comment\">//从列表中删除的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     *返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private remove method that skips bounds checking and does not</span></span><br><span class=\"line\"><span class=\"comment\">     * return the value removed.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span>+index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList源码分析\"><a href=\"#ArrayList源码分析\" class=\"headerlink\" title=\"ArrayList源码分析\"></a><font face=\"楷体\" id=\"1\">ArrayList源码分析</font></h3><h4 id=\"System-arraycopy-和Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy()和Arrays.copyOf()方法\"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又如toArray()方法中用到了copyOf()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\"> *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\"> *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"><span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两者联系与区别\"><a href=\"#两者联系与区别\" class=\"headerlink\" title=\"两者联系与区别\"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p>\n<ol>\n<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>\n<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。<h4 id=\"ArrayList-核心扩容技术\"><a href=\"#ArrayList-核心扩容技术\" class=\"headerlink\" title=\"ArrayList 核心扩容技术\"></a>ArrayList 核心扩容技术</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class=\"line\">        <span class=\"comment\">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//elementData为保存ArrayList数据的数组</span></span><br><span class=\"line\">   <span class=\"comment\">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">    <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\">&lt;&lt;(左移)</font>、<font color=\"red\">&gt;&gt;(带符号右移)</font>和<font color=\"red\">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p>\n<p><strong>另外需要注意的是：</strong></p>\n<ol>\n<li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p>\n</li>\n<li><p>java 中的<strong>length()方法</strong>是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p>\n</li>\n<li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>\n</li>\n</ol>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(3)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>  </span></span><br><span class=\"line\"><span class=\"class\">(4)<span class=\"title\">static</span> <span class=\"title\">final</span> <span class=\"title\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>　　ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>\n<h3 id=\"ArrayList经典Demo\"><a href=\"#ArrayList经典Demo\" class=\"headerlink\" title=\" ArrayList经典Demo\"></a><font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span></span>&#123;</span><br><span class=\"line\">         ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"Before add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">7</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">9</span>);</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"After add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"Printing elements of arrayList\"</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 三种遍历方式打印元素</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种：通过迭代器遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class=\"line\">         <span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">             System.out.print(it.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种：通过索引值遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过索引值遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class=\"line\">             System.out.print(arrayList.get(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第三种：for循环遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"for循环遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(Integer number : arrayList)&#123;</span><br><span class=\"line\">             System.out.print(number + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// toArray用法</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种方式(最常用)</span></span><br><span class=\"line\">         Integer[] integer = arrayList.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种方式(容易理解)</span></span><br><span class=\"line\">         Integer[] integer1 = <span class=\"keyword\">new</span> Integer[arrayList.size()];</span><br><span class=\"line\">         arrayList.toArray(integer1);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 抛出异常，java不支持向下转型</span></span><br><span class=\"line\">         <span class=\"comment\">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class=\"line\">         <span class=\"comment\">//integer2 = arrayList.toArray();</span></span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 删除指定位置上的元素</span></span><br><span class=\"line\">         arrayList.remove(<span class=\"number\">2</span>);    </span><br><span class=\"line\">         <span class=\"comment\">// 删除指定元素</span></span><br><span class=\"line\">         arrayList.remove((Object)<span class=\"number\">3</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 判断arrayList是否包含5</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList contains 5 is: \"</span> + arrayList.contains(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 清空ArrayList</span></span><br><span class=\"line\">         arrayList.clear();</span><br><span class=\"line\">         <span class=\"comment\">// 判断ArrayList是否为空</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList is empty: \"</span> + arrayList.isEmpty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck3mrzrb90000lon9dtgopunz","category_id":"ck3mrzrbj0004lon9an6mpyzd","_id":"ck3mrzrbu000glon9mwgshgqn"},{"post_id":"ck3mrzrbh0002lon9inqib3st","category_id":"ck3mrzrbj0004lon9an6mpyzd","_id":"ck3mrzrbw000klon9063q7hpl"},{"post_id":"ck3mrzrcq000slon9wrw5afl6","category_id":"ck3mrzrbj0004lon9an6mpyzd","_id":"ck3mrzrcs000wlon9dluz5yv2"},{"post_id":"ck3mrzrcs000ulon9l11ikalk","category_id":"ck3mrzrcs000vlon9vkqqn9oc","_id":"ck3mrzrct0010lon9unxniipt"},{"post_id":"ck3mrzrcw0019lon925joueud","category_id":"ck3mrzrcs000vlon9vkqqn9oc","_id":"ck3mrzrcw001blon98osdb6qe"},{"post_id":"ck3mrzrd5001dlon9bsi1vtfa","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdi0020lon9xfatkvom"},{"post_id":"ck3mrzrd5001dlon9bsi1vtfa","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdi0022lon9xsizdvk9"},{"post_id":"ck3mrzrdc001jlon9sf6q37t8","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdj0025lon9x3u53ke8"},{"post_id":"ck3mrzrdc001jlon9sf6q37t8","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdj0028lon95a6ucbli"},{"post_id":"ck3mrzrdd001mlon9icd3kt12","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdj002alon9uj79x0ol"},{"post_id":"ck3mrzrdd001mlon9icd3kt12","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdk002dlon9x8a9a9h0"},{"post_id":"ck3mrzrd9001elon9f8tlmiaf","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdk002glon94krg96dm"},{"post_id":"ck3mrzrd9001elon9f8tlmiaf","category_id":"ck3mrzrdj0024lon9s3vk4ehk","_id":"ck3mrzrdk002jlon9f1dzwc3r"},{"post_id":"ck3mrzrde001nlon94vxp5vkg","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdl002llon9venmpsyu"},{"post_id":"ck3mrzrde001nlon94vxp5vkg","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdm002mlon96ztn43pm"},{"post_id":"ck3mrzrdf001qlon94sitv4ih","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdn002qlon947hi2g99"},{"post_id":"ck3mrzrdf001qlon94sitv4ih","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdn002slon9gttt8kwx"},{"post_id":"ck3mrzrdb001hlon9vwkdm6ha","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdo002wlon9dvjfe2ir"},{"post_id":"ck3mrzrdb001hlon9vwkdm6ha","category_id":"ck3mrzrdj0024lon9s3vk4ehk","_id":"ck3mrzrdo002ylon91klnx4p8"},{"post_id":"ck3mrzrdg001slon9x5502i98","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdp0031lon9sz085mes"},{"post_id":"ck3mrzrdg001slon9x5502i98","category_id":"ck3mrzrdg001tlon9484x1pd1","_id":"ck3mrzrdp0033lon91odt6dxn"},{"post_id":"ck3mrzrdh001wlon9nqbz605i","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzrdq003blon9ph32t2h5"},{"post_id":"ck3mrzrdh001wlon9nqbz605i","category_id":"ck3mrzrdp0034lon92lmoltjr","_id":"ck3mrzrdr003dlon9rfsfbigf"},{"post_id":"ck3mrzrds003flon9mrm0c3yu","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdv003llon9aa2jy9la"},{"post_id":"ck3mrzrds003flon9mrm0c3yu","category_id":"ck3mrzrdj0024lon9s3vk4ehk","_id":"ck3mrzrdx003qlon9zd9ycakr"},{"post_id":"ck3mrzrdt003glon9xsfl44k0","category_id":"ck3mrzrda001flon9b12isibc","_id":"ck3mrzrdy003tlon9ez0x9382"},{"post_id":"ck3mrzrdt003glon9xsfl44k0","category_id":"ck3mrzrdj0024lon9s3vk4ehk","_id":"ck3mrzre0003xlon9geha997i"},{"post_id":"ck3mrzrdu003ilon961a7nj0k","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre0003zlon9d5wtc206"},{"post_id":"ck3mrzrdu003ilon961a7nj0k","category_id":"ck3mrzrdw003plon9yjosylz2","_id":"ck3mrzre00043lon9iq96r4xu"},{"post_id":"ck3mrzrdv003klon9w39ijja9","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre10044lon96uvacx65"},{"post_id":"ck3mrzrdv003klon9w39ijja9","category_id":"ck3mrzrdz003wlon9pw1h5xcr","_id":"ck3mrzre10047lon9o4pzp516"},{"post_id":"ck3mrzrdw003olon94glqmp3m","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre10049lon9y60aegp5"},{"post_id":"ck3mrzrdw003olon94glqmp3m","category_id":"ck3mrzre00041lon94sml7bbi","_id":"ck3mrzre2004clon93n3ef2mc"},{"post_id":"ck3mrzrdy003slon9rb4egxy7","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre2004elon9o9lzyi08"},{"post_id":"ck3mrzrdy003slon9rb4egxy7","category_id":"ck3mrzrdz003wlon9pw1h5xcr","_id":"ck3mrzre2004hlon95sb3876f"},{"post_id":"ck3mrzrdz003ulon9f7ao6j52","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre2004ilon9e3l8d1m4"},{"post_id":"ck3mrzrdz003ulon9f7ao6j52","category_id":"ck3mrzrdz003wlon9pw1h5xcr","_id":"ck3mrzre3004klon9tt1vop0f"},{"post_id":"ck3mrzre5004llon9enuioxnw","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre6004plon9x79ly9br"},{"post_id":"ck3mrzre5004llon9enuioxnw","category_id":"ck3mrzrdw003plon9yjosylz2","_id":"ck3mrzre6004qlon9wyi4beum"},{"post_id":"ck3mrzre5004mlon9mdauusio","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre6004slon96o06n9e3"},{"post_id":"ck3mrzre5004mlon9mdauusio","category_id":"ck3mrzrdw003plon9yjosylz2","_id":"ck3mrzre6004tlon93q9ryps6"},{"post_id":"ck3mrzre7004wlon9u1yf9yj3","category_id":"ck3mrzrdo002vlon98gnhmlu0","_id":"ck3mrzre8004ylon94118la1d"},{"post_id":"ck3mrzre7004wlon9u1yf9yj3","category_id":"ck3mrzrdw003plon9yjosylz2","_id":"ck3mrzre9004zlon9jok3s9e3"}],"PostTag":[{"post_id":"ck3mrzrb90000lon9dtgopunz","tag_id":"ck3mrzrbk0005lon9rhda6o2r","_id":"ck3mrzrbr000dlon98coy9pxr"},{"post_id":"ck3mrzrbh0002lon9inqib3st","tag_id":"ck3mrzrbp000clon9v77qb5wx","_id":"ck3mrzrbx000mlon9i0wbtc7c"},{"post_id":"ck3mrzrbh0002lon9inqib3st","tag_id":"ck3mrzrbu000hlon90mkg1f6f","_id":"ck3mrzrbx000nlon9rosgnc0h"},{"post_id":"ck3mrzrc7000olon98wxddi5j","tag_id":"ck3mrzrc8000plon9rlgcgj8b","_id":"ck3mrzrc9000qlon96ec1qydz"},{"post_id":"ck3mrzrcp000rlon9ighrnxn9","tag_id":"ck3mrzrcr000tlon982iuz2sj","_id":"ck3mrzrct000ylon9sezhn2vr"},{"post_id":"ck3mrzrcq000slon9wrw5afl6","tag_id":"ck3mrzrcs000xlon9znlgdhsx","_id":"ck3mrzrct0013lon9dav7kxb9"},{"post_id":"ck3mrzrcq000slon9wrw5afl6","tag_id":"ck3mrzrct000zlon9z58nqrka","_id":"ck3mrzrct0014lon9tfvs1zqn"},{"post_id":"ck3mrzrcq000slon9wrw5afl6","tag_id":"ck3mrzrct0011lon9xijyzh7x","_id":"ck3mrzrcu0016lon9zbl16geu"},{"post_id":"ck3mrzrcs000ulon9l11ikalk","tag_id":"ck3mrzrct0012lon9l9rfcxog","_id":"ck3mrzrcu0017lon9m5ki8w9q"},{"post_id":"ck3mrzrcs000ulon9l11ikalk","tag_id":"ck3mrzrct0011lon9xijyzh7x","_id":"ck3mrzrcu0018lon9vmv3z1o6"},{"post_id":"ck3mrzrcw0019lon925joueud","tag_id":"ck3mrzrcw001alon9nwc87irf","_id":"ck3mrzrcw001clon9es6b5egr"},{"post_id":"ck3mrzrd5001dlon9bsi1vtfa","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdf001rlon9brw5d15h"},{"post_id":"ck3mrzrd5001dlon9bsi1vtfa","tag_id":"ck3mrzrdd001llon9532rvfnj","_id":"ck3mrzrdg001ulon92vpxzaaa"},{"post_id":"ck3mrzrd9001elon9f8tlmiaf","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdi0023lon934b1gef8"},{"post_id":"ck3mrzrd9001elon9f8tlmiaf","tag_id":"ck3mrzrdg001vlon9pksylz7r","_id":"ck3mrzrdj0026lon9m9w4n6g9"},{"post_id":"ck3mrzrd9001elon9f8tlmiaf","tag_id":"ck3mrzrdi001ylon9jqzwdeso","_id":"ck3mrzrdj0029lon9wbbgl3nv"},{"post_id":"ck3mrzrdb001hlon9vwkdm6ha","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdk002elon9ipcykdua"},{"post_id":"ck3mrzrdb001hlon9vwkdm6ha","tag_id":"ck3mrzrdj0027lon9n5ksqgxj","_id":"ck3mrzrdk002hlon9a4n3gdwa"},{"post_id":"ck3mrzrdc001jlon9sf6q37t8","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdm002olon9f3jt1o0w"},{"post_id":"ck3mrzrdc001jlon9sf6q37t8","tag_id":"ck3mrzrdk002clon92b2lhifz","_id":"ck3mrzrdn002rlon9hwo1x1ul"},{"post_id":"ck3mrzrdc001jlon9sf6q37t8","tag_id":"ck3mrzrdk002ilon9g5w7vg2t","_id":"ck3mrzrdo002ulon9osct40f2"},{"post_id":"ck3mrzrdd001mlon9icd3kt12","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdo002xlon9eb9k7rj5"},{"post_id":"ck3mrzrdd001mlon9icd3kt12","tag_id":"ck3mrzrdm002nlon9s5xiti3e","_id":"ck3mrzrdp0030lon97p6ci7yb"},{"post_id":"ck3mrzrde001nlon94vxp5vkg","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdp0032lon9iynm8epg"},{"post_id":"ck3mrzrde001nlon94vxp5vkg","tag_id":"ck3mrzrdn002tlon9ob3n9fn3","_id":"ck3mrzrdp0036lon9n3bosb4c"},{"post_id":"ck3mrzrdf001qlon94sitv4ih","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdp0037lon9s793w5qp"},{"post_id":"ck3mrzrdf001qlon94sitv4ih","tag_id":"ck3mrzrdo002zlon94ue0r87a","_id":"ck3mrzrdp0038lon9a5ofswxk"},{"post_id":"ck3mrzrdg001slon9x5502i98","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdq003alon9aop7egp8"},{"post_id":"ck3mrzrdg001slon9x5502i98","tag_id":"ck3mrzrdp0035lon9o8vpyns8","_id":"ck3mrzrdr003clon9qtsi9mil"},{"post_id":"ck3mrzrdh001wlon9nqbz605i","tag_id":"ck3mrzrdq0039lon93izfl4ei","_id":"ck3mrzrdr003elon9zy0b08u6"},{"post_id":"ck3mrzrds003flon9mrm0c3yu","tag_id":"ck3mrzrda001glon99igqbm6o","_id":"ck3mrzrdu003hlon9fj546bgz"},{"post_id":"ck3mrzrds003flon9mrm0c3yu","tag_id":"ck3mrzrdj0027lon9n5ksqgxj","_id":"ck3mrzrdv003jlon9mdgp9vw8"},{"post_id":"ck3mrzrdt003glon9xsfl44k0","tag_id":"ck3mrzrdg001vlon9pksylz7r","_id":"ck3mrzrdw003nlon9rs7bd144"},{"post_id":"ck3mrzrdt003glon9xsfl44k0","tag_id":"ck3mrzrdi001ylon9jqzwdeso","_id":"ck3mrzrdy003rlon93ndwi8qc"},{"post_id":"ck3mrzrdu003ilon961a7nj0k","tag_id":"ck3mrzrdw003mlon9cfaeact7","_id":"ck3mrzre0003ylon9sdcsa4fc"},{"post_id":"ck3mrzrdv003klon9w39ijja9","tag_id":"ck3mrzrdz003vlon9tt4g8sx8","_id":"ck3mrzre00042lon9y5526jag"},{"post_id":"ck3mrzrdw003olon94glqmp3m","tag_id":"ck3mrzre00040lon96acil9x4","_id":"ck3mrzre2004blon96wb5jnq3"},{"post_id":"ck3mrzrdw003olon94glqmp3m","tag_id":"ck3mrzre10045lon9qld44bfy","_id":"ck3mrzre2004dlon91tmf5zr0"},{"post_id":"ck3mrzrdy003slon9rb4egxy7","tag_id":"ck3mrzrdz003vlon9tt4g8sx8","_id":"ck3mrzre2004glon961hilf94"},{"post_id":"ck3mrzrdz003ulon9f7ao6j52","tag_id":"ck3mrzrdz003vlon9tt4g8sx8","_id":"ck3mrzre3004jlon9t9fkpl55"},{"post_id":"ck3mrzre5004llon9enuioxnw","tag_id":"ck3mrzrdn002tlon9ob3n9fn3","_id":"ck3mrzre6004nlon9gch69x9c"},{"post_id":"ck3mrzre5004mlon9mdauusio","tag_id":"ck3mrzre6004olon9lxm8rgrt","_id":"ck3mrzre7004ulon9wg1jw8xd"},{"post_id":"ck3mrzre5004mlon9mdauusio","tag_id":"ck3mrzre6004rlon9eomxrqtx","_id":"ck3mrzre7004vlon9jzuv5zr6"},{"post_id":"ck3mrzre7004wlon9u1yf9yj3","tag_id":"ck3mrzrdw003mlon9cfaeact7","_id":"ck3mrzre8004xlon9q3ngfm15"}],"Tag":[{"name":"gitlab","_id":"ck3mrzrbk0005lon9rhda6o2r"},{"name":"automation","_id":"ck3mrzrbp000clon9v77qb5wx"},{"name":"tool","_id":"ck3mrzrbu000hlon90mkg1f6f"},{"name":"docker","_id":"ck3mrzrc8000plon9rlgcgj8b"},{"name":"http","_id":"ck3mrzrcr000tlon982iuz2sj"},{"name":"jenkins","_id":"ck3mrzrcs000xlon9znlgdhsx"},{"name":"testlink","_id":"ck3mrzrct000zlon9z58nqrka"},{"name":"plugin","_id":"ck3mrzrct0011lon9xijyzh7x"},{"name":"vscode","_id":"ck3mrzrct0012lon9l9rfcxog"},{"name":"tools","_id":"ck3mrzrcw001alon9nwc87irf"},{"name":"algorithm","_id":"ck3mrzrda001glon99igqbm6o"},{"name":"array","_id":"ck3mrzrdd001llon9532rvfnj"},{"name":"graph","_id":"ck3mrzrdg001vlon9pksylz7r"},{"name":"topological-sort","_id":"ck3mrzrdi001ylon9jqzwdeso"},{"name":"tree","_id":"ck3mrzrdj0027lon9n5ksqgxj"},{"name":"queue","_id":"ck3mrzrdk002clon92b2lhifz"},{"name":"stack","_id":"ck3mrzrdk002ilon9g5w7vg2t"},{"name":"search","_id":"ck3mrzrdm002nlon9s5xiti3e"},{"name":"linked-list","_id":"ck3mrzrdn002tlon9ob3n9fn3"},{"name":"binary-tree","_id":"ck3mrzrdo002zlon94ue0r87a"},{"name":"string","_id":"ck3mrzrdp0035lon9o8vpyns8"},{"name":"jvm","_id":"ck3mrzrdq0039lon93izfl4ei"},{"name":"array-list","_id":"ck3mrzrdw003mlon9cfaeact7"},{"name":"interview-questions","_id":"ck3mrzrdz003vlon9tt4g8sx8"},{"name":"multithread","_id":"ck3mrzre00040lon96acil9x4"},{"name":"interview","_id":"ck3mrzre10045lon9qld44bfy"},{"name":"map","_id":"ck3mrzre6004olon9lxm8rgrt"},{"name":"hashmap","_id":"ck3mrzre6004rlon9eomxrqtx"}]}}