{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next-reload/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"862ac869a305ae6375ff7b23e2463d0bbfc8bf8a","modified":1554004057107},{"_id":"themes/next-reload/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1572418450394},{"_id":"themes/next-reload/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1572418450397},{"_id":"themes/next-reload/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1572418450394},{"_id":"themes/next-reload/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1572418450397},{"_id":"themes/next-reload/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1572418450394},{"_id":"themes/next-reload/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1572418450397},{"_id":"themes/next-reload/README.md","hash":"a0430372844df9caea6e9bf96492775ed42a4578","modified":1572418450397},{"_id":"themes/next-reload/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1572418450397},{"_id":"themes/next-reload/_config.yml","hash":"180f9d28a413a8f85719b938e1d67cc38c29734b","modified":1572419491256},{"_id":"themes/next-reload/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1572418450397},{"_id":"themes/next-reload/package.json","hash":"5e218373ff6e676a54fe5f903a04e49324029908","modified":1572418450425},{"_id":"themes/next-reload/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1572418450401},{"_id":"source/_posts/.DS_Store","hash":"ba9cc4b0a74906e227ba18b9dabc1cfd18c4064f","modified":1569307682427},{"_id":"source/categories/index.md","hash":"200f34213008250f19919bc2d0ce126405682719","modified":1553348755323},{"_id":"source/tags/index.md","hash":"c6dcf4c6f71e8b9397dfd859d6d7c37e71c6aa3a","modified":1553348766706},{"_id":"themes/next-reload/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1572418450386},{"_id":"themes/next-reload/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1572418450389},{"_id":"themes/next-reload/.git/packed-refs","hash":"21eef4c083dc24e2f0f2289f3fefdc97e752e9b1","modified":1572418450383},{"_id":"themes/next-reload/.git/index","hash":"897c6f186473c608b0b572fb090775d79b725b69","modified":1572418949895},{"_id":"themes/next-reload/.github/CONTRIBUTING.md","hash":"0928b4db7eabac1e41c82e297f16f217774bea25","modified":1572418450394},{"_id":"themes/next-reload/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1572418450394},{"_id":"themes/next-reload/.github/PULL_REQUEST_TEMPLATE.md","hash":"2a4ff75ccb91d9001032c08e22489096b850bf4f","modified":1572418450395},{"_id":"themes/next-reload/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1572418450395},{"_id":"themes/next-reload/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1572418450396},{"_id":"themes/next-reload/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1572418450396},{"_id":"themes/next-reload/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1572418450396},{"_id":"themes/next-reload/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1572418450396},{"_id":"themes/next-reload/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1572418450396},{"_id":"themes/next-reload/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1572418450396},{"_id":"themes/next-reload/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1572418450396},{"_id":"themes/next-reload/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1572418450396},{"_id":"themes/next-reload/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1572418450398},{"_id":"themes/next-reload/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1572418450398},{"_id":"themes/next-reload/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1572418450398},{"_id":"themes/next-reload/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1572418450398},{"_id":"themes/next-reload/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1572418450398},{"_id":"themes/next-reload/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1572418450399},{"_id":"themes/next-reload/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1572418450399},{"_id":"themes/next-reload/docs/MATH.md","hash":"58a961498c55cf4f0c69cf3668c810b602a17529","modified":1572418450399},{"_id":"themes/next-reload/docs/UPDATE-FROM-5.1.X.md","hash":"199e9ef3cb5928af0fe801d03d2d1aeea704cea4","modified":1572418450399},{"_id":"themes/next-reload/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1572418450429},{"_id":"themes/next-reload/layout/_layout.swig","hash":"512bdf6787b5d9fb1d40b126b0fa8e6f1018d1cd","modified":1572418450412},{"_id":"themes/next-reload/layout/archive.swig","hash":"59155648f6306888077d1f1d635f63177b36148d","modified":1572418450423},{"_id":"themes/next-reload/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1572418450423},{"_id":"themes/next-reload/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1572418450424},{"_id":"themes/next-reload/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1572418450424},{"_id":"themes/next-reload/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1572418450424},{"_id":"themes/next-reload/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1572418450425},{"_id":"themes/next-reload/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1572418450403},{"_id":"themes/next-reload/languages/default.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1572418450403},{"_id":"themes/next-reload/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1572418450403},{"_id":"themes/next-reload/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1572418450403},{"_id":"themes/next-reload/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1572418450403},{"_id":"themes/next-reload/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1572418450404},{"_id":"themes/next-reload/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1572418450405},{"_id":"themes/next-reload/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1572418450406},{"_id":"themes/next-reload/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1572418450408},{"_id":"themes/next-reload/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1572418450407},{"_id":"themes/next-reload/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1572418450409},{"_id":"themes/next-reload/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1572418450406},{"_id":"themes/next-reload/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1572418450410},{"_id":"themes/next-reload/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1572418450410},{"_id":"themes/next-reload/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1572418450411},{"_id":"themes/next-reload/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1572418450410},{"_id":"themes/next-reload/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1572418450410},{"_id":"themes/next-reload/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1572418450411},{"_id":"themes/next-reload/languages/zh-CN.yml","hash":"e92e1e07a89c9fab27f445f9ec0fa35049fef38c","modified":1572418450411},{"_id":"themes/next-reload/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1572418450411},{"_id":"themes/next-reload/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1572418450411},{"_id":"source/_posts/Algorithm/.DS_Store","hash":"e630ff67ca71de8f56f9000a074d14636ad93695","modified":1553312290172},{"_id":"source/_posts/Android/button-mutex-demo.md","hash":"79893ef83a04684002a3ce5a9e23c5e5f3c37806","modified":1553260639525},{"_id":"source/_posts/DevOps/jenkins-testlink-plugin-source-code-note.md","hash":"d39ed477d0026a629f24d7cf66a4a981321e1376","modified":1569727285915},{"_id":"source/_posts/Git/introduce-git.md","hash":"b647359f8485033983af81250cd3ec7f70611a03","modified":1553403290867},{"_id":"source/_posts/DevOps/serial-port-debug-env-automation.md","hash":"d4329dde1a90cdc2e1e9acf429e980cb418655ba","modified":1569307884372},{"_id":"source/_posts/Java/.DS_Store","hash":"26286303a706001edd293694f732e104f72e79f2","modified":1553402554150},{"_id":"source/_posts/Tools/vscode-plugin-dev-intro.md","hash":"34760f38123d031413a51a9252860efa3e85a9e4","modified":1569307884372},{"_id":"themes/next-reload/.git/hooks/gitshot-pc","hash":"d244916c91cfb43c3efc6c4b10266b2cfce4ecb8","modified":1572417754534},{"_id":"themes/next-reload/.git/hooks/post-commit","hash":"d244916c91cfb43c3efc6c4b10266b2cfce4ecb8","modified":1572417754533},{"_id":"themes/next-reload/.git/logs/HEAD","hash":"73cf74e2f375f7b002c3442fbbea7ca38a7f410a","modified":1572418450387},{"_id":"themes/next-reload/.github/ISSUE_TEMPLATE/bug-report.md","hash":"a0601577b77b8ad89742dc99f98edebf9cc45c10","modified":1572418450395},{"_id":"themes/next-reload/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6d79701dd0bb3757722650d9df30eeaacd83344e","modified":1572418450395},{"_id":"themes/next-reload/.github/ISSUE_TEMPLATE/other.md","hash":"bf8b10715f5529cc6997501d821307895710ba58","modified":1572418450395},{"_id":"themes/next-reload/.github/ISSUE_TEMPLATE/question.md","hash":"35a9e1469962a9a163abd0b83677a412516272ef","modified":1572418450395},{"_id":"themes/next-reload/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1572418450400},{"_id":"themes/next-reload/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"ebacdc94f6f9724a7c6ef7c3cdde41ff7c37931a","modified":1572418450400},{"_id":"themes/next-reload/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1572418450400},{"_id":"themes/next-reload/docs/zh-CN/CONTRIBUTING.md","hash":"41c06240e349a885b640c6ba4a982e3b8e7762fe","modified":1572418450400},{"_id":"themes/next-reload/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1572418450401},{"_id":"themes/next-reload/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"264d131b8865bae069f8e4d78a33a0f59d28e36b","modified":1572418450401},{"_id":"themes/next-reload/docs/zh-CN/MATH.md","hash":"c7df75363851f31ae7a3e7b93798070c5d8a3053","modified":1572418450401},{"_id":"themes/next-reload/docs/zh-CN/README.md","hash":"1766bd2e528ec148d3c5dd55e6be55449fcda94e","modified":1572418450401},{"_id":"themes/next-reload/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"8109a531d3a7f5a306e36d4304c11f0c7c180c87","modified":1572418450401},{"_id":"themes/next-reload/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1572418450399},{"_id":"themes/next-reload/scripts/events/index.js","hash":"ac2945693791e62a3046248f2a511afadcaebc16","modified":1572418450425},{"_id":"themes/next-reload/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1572418450400},{"_id":"themes/next-reload/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1572418450399},{"_id":"themes/next-reload/docs/ru/README.md","hash":"7302b2e5318c0c13e6484aa6487be29599ebc2b2","modified":1572418450400},{"_id":"themes/next-reload/scripts/filters/locals.js","hash":"ffa0e122c1cdf9c86ddca104ddb2dfbaccaa1bb5","modified":1572418450428},{"_id":"themes/next-reload/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1572418450427},{"_id":"themes/next-reload/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1572418450428},{"_id":"themes/next-reload/scripts/filters/post.js","hash":"3c1e483c2c4a1c5a2f9a99b81ce0fda5fd21926b","modified":1572418450428},{"_id":"themes/next-reload/scripts/helpers/engine.js","hash":"b357cbc5d5b39b1bb5221149e7d358135a7ba56d","modified":1572418450428},{"_id":"themes/next-reload/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1572418450429},{"_id":"themes/next-reload/scripts/helpers/next-url.js","hash":"e60e6c0aaa979d42b01685ba2a03a76fa6e059e2","modified":1572418450429},{"_id":"themes/next-reload/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1572418450430},{"_id":"themes/next-reload/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1572418450429},{"_id":"themes/next-reload/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1572418450430},{"_id":"themes/next-reload/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1572418450431},{"_id":"themes/next-reload/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1572418450433},{"_id":"themes/next-reload/scripts/tags/include-raw.js","hash":"fad54f0e9e225a70390209f63d9b3cc566a5ebcb","modified":1572418450432},{"_id":"themes/next-reload/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1572418450435},{"_id":"themes/next-reload/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1572418450434},{"_id":"themes/next-reload/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1572418450436},{"_id":"themes/next-reload/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1572418450436},{"_id":"themes/next-reload/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1572418450436},{"_id":"themes/next-reload/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1572418450463},{"_id":"themes/next-reload/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1572418450472},{"_id":"themes/next-reload/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1572418450464},{"_id":"themes/next-reload/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1572418450464},{"_id":"themes/next-reload/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1572418450464},{"_id":"themes/next-reload/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1572418450465},{"_id":"themes/next-reload/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1572418450465},{"_id":"themes/next-reload/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1572418450465},{"_id":"themes/next-reload/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1572418450466},{"_id":"themes/next-reload/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1572418450468},{"_id":"themes/next-reload/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1572418450466},{"_id":"themes/next-reload/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1572418450467},{"_id":"themes/next-reload/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1572418450469},{"_id":"themes/next-reload/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1572418450469},{"_id":"themes/next-reload/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1572418450470},{"_id":"themes/next-reload/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1572418450470},{"_id":"themes/next-reload/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1572418450470},{"_id":"themes/next-reload/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1572418450412},{"_id":"themes/next-reload/layout/_macro/sidebar.swig","hash":"1116597ae81c391981f3a8b80fa6febe5796583d","modified":1572418450412},{"_id":"themes/next-reload/source/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1572418450470},{"_id":"themes/next-reload/layout/_macro/post.swig","hash":"e80d07467dcd614e940451737f4c1eaab8c8d272","modified":1572418450412},{"_id":"themes/next-reload/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1572418450470},{"_id":"themes/next-reload/source/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1572418450471},{"_id":"themes/next-reload/source/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1572418450471},{"_id":"themes/next-reload/source/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1572418450471},{"_id":"themes/next-reload/source/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1572418450472},{"_id":"themes/next-reload/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1572418450420},{"_id":"themes/next-reload/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1572418450420},{"_id":"themes/next-reload/layout/_third-party/quicklink.swig","hash":"4abfcb5dae0e6dec5e288baa3a9fe4065829b392","modified":1572418450420},{"_id":"themes/next-reload/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1572418450416},{"_id":"themes/next-reload/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1572418450416},{"_id":"themes/next-reload/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1572418450417},{"_id":"themes/next-reload/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1572418450417},{"_id":"themes/next-reload/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1572418450417},{"_id":"themes/next-reload/layout/_partials/comments.swig","hash":"479286b378b027224c600f6bdd9ed51126086993","modified":1572418450412},{"_id":"themes/next-reload/layout/_partials/footer.swig","hash":"ee6ae67a3c7b99ee768afbd36882390b9f4db5b0","modified":1572418450413},{"_id":"themes/next-reload/layout/_partials/pagination.swig","hash":"b9d3f6534efb9e637ac46318fa07c2e5607bf830","modified":1572418450415},{"_id":"themes/next-reload/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1572418450416},{"_id":"themes/next-reload/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572418450453},{"_id":"themes/next-reload/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572418450453},{"_id":"source/_posts/Algorithm/Data-Structure/avlree-template-implement.md","hash":"8ab0e772cdb0db9e2445b8f1fec98cb30b57e752","modified":1553312285539},{"_id":"source/_posts/Algorithm/Data-Structure/isBST.md","hash":"3925beb415d83d3076ea59f9eb24bbafc0502244","modified":1553312285539},{"_id":"source/_posts/Algorithm/Data-Structure/topological-sort-all.md","hash":"adc813c7a68f4f2a801143bf7786d1d04a6b0c1c","modified":1553312285539},{"_id":"source/_posts/Algorithm/Data-Structure/topological-sort.md","hash":"2fdd0a67b2a957519092b7ac94b9149c0bc7d59e","modified":1553312285539},{"_id":"source/_posts/Algorithm/ForOffer/find-in-two-dimensional-array.md","hash":"fe83955fd11c0fc3f64f8d0335fb1ccee603403b","modified":1553312196539},{"_id":"source/_posts/Algorithm/ForOffer/implement-queue-with-stack.md","hash":"a7a7bc172db030551ca9c2ce297d57669b47416c","modified":1553312196539},{"_id":"source/_posts/Algorithm/ForOffer/min-number-in-rotate-array.md","hash":"2c2a34b95620d2964cc42646e26113507ec40816","modified":1553312196539},{"_id":"source/_posts/Algorithm/ForOffer/print-list-from-tail-to-head.md","hash":"b59858e828c2420f829fc39d170858d0d4bfb59c","modified":1553312196539},{"_id":"source/_posts/Algorithm/ForOffer/reconstruct-binary-tree.md","hash":"8442312fbb56f21effc843b681fd8b05a4e642bf","modified":1553312196539},{"_id":"source/_posts/Algorithm/ForOffer/replace-sapce.md","hash":"bd637cdd78c32dffc0bca6f1899daa01c715714c","modified":1553312196539},{"_id":"source/_posts/Algorithm/LeetCode/leetcode-linear-list.md","hash":"a8152e8fc9d9083440d8c2a3fe7ee2235b942f18","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p1-two-sum.md","hash":"f3978112aad8262c61bd065953f56853f31e7f7e","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p100-same-tree.md","hash":"708613c889ef7f648f47b9e0f6d1516fb1d53319","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p107-binary-tree-level-order-traversal-ii.md","hash":"8875eeb28e2a553df2b5105a5bb45bdcbeba1d90","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p101-symmetric-tree.md","hash":"61d4b04e6170ad341948e02fdc8271d928732de6","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p108-convert-sorted-array-to-binary-search-tree.md","hash":"6ec4588fdb37f1e1c459372f69e16cecbd0c1a70","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p110-balanced-binary-tree.md","hash":"3bfda0ba762d94af23f125067e41aea959482c1d","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p112-path-sum.md","hash":"718e62e0c2e204de0defebb5be78245ea5a82911","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p111-minimum-depth-of-binary-tree.md","hash":"842c4d0bb4a3c58c61c4b7e816f528c03b134c7a","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p118-pascal's-triangle.md","hash":"f299c83ca963640a5a22fb04d2ab27e4398139f4","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p121-best-time-to-buy-and-sell-stock.md","hash":"7fb3c09ead68171f468b6b9f7aa0f6e29275379d","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p119-pascal's-triangle-ii.md","hash":"5626878363660b8e4637d7a8d595d06d35ba3064","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p122-best-time-to-buy-and-sell-stock-ii.md","hash":"bc96c6ade5d578f0a5c9652db5150496d4c6c279","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p136-single-number.md","hash":"07310ce8be04fc7c2e964ee632d1caf424adf07a","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p125-valid-palindrome.md","hash":"03b357dd46476b739bbfa989c438f0da6675847e","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p141-linked-list-cycle.md","hash":"2cba1a7416c5cd1666ba8f301f593fd82892ccff","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p160-intersection-of-two-linked-lists.md","hash":"760cfcd88a2028af3d13249e882cc401f8fb423b","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p167-two-sum-ii---input-array-is-sorted.md","hash":"0a1d45158369fb9b9d55b1bc125a0f89ea1a4bac","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p169-majority-element.md","hash":"5675255e12c3f84a0d50621643342df71f5ff730","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p168-excel-sheet-column-title.md","hash":"0e82a1ee66675b4bfbd5d29267b92f6c7d9dbc79","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p171-excel-sheet-column-number.md","hash":"a994788070c69fd3383ed253b7badde9fd1cd414","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p189-rotate-array.md","hash":"c391b4693ca1e0c0895a8806b4281d2716771044","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p20-valid-parentheses.md","hash":"5eeb19f88b996a3de5b6b71a87e160fecc10adff","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p190-reverse-bits.md","hash":"96a847fecfa8e28f07141cd9a791582e96c8f6a0","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p203-remove-linked-list-elements.md","hash":"7f20cc9c6d111ec2ef19016b81089c0025f89276","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p191-number-of-1-bits.md","hash":"f1f671cffc5649a3ed6e3190614b57c4f665675f","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p204-count-primes.md","hash":"d7303a998f8d79e345acd89ed88cf48bdbb26033","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p205-isomorphic-strings.md","hash":"3d017d8c6b1834668017bafc6e25a03ab7b3f298","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p206-reverse-linked-list.md","hash":"d11bc868aab2721bd9165ef4b36e056d67087c64","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p21-merge-two-sorted-lists.md","hash":"560d533b1c87eededd5b3ea4c7de617735487b2f","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p217-contains-duplicate.md","hash":"4bb41c196193f69ebd679fd3938df34caab95a7e","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p226-invert-binary-tree.md","hash":"2598cea09875c8a60f0b0c8f5b71c2748233950b","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p225-implement-stack-using-queues.md","hash":"fabf848dfb084b7677036e62571c1ec9d804e65c","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p231-power-of-two.md","hash":"f3ed7df002621dca1fcefdd9112f87a97fe9fce1","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p232-implement-queue-using-stacks.md","hash":"08bdf93ba9fc7490019410e7a21fcee7a617450d","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p237-delete-node-in-a-linked-list.md","hash":"976d99ff8d86cddc37a8a77db8b12c3746eadb97","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p242-valid-anagram.md","hash":"f6e0caff6ba12c17750fb57442288e804b6a3289","modified":1553312170792},{"_id":"source/_posts/Algorithm/LeetCode/p234-palindrome-linked-list.md","hash":"5701f7e65ee77772e6c81e289308015a08fdb3b8","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p257-binary-tree-paths.md","hash":"bd51571664cb60f64fb92ef7fc03536f23dbb524","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p26-remove-duplicates-from-sorted-array.md","hash":"6f989122d35dada7bd742e4e2ec2c40da2cecad7","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p258-add-digits.md","hash":"4ffda547e138e547131f33acdfb111fbc02ca1c2","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p263-ugly-number.md","hash":"13d359938599736a1815c2210b4372034e3842b5","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p268-missing-number.md","hash":"d553fea2f30e1204bdeb1f1eec404a6f58d2c527","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p27-remove-element.md","hash":"7eb08157a3184dde3350857e0fa274cc9a4da4e5","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p283-move-zeroes.md","hash":"636b8a28670b722b323a1d659885c54e0c8e6f05","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p278-first-bad-version.md","hash":"45dab959f0b1f44d99332742a05423c358346067","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p292-nim-game.md","hash":"88eb18cc3c7172f038aa8fe063262de37fede6f7","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p28-implement-strstr().md","hash":"ed6e12a732d9788846e3c7816f5fa9e940e29c1d","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p310-minimum-height-trees.md","hash":"caa709fc599ba4a2e5a63fc2cd43313a6f08c62b","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p326-power-of-three.md","hash":"a672a8344cc1518569d224225ba24a43d4f8ab49","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p338-counting-bits.md","hash":"2126dfaf9fb77e5a4dbd1bfdc630bf32ece4198a","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p34-search-for-a-range.md","hash":"8f99741a4e0515add575c41f20118a99cf8ce5bf","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p342-power-of-four.md","hash":"b8019c132fc3a9e09b882c0d61bf0c115d0e6b6f","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p349-intersection-of-two-arrays.md","hash":"bb7f8cac9eb2be6ff30fe4ebc2adc761b3f3fe65","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p344-reverse-string.md","hash":"b022e69387b493fe517052ce55ba9aa906ee878e","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p345-reverse-vowels-of-a-string.md","hash":"3452ab894cff5b97eb29ce09ae32e485fef33235","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p35-search-insert-position.md","hash":"f82b4b89d894f204698ca7b514d3a2f10d6687d8","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p350-intersection-of-two-arrays-ii.md","hash":"1037091ee96538e8e25dd4cf20b2e316e68b1d26","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p367-valid-perfect-square.md","hash":"eaf6b297647cae167d45f4961e8fa50d7e49d5ee","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p371-sum-of-two-integers.md","hash":"243cb163934780392227738a404d1215da14dc47","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p374-guess-number-higher-or-lower.md","hash":"3d3c7240021a549e384bc00bc03cfbf4b231a599","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p383-ransom-note.md","hash":"d16d2197af22690f3a55e15f726307d2fdca2fd2","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p387-first-unique-character-in-a-string.md","hash":"7b9305d1dc6ae8056b381b248545b988fddbead6","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p401-binary-watch.md","hash":"669bb70fd9962234f8a6ef2445916c0728ceffac","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p389-find-the-difference.md","hash":"b006dacc8ecfd5f42c462deefd91977fc6acfb44","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p404-sum-of-left-leaves.md","hash":"31fc7d8c869947657c83f7e3aa869af61902ca48","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p412-fizz-buzz.md","hash":"c04af7cb0d6d32a74d0ecde3d6706479216ec27d","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p414-third-maximum-number.md","hash":"3692ce50836fa9ae0fcedf77410366f65e377b92","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p415-add-strings.md","hash":"9097eff09b7fb64e48f5a03be088e51768ebf148","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p434-number-of-segments-in-a-string.md","hash":"8187145704d34e3807f0fcec994559eee7e01003","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p441-arranging-coins.md","hash":"87fd1e53b47c297dd8503118c05690289ad4cadc","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p461-hamming-distance.md","hash":"85430737bc6409fa8b7b35dc326d390bc30d6fd0","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p475-heaters.md","hash":"91a3cb229d52da676ba65b6919c49abd07d78420","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p476-number-complement.md","hash":"0dd046a1c5bc6ab4a3c47aaf732df3e10d5cf760","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p50-pow(x,-n).md","hash":"3fa0e015df0d67ea15be67c93e6272b032b77a5f","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p504-base-7.md","hash":"733db59089d4794d7255cce62abc647ea1b5134d","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p507-perfect-number.md","hash":"870cc4cd7b70783688f1f92a0367e453756921fa","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p53-maximum-subarray.md","hash":"06dbd727fa44bf6e4aeb4a40d525fdceab15ba78","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p541-reverse-string-ii.md","hash":"52f3f0ebfe3b5294b1b5b3012503c8996ebb0e41","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p540-single-element-in-a-sorted-array.md","hash":"0daee96964874de9ac6afcadde4a982b9f2f59da","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p575-distribute-candies.md","hash":"79acf3c88a57ff112987d43c97a4f6e513706901","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p535-encode-and-decode-tinyurl.md","hash":"bfe758a0ce3f574c5c88f21fe64f84de62a85031","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p617-merge-two-binary-trees.md","hash":"f1bf8acdb409bd20b6c97744cf0fc09c4ed5dd0f","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p58-length-of-last-word.md","hash":"c4f2396669f9f0e0c6ffa1fec0a3f11ec8f95e67","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p654-maximum-binary-tree.md","hash":"78815ab3f43a000a05cb025fbd18d1ee6384f64c","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p657-judge-route-circle.md","hash":"44a409aca6788655be2c39a64fbc5149a323d8ef","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p66-plus-one.md","hash":"bfe5f1594aa74c1b132c53e208e03a7544a64839","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p669-trim-a-binary-search-tree.md","hash":"ff0891193f274948bc64ffb650bcc3aa1d46b1a4","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p67-add-binary.md","hash":"4216ccd31d9d40c732fec544cdd7875515efd63b","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p69-sqrt(x).md","hash":"c15ecd2365d3dd7f10710b75072ccc8eec617651","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p744-find-smallest-letter-greater-than-target.md","hash":"3076ddd4a80bb89e16106baffb458efc5af0811e","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p7-reverse-integer.md","hash":"ee38d3f02b500d5ec0655bac571986ef376c2dab","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p70-climbing-stairs.md","hash":"e85bc406557b27f07581f8436929040d41ce20ae","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p771-jewels-and-stones.md","hash":"30e648a4ccda52d8bd56f870a5c702c61aaa68f1","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p728-self-dividing-numbers.md","hash":"aa717387afb7ac714a62d96f4c7d3b88d8cd8f95","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p83-remove-duplicates-from-sorted-list.md","hash":"bb21fdef1bfa8063cfe43eab8c563567e1dbcae6","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p88-merge-sorted-array.md","hash":"075845691fd932409fb6fe398076e9740bb82efb","modified":1553312170793},{"_id":"source/_posts/Algorithm/LeetCode/p9-palindrome-number.md","hash":"c928c92359eacef37eebafbba1be1e118aed15ee","modified":1553312170793},{"_id":"source/_posts/Java/Collection-Framework/ArrayList.md","hash":"c87cc0d38100105c4434d950eaf880d78bdb3213","modified":1553352293710},{"_id":"source/_posts/Java/Collection-Framework/ArrayList-Grow.md","hash":"166ff002c3f70b650bc8b983dbbe805eacaa94c6","modified":1553313004721},{"_id":"source/_posts/Java/Collection-Framework/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1553312248164},{"_id":"source/_posts/Java/Collection-Framework/LinkedList.md","hash":"f5d3a2b37b79678544c548ad77e903ffa93710ea","modified":1553312953296},{"_id":"source/_posts/Java/Concurrency/questiones-multithread-in-java.md","hash":"c80cceb9fe83a15c3c9a1a13f07bf4b6f58a9c2c","modified":1553312385606},{"_id":"source/_posts/Java/Collection-Framework/HashMap.md","hash":"48d05f224d82a9e02a9ef23d6ac799197aa607d2","modified":1553312493241},{"_id":"source/_posts/Java/Summary/common-questions.md","hash":"b2f7b53e6f0206250f63b519959c5bb113800f4d","modified":1553407722897},{"_id":"source/_posts/Java/Summary/string.md","hash":"88d67b2239e558e4acd598e8122ba1701eced3e3","modified":1553407725398},{"_id":"source/_posts/Java/JVM/implement-function-call-in-c.md","hash":"a3791d42e123c32193b49acecba09003be2fa639","modified":1553312248602},{"_id":"source/_posts/Java/Summary/thread.md","hash":"947481028b3cb5ece264a63e25d21e7a3e613aab","modified":1553407729971},{"_id":"themes/next-reload/.git/refs/heads/master","hash":"c722097b59cd2c315a1084a52fec53b08d7b2548","modified":1572418450387},{"_id":"themes/next-reload/scripts/events/lib/config.js","hash":"246e55d48f2f3ef510c11594c7c08ddb93ac0928","modified":1572418450425},{"_id":"themes/next-reload/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1572418450425},{"_id":"themes/next-reload/scripts/events/lib/injects.js","hash":"311a54c0a0b6192502e68ce8c0b20e77aed3b996","modified":1572418450425},{"_id":"themes/next-reload/scripts/filters/comment/changyan.js","hash":"1fc2a94b94108175848ba9541d05898c071386d0","modified":1572418450426},{"_id":"themes/next-reload/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1572418450426},{"_id":"themes/next-reload/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1572418450426},{"_id":"themes/next-reload/scripts/filters/comment/disqus.js","hash":"d2ce60980fc148bfb877981aabd07bf45d2cdcda","modified":1572418450426},{"_id":"themes/next-reload/scripts/filters/comment/disqusjs.js","hash":"c081166868e6428a07c51c5674b86b7a4cc9c2a8","modified":1572418450427},{"_id":"themes/next-reload/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1572418450427},{"_id":"themes/next-reload/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1572418450427},{"_id":"themes/next-reload/scripts/filters/comment/valine.js","hash":"5201cd09a5e263282ccbf205f07d46f4c6d3f700","modified":1572418450427},{"_id":"themes/next-reload/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1572418450462},{"_id":"themes/next-reload/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1572418450462},{"_id":"themes/next-reload/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1572418450463},{"_id":"themes/next-reload/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1572418450462},{"_id":"themes/next-reload/source/css/_variables/base.styl","hash":"e76e0e411c9892004e73e1bb7b3c1cca2191eedc","modified":1572418450463},{"_id":"themes/next-reload/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1572418450452},{"_id":"themes/next-reload/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1572418450454},{"_id":"themes/next-reload/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1572418450454},{"_id":"themes/next-reload/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1572418450473},{"_id":"themes/next-reload/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1572418450474},{"_id":"themes/next-reload/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1572418450473},{"_id":"themes/next-reload/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1572418450474},{"_id":"themes/next-reload/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1572418450475},{"_id":"themes/next-reload/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1572418450488},{"_id":"themes/next-reload/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1572418450489},{"_id":"themes/next-reload/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1572418450471},{"_id":"themes/next-reload/source/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1572418450472},{"_id":"themes/next-reload/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1572418450417},{"_id":"themes/next-reload/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/analytics/google-analytics.swig","hash":"194201cce870c1af6f5123a62cb766cd24e46217","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/comments/disqus.swig","hash":"fe3cdd70224bd0c8171513a5dfed7b85deb7f23d","modified":1572418450419},{"_id":"themes/next-reload/layout/_third-party/comments/gitalk.swig","hash":"8063f65cdaae80840fcf427b875ae606f678dfa5","modified":1572418450419},{"_id":"themes/next-reload/layout/_third-party/comments/disqusjs.swig","hash":"9719cb5858896aef86c2e0bec0ace259936680c4","modified":1572418450419},{"_id":"themes/next-reload/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1572418450419},{"_id":"themes/next-reload/layout/_third-party/comments/valine.swig","hash":"a9c8e7987b63b9ef66e47b966aea05ac77ff920a","modified":1572418450419},{"_id":"themes/next-reload/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1572418450418},{"_id":"themes/next-reload/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1572418450420},{"_id":"themes/next-reload/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1572418450420},{"_id":"themes/next-reload/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1572418450421},{"_id":"themes/next-reload/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1572418450420},{"_id":"themes/next-reload/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1572418450421},{"_id":"themes/next-reload/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1572418450421},{"_id":"themes/next-reload/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/statistics/lean-analytics.swig","hash":"7f2941d119abca6627561fb010dad96fa48d2092","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/statistics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/statistics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/statistics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1572418450422},{"_id":"themes/next-reload/layout/_third-party/statistics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1572418450423},{"_id":"themes/next-reload/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1572418450423},{"_id":"themes/next-reload/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1572418450423},{"_id":"themes/next-reload/layout/_scripts/pages/schedule.swig","hash":"246ff123cbaa507f23514c0c51c6cc006685898e","modified":1572418450416},{"_id":"themes/next-reload/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1572418450417},{"_id":"themes/next-reload/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1572418450417},{"_id":"themes/next-reload/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1572418450417},{"_id":"themes/next-reload/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1572418450417},{"_id":"themes/next-reload/layout/_partials/head/head-unique.swig","hash":"f5d2c5a3421ae52888be62e2c837459d1175cc93","modified":1572418450413},{"_id":"themes/next-reload/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1572418450413},{"_id":"themes/next-reload/layout/_partials/head/head.swig","hash":"7f94334632478fde4ff03f8d6ef1e9b2f02c30b0","modified":1572418450413},{"_id":"themes/next-reload/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1572418450413},{"_id":"themes/next-reload/layout/_partials/header/menu-item.swig","hash":"ff33b5797f5e4b5cbcb3c222c17bc636c6b88df6","modified":1572418450414},{"_id":"themes/next-reload/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1572418450414},{"_id":"themes/next-reload/layout/_partials/header/sub-menu.swig","hash":"fbec9f77139e1f300509c38446416b4b26350cfa","modified":1572418450414},{"_id":"themes/next-reload/layout/_partials/header/menu.swig","hash":"d488664bc16608b5f829f959c2058b4381be244a","modified":1572418450414},{"_id":"themes/next-reload/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1572418450414},{"_id":"themes/next-reload/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1572418450415},{"_id":"themes/next-reload/layout/_partials/post/post-copyright.swig","hash":"becfa683c3e5409e20cdb7b1dc8a6db331bddefe","modified":1572418450415},{"_id":"themes/next-reload/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1572418450415},{"_id":"themes/next-reload/layout/_partials/post/post-reward.swig","hash":"bebf630963c1c65fd152859a1ba316b03be17cce","modified":1572418450415},{"_id":"themes/next-reload/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1572418450416},{"_id":"themes/next-reload/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1572418450416},{"_id":"themes/next-reload/layout/_partials/sidebar/site-overview.swig","hash":"2afd85181eaefcd68c4db71b0526ee26e2146477","modified":1572418450416},{"_id":"themes/next-reload/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1572418450416},{"_id":"themes/next-reload/.git/logs/refs/heads/master","hash":"73cf74e2f375f7b002c3442fbbea7ca38a7f410a","modified":1572418450388},{"_id":"themes/next-reload/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1572418450386},{"_id":"themes/next-reload/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1572418450437},{"_id":"themes/next-reload/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1572418450437},{"_id":"themes/next-reload/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1572418450437},{"_id":"themes/next-reload/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1572418450448},{"_id":"themes/next-reload/source/css/_common/scaffolding/base.styl","hash":"2067e15799a3a3cda8bfe7782d67a4dc42f1ef79","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1572418450448},{"_id":"themes/next-reload/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1572418450449},{"_id":"themes/next-reload/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1572418450449},{"_id":"themes/next-reload/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1572418450449},{"_id":"themes/next-reload/source/css/_common/scaffolding/tables.styl","hash":"f3c5f1dadc01042381444102d35174dacc6f079a","modified":1572418450450},{"_id":"themes/next-reload/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1572418450446},{"_id":"themes/next-reload/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1572418450451},{"_id":"themes/next-reload/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1572418450446},{"_id":"themes/next-reload/source/css/_schemes/Gemini/index.styl","hash":"08c2679a31f195940fe1e6c76e64799fb21cda99","modified":1572418450455},{"_id":"themes/next-reload/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1572418450455},{"_id":"themes/next-reload/source/css/_schemes/Mist/_header.styl","hash":"4341f0e057b42e8c47629bb3196fca3b49f0cc19","modified":1572418450455},{"_id":"themes/next-reload/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1572418450457},{"_id":"themes/next-reload/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1572418450458},{"_id":"themes/next-reload/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1572418450456},{"_id":"themes/next-reload/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1572418450459},{"_id":"themes/next-reload/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1572418450459},{"_id":"themes/next-reload/source/css/_schemes/Muse/_menu.styl","hash":"316ee13fc26d327c8862c2455211144c180cf9c1","modified":1572418450459},{"_id":"themes/next-reload/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1572418450460},{"_id":"themes/next-reload/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1572418450460},{"_id":"themes/next-reload/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1572418450460},{"_id":"themes/next-reload/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1572418450461},{"_id":"themes/next-reload/source/css/_schemes/Pisces/_sidebar.styl","hash":"c59226767164285d6708d8762f937f93bab264ca","modified":1572418450461},{"_id":"themes/next-reload/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1572418450461},{"_id":"themes/next-reload/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1572418450462},{"_id":"themes/next-reload/source/css/_schemes/Pisces/_menu.styl","hash":"c0ed534696ed86560c95ab2a3541b2b42a41ed39","modified":1572418450461},{"_id":"themes/next-reload/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1572418450462},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1572418450475},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1572418450476},{"_id":"themes/next-reload/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1572418450478},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1572418450482},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1572418450485},{"_id":"themes/next-reload/.git/logs/refs/remotes/origin/HEAD","hash":"73cf74e2f375f7b002c3442fbbea7ca38a7f410a","modified":1572418450386},{"_id":"themes/next-reload/.git/objects/pack/pack-aa021a75ea75ccaf526241fa013d783788bc80be.idx","hash":"1ee58b13c67c900bf01d129945c84f893bbb571f","modified":1572418450366},{"_id":"themes/next-reload/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1572418450438},{"_id":"themes/next-reload/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1572418450438},{"_id":"themes/next-reload/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1572418450439},{"_id":"themes/next-reload/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1572418450439},{"_id":"themes/next-reload/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1572418450440},{"_id":"themes/next-reload/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1572418450440},{"_id":"themes/next-reload/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1572418450441},{"_id":"themes/next-reload/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1572418450441},{"_id":"themes/next-reload/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1572418450441},{"_id":"themes/next-reload/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1572418450442},{"_id":"themes/next-reload/source/css/_common/components/post/post-gallery.styl","hash":"d557a0de91a428330b43cdae9f1ec7167d24e2e4","modified":1572418450441},{"_id":"themes/next-reload/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1572418450442},{"_id":"themes/next-reload/source/css/_common/components/post/post-header.styl","hash":"3566136c06d96b34e1e7a3eca72fb0f40a63af80","modified":1572418450442},{"_id":"themes/next-reload/source/css/_common/components/post/post-reward.styl","hash":"f8ba308231cf81453e41457796e94f1ce886d855","modified":1572418450442},{"_id":"themes/next-reload/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1572418450442},{"_id":"themes/next-reload/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/components/post/post.styl","hash":"5248880398c1318624bdab95109c1c9fdb8eec02","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1572418450443},{"_id":"themes/next-reload/source/css/_common/components/third-party/third-party.styl","hash":"4525465f40f82bd66e5f34e986440c75a9e2d2b2","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"2b536832cfc81667dadd9603c8c700e44d458261","modified":1572418450448},{"_id":"themes/next-reload/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1572418450448},{"_id":"themes/next-reload/source/css/_common/scaffolding/highlight/highlight.styl","hash":"4b980363822c24b3ad85c271719210a8ad2b646e","modified":1572418450449},{"_id":"themes/next-reload/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1572418450449},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1572418450450},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1572418450450},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"879f9cec9c88d65b2e31af4346b2bc0f6941f05d","modified":1572418450450},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1572418450451},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1572418450451},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/note.styl","hash":"068b304be305fbfd0220276d56b93cefd968f0b6","modified":1572418450451},{"_id":"themes/next-reload/source/css/_common/scaffolding/tags/tabs.styl","hash":"419fa6cfc103d08dfd6a385ab7f24468c644d581","modified":1572418450451},{"_id":"themes/next-reload/source/css/_common/outline/footer/footer.styl","hash":"5528a755b180312d008054653633d857aeeb6780","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1572418450444},{"_id":"themes/next-reload/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1572418450445},{"_id":"themes/next-reload/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1572418450445},{"_id":"themes/next-reload/source/css/_common/outline/header/site-nav.styl","hash":"b5ba1b3d5535ccf1e5df6f4cd8ee0147d7278be9","modified":1572418450445},{"_id":"themes/next-reload/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1572418450445},{"_id":"themes/next-reload/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1572418450445},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1572418450446},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1572418450446},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1572418450446},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"cc4beedb56c37246d9e0f74e4b2cc34231dabc65","modified":1572418450446},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/sidebar.styl","hash":"eaa62b5de4ddb18378c1a4049a172d4fa4b655d8","modified":1572418450447},{"_id":"themes/next-reload/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1572418450447},{"_id":"themes/next-reload/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1572418450480},{"_id":"themes/next-reload/.git/objects/pack/pack-aa021a75ea75ccaf526241fa013d783788bc80be.pack","hash":"dcc0068b96312aee2ec9526b8abe961046209adb","modified":1572418450363}],"Category":[{"name":"Android","_id":"ck2u3gdqz0004qnn9xnt92701"},{"name":"DevOps","_id":"ck2u3gdr60008qnn9tniurxj9"},{"name":"Tools","_id":"ck2u3gdrf000eqnn9sxqsxyz2"},{"name":"Git","_id":"ck2u3gdsc000vqnn9ajhup9n7"},{"name":"Algorithm","_id":"ck2u3gdtf0011qnn9yomtheaw"},{"name":"ForOffer","parent":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdtu001fqnn9ktedibjc"},{"name":"Data-Structure","parent":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdty001lqnn9m9lntvoi"},{"name":"LeetCode","parent":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gduw0033qnn92z041qaj"},{"name":"Java","_id":"ck2u3ge0e00agqnn93ywogllt"},{"name":"JVM","parent":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge0f00apqnn9feqhup37"},{"name":"Summary","parent":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge1o00emqnn9bqqpgcdj"},{"name":"Concurrency","parent":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge1s00esqnn9za2dfsr5"},{"name":"Collection-Framework","parent":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge1x00ezqnn9e4gpdebw"}],"Data":[],"Page":[{"title":"categories","date":"2019-03-23T13:43:41.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-23 21:43:41\ntype: categories\ncomments: false\n---\n","updated":"2019-03-23T13:45:55.323Z","path":"categories/index.html","layout":"page","_id":"ck2u3gdmg0000qnn9gebt8ykm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-03-23T13:43:29.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-23 21:43:29\ntype: tags\ncomments: false\n---\n","updated":"2019-03-23T13:46:06.706Z","path":"tags/index.html","layout":"page","_id":"ck2u3gdmj0001qnn9x4ibhz87","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RadioGroup实现按钮互斥效果","_content":"\n\n\n在Android应用中，常常需要用到按钮互斥的效果，比如在一组按钮里面作单选，我们很容易想到用RadioButton去实现，但在更进一步的场景，比如微信App底部Tab的切换，在点击底部Button的时候会出现按钮高亮的效果，点击其他按钮会取消掉上一个高亮效果，Touch已经处于高亮效果的Button，会取消高亮，而释放时会继续高亮效果。\n\n## 效果展示\n\n文字的描述比较费力还不容易理解，那么先展示一下效果吧。\n\n![ButtonMutex](http://oslixehxy.bkt.clouddn.com/18-5-3/93041749.jpg)\n\n\n\n## 环境配置\n\nWin10专业版\n\nAndroid Studio 3.1.1\n\nJDK 1.8.0\n\n### 工程文件目录：（文末附源码）\n\n![1525362107114](http://oslixehxy.bkt.clouddn.com/18-5-3/54060288.jpg)\n\n- MainActivity.java:首页的界面\n\n## 代码实现\n\n### 布局文件\n\n1. activity_main.xml \n\n   ~~~xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools=\"http://schemas.android.com/tools\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:background=\"#000000\"\n       tools:context=\".MainActivity\">\n\n       <LinearLayout\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\"\n           android:orientation=\"horizontal\">\n\n           <RadioGroup\n               android:id=\"@+id/rg_entry\"\n               android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\" >\n\n               <RadioButton\n                   android:id=\"@+id/rb_sync\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_sync\"/>\n\n               <RadioButton\n                   android:id=\"@+id/rb_apa\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_apa\"/>\n\n               <RadioButton\n                   android:id=\"@+id/rb_dvr\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_dvr\"/>\n           </RadioGroup>\n\n       </LinearLayout>\n   </android.support.constraint.ConstraintLayout>\n   ~~~\n\n2. selector_rb_dvr.xml： dvr按钮被选中时对应的icon状态\n\n   另外两个的selector_xxx.xml 代码与此相同，区别是`@drawable/xxx`加载的对象不同\n\n   ~~~xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n       <item android:drawable=\"@drawable/icon_dvr_hl\" android:state_pressed=\"false\" android:state_selected=\"true\" />\n       <item android:drawable=\"@drawable/icon_dvr_hl\" android:state_checked=\"true\" android:state_pressed=\"false\" />\n       <item android:drawable=\"@drawable/icon_dvr_normal\" />\n\n   </selector>\n   ~~~\n\n### Activity代码\n\nMainActivity.java\n\n~~~java\npackage shu.shaw.buttonmutex;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.widget.RadioButton;\nimport android.widget.RadioGroup;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private RadioGroup radioGroup;\n    private RadioButton rbDvr;\n    private RadioButton rbApa;\n    private RadioButton rbSync;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n\n        final RadioButton rbDvr = (RadioButton)findViewById(R.id.rb_dvr);\n        final RadioButton rbApa = (RadioButton)findViewById(R.id.rb_apa);\n        RadioButton rbSync = (RadioButton)findViewById(R.id.rb_sync);\n\n        RadioGroup radioGroup = (RadioGroup)findViewById(R.id.rg_entry);\n        radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                if (checkedId == rbDvr.getId()) {\n                    Toast.makeText(getApplicationContext(), \"click the DVR button\", Toast.LENGTH_LONG).show();\n                } else if (checkedId == rbApa.getId()) {\n                    Toast.makeText(getApplicationContext(), \"click the APA button\", Toast.LENGTH_LONG).show();\n                } else {\n                    Toast.makeText(getApplicationContext(), \"click the SYNC button\", Toast.LENGTH_LONG).show();\n                }\n            }\n        });\n    }\n}\n\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/android-demo/tree/other/ButtonMutex)\n\n## 参考\n\n[Android自定义控件----RadioGroup实现APP首页底部Tab的切换](http://www.cnblogs.com/smyhvae/p/4463931.html)","source":"_posts/Android/button-mutex-demo.md","raw":"---\ntitle: RadioGroup实现按钮互斥效果\ncategories:\n  - Android\ntags:\n  - android\n---\n\n\n\n在Android应用中，常常需要用到按钮互斥的效果，比如在一组按钮里面作单选，我们很容易想到用RadioButton去实现，但在更进一步的场景，比如微信App底部Tab的切换，在点击底部Button的时候会出现按钮高亮的效果，点击其他按钮会取消掉上一个高亮效果，Touch已经处于高亮效果的Button，会取消高亮，而释放时会继续高亮效果。\n\n## 效果展示\n\n文字的描述比较费力还不容易理解，那么先展示一下效果吧。\n\n![ButtonMutex](http://oslixehxy.bkt.clouddn.com/18-5-3/93041749.jpg)\n\n\n\n## 环境配置\n\nWin10专业版\n\nAndroid Studio 3.1.1\n\nJDK 1.8.0\n\n### 工程文件目录：（文末附源码）\n\n![1525362107114](http://oslixehxy.bkt.clouddn.com/18-5-3/54060288.jpg)\n\n- MainActivity.java:首页的界面\n\n## 代码实现\n\n### 布局文件\n\n1. activity_main.xml \n\n   ~~~xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n       xmlns:tools=\"http://schemas.android.com/tools\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:background=\"#000000\"\n       tools:context=\".MainActivity\">\n\n       <LinearLayout\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\"\n           android:orientation=\"horizontal\">\n\n           <RadioGroup\n               android:id=\"@+id/rg_entry\"\n               android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\" >\n\n               <RadioButton\n                   android:id=\"@+id/rb_sync\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_sync\"/>\n\n               <RadioButton\n                   android:id=\"@+id/rb_apa\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_apa\"/>\n\n               <RadioButton\n                   android:id=\"@+id/rb_dvr\"\n                   android:layout_width=\"wrap_content\"\n                   android:layout_height=\"wrap_content\"\n                   android:layout_weight=\"1\"\n                   android:checked=\"false\"\n                   android:button=\"@null\"\n                   android:drawableTop=\"@drawable/selector_rb_dvr\"/>\n           </RadioGroup>\n\n       </LinearLayout>\n   </android.support.constraint.ConstraintLayout>\n   ~~~\n\n2. selector_rb_dvr.xml： dvr按钮被选中时对应的icon状态\n\n   另外两个的selector_xxx.xml 代码与此相同，区别是`@drawable/xxx`加载的对象不同\n\n   ~~~xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <selector xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n       <item android:drawable=\"@drawable/icon_dvr_hl\" android:state_pressed=\"false\" android:state_selected=\"true\" />\n       <item android:drawable=\"@drawable/icon_dvr_hl\" android:state_checked=\"true\" android:state_pressed=\"false\" />\n       <item android:drawable=\"@drawable/icon_dvr_normal\" />\n\n   </selector>\n   ~~~\n\n### Activity代码\n\nMainActivity.java\n\n~~~java\npackage shu.shaw.buttonmutex;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.widget.RadioButton;\nimport android.widget.RadioGroup;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private RadioGroup radioGroup;\n    private RadioButton rbDvr;\n    private RadioButton rbApa;\n    private RadioButton rbSync;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n\n        final RadioButton rbDvr = (RadioButton)findViewById(R.id.rb_dvr);\n        final RadioButton rbApa = (RadioButton)findViewById(R.id.rb_apa);\n        RadioButton rbSync = (RadioButton)findViewById(R.id.rb_sync);\n\n        RadioGroup radioGroup = (RadioGroup)findViewById(R.id.rg_entry);\n        radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                if (checkedId == rbDvr.getId()) {\n                    Toast.makeText(getApplicationContext(), \"click the DVR button\", Toast.LENGTH_LONG).show();\n                } else if (checkedId == rbApa.getId()) {\n                    Toast.makeText(getApplicationContext(), \"click the APA button\", Toast.LENGTH_LONG).show();\n                } else {\n                    Toast.makeText(getApplicationContext(), \"click the SYNC button\", Toast.LENGTH_LONG).show();\n                }\n            }\n        });\n    }\n}\n\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/android-demo/tree/other/ButtonMutex)\n\n## 参考\n\n[Android自定义控件----RadioGroup实现APP首页底部Tab的切换](http://www.cnblogs.com/smyhvae/p/4463931.html)","slug":"Android/button-mutex-demo","published":1,"date":"2018-05-03T16:08:54.776Z","updated":"2019-03-22T13:17:19.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdqk0002qnn9bfvosdsn","content":"<p>在Android应用中，常常需要用到按钮互斥的效果，比如在一组按钮里面作单选，我们很容易想到用RadioButton去实现，但在更进一步的场景，比如微信App底部Tab的切换，在点击底部Button的时候会出现按钮高亮的效果，点击其他按钮会取消掉上一个高亮效果，Touch已经处于高亮效果的Button，会取消高亮，而释放时会继续高亮效果。</p>\n<h2 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h2><p>文字的描述比较费力还不容易理解，那么先展示一下效果吧。</p>\n<p><img src=\"http://oslixehxy.bkt.clouddn.com/18-5-3/93041749.jpg\" alt=\"ButtonMutex\"></p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>Win10专业版</p>\n<p>Android Studio 3.1.1</p>\n<p>JDK 1.8.0</p>\n<h3 id=\"工程文件目录：（文末附源码）\"><a href=\"#工程文件目录：（文末附源码）\" class=\"headerlink\" title=\"工程文件目录：（文末附源码）\"></a>工程文件目录：（文末附源码）</h3><p><img src=\"http://oslixehxy.bkt.clouddn.com/18-5-3/54060288.jpg\" alt=\"1525362107114\"></p>\n<ul>\n<li>MainActivity.java:首页的界面</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"布局文件\"><a href=\"#布局文件\" class=\"headerlink\" title=\"布局文件\"></a>布局文件</h3><ol>\n<li><p>activity_main.xml </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">android.support.constraint.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">\"http://schemas.android.com/tools\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">\"#000000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">\".MainActivity\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"horizontal\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RadioGroup</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rg_entry\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_sync\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_sync\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_apa\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_apa\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_dvr\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_dvr\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RadioGroup</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>selector_rb_dvr.xml： dvr按钮被选中时对应的icon状态</p>\n<p>另外两个的selector_xxx.xml 代码与此相同，区别是<code>@drawable/xxx</code>加载的对象不同</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">selector</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_hl\"</span> <span class=\"attr\">android:state_pressed</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">android:state_selected</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_hl\"</span> <span class=\"attr\">android:state_checked</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">android:state_pressed</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_normal\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Activity代码\"><a href=\"#Activity代码\" class=\"headerlink\" title=\"Activity代码\"></a>Activity代码</h3><p>MainActivity.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> shu.shaw.buttonmutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.RadioButton;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.RadioGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioGroup radioGroup;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbDvr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbApa;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbSync;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> RadioButton rbDvr = (RadioButton)findViewById(R.id.rb_dvr);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RadioButton rbApa = (RadioButton)findViewById(R.id.rb_apa);</span><br><span class=\"line\">        RadioButton rbSync = (RadioButton)findViewById(R.id.rb_sync);</span><br><span class=\"line\"></span><br><span class=\"line\">        RadioGroup radioGroup = (RadioGroup)findViewById(R.id.rg_entry);</span><br><span class=\"line\">        radioGroup.setOnCheckedChangeListener(<span class=\"keyword\">new</span> RadioGroup.OnCheckedChangeListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCheckedChanged</span><span class=\"params\">(RadioGroup group, <span class=\"keyword\">int</span> checkedId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (checkedId == rbDvr.getId()) &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the DVR button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (checkedId == rbApa.getId()) &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the APA button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the SYNC button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/android-demo/tree/other/ButtonMutex\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/smyhvae/p/4463931.html\" target=\"_blank\" rel=\"noopener\">Android自定义控件—-RadioGroup实现APP首页底部Tab的切换</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Android应用中，常常需要用到按钮互斥的效果，比如在一组按钮里面作单选，我们很容易想到用RadioButton去实现，但在更进一步的场景，比如微信App底部Tab的切换，在点击底部Button的时候会出现按钮高亮的效果，点击其他按钮会取消掉上一个高亮效果，Touch已经处于高亮效果的Button，会取消高亮，而释放时会继续高亮效果。</p>\n<h2 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h2><p>文字的描述比较费力还不容易理解，那么先展示一下效果吧。</p>\n<p><img src=\"http://oslixehxy.bkt.clouddn.com/18-5-3/93041749.jpg\" alt=\"ButtonMutex\"></p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>Win10专业版</p>\n<p>Android Studio 3.1.1</p>\n<p>JDK 1.8.0</p>\n<h3 id=\"工程文件目录：（文末附源码）\"><a href=\"#工程文件目录：（文末附源码）\" class=\"headerlink\" title=\"工程文件目录：（文末附源码）\"></a>工程文件目录：（文末附源码）</h3><p><img src=\"http://oslixehxy.bkt.clouddn.com/18-5-3/54060288.jpg\" alt=\"1525362107114\"></p>\n<ul>\n<li>MainActivity.java:首页的界面</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"布局文件\"><a href=\"#布局文件\" class=\"headerlink\" title=\"布局文件\"></a>布局文件</h3><ol>\n<li><p>activity_main.xml </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">android.support.constraint.ConstraintLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">\"http://schemas.android.com/tools\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:background</span>=<span class=\"string\">\"#000000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">tools:context</span>=<span class=\"string\">\".MainActivity\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"horizontal\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">RadioGroup</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rg_entry\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_sync\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_sync\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_apa\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_apa\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">RadioButton</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/rb_dvr\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_weight</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:checked</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:button</span>=<span class=\"string\">\"@null\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:drawableTop</span>=<span class=\"string\">\"@drawable/selector_rb_dvr\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">RadioGroup</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>selector_rb_dvr.xml： dvr按钮被选中时对应的icon状态</p>\n<p>另外两个的selector_xxx.xml 代码与此相同，区别是<code>@drawable/xxx</code>加载的对象不同</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">selector</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_hl\"</span> <span class=\"attr\">android:state_pressed</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">android:state_selected</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_hl\"</span> <span class=\"attr\">android:state_checked</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">android:state_pressed</span>=<span class=\"string\">\"false\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/icon_dvr_normal\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Activity代码\"><a href=\"#Activity代码\" class=\"headerlink\" title=\"Activity代码\"></a>Activity代码</h3><p>MainActivity.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> shu.shaw.buttonmutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.RadioButton;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.RadioGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Toast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioGroup radioGroup;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbDvr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbApa;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RadioButton rbSync;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> RadioButton rbDvr = (RadioButton)findViewById(R.id.rb_dvr);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RadioButton rbApa = (RadioButton)findViewById(R.id.rb_apa);</span><br><span class=\"line\">        RadioButton rbSync = (RadioButton)findViewById(R.id.rb_sync);</span><br><span class=\"line\"></span><br><span class=\"line\">        RadioGroup radioGroup = (RadioGroup)findViewById(R.id.rg_entry);</span><br><span class=\"line\">        radioGroup.setOnCheckedChangeListener(<span class=\"keyword\">new</span> RadioGroup.OnCheckedChangeListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCheckedChanged</span><span class=\"params\">(RadioGroup group, <span class=\"keyword\">int</span> checkedId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (checkedId == rbDvr.getId()) &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the DVR button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (checkedId == rbApa.getId()) &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the APA button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    Toast.makeText(getApplicationContext(), <span class=\"string\">\"click the SYNC button\"</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/android-demo/tree/other/ButtonMutex\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/smyhvae/p/4463931.html\" target=\"_blank\" rel=\"noopener\">Android自定义控件—-RadioGroup实现APP首页底部Tab的切换</a></p>\n"},{"title":"关于串口调试自动化的解决方案","_content":"\n## 问题\n\n在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个\n\n- 重复命令手动输入执行\n- 交互性输入\n- 等待执行信息，不能自动保存到文件\n- 串口调试环境本身edit 便利性\n\n基于以上的问题，需要存在需求：\n\n- 可以将执行命令存放脚本中，而且可以去调用执行\n- 可处理交互性输入\n- 对于执行命令输出可以保存到 log 文件\n\n## 基本方案\n\n1. 基于 SecureCRT \n\n   SecureCRT 脚本，使用 python 语言\n\n   优点：\n\n   - GUI 界面，操作直观\n   - python syntax 语法特性支持强大\n\n   缺点：\n\n   - SecureCRT 过重，本身安装麻烦\n   - 仍然需要基本交互，SecureCRT 内调用脚本\n   - 与 jenkins 的集成\n\n2. 基于 Terminal 环境\n\n   首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。\n\n   其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）\n\n   最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。\n\n   优点：\n\n   - 轻量化，可通过命令行安装\n   - 所有过程都在 Terminal 操作\n   - 集成到 Jenkins，完全支持自动化流程\n\n   缺点：\n\n   - picocom 在功能性方面较弱\n\n##实际解决\n\n针对上面两种方案，如果是非重复性调试，使用前者上手更快。\n\n如果有需要多次重复性，或者自动化测试需求，选择后者。\n\n下面给出使用 Expect 的一个 demo：\n\n~~~tcl\n#!/usr/bin/expect \n# -d: debug mode\n\n# expect config\nset timeout 30\nlog_file test-expect.log\n\n# picocom config\nset baudrate \"115200\"\nset device \"/dev/ttyUSB0\"\nset prompt \"=>\"\n\n# function define\nset interval 5\nset iter_cnt 10\n\nproc start_xvr_debug { prompt } {\n    send \"xvr_client_dbus\\r\"\n    expect $prompt\n}\n\nproc test_switch_channel_display { iter_cnt interval prompt } {\n\n    for { set i 1 }  { $i < $iter_cnt } { incr i 1 } {\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n}\n\nproc test_start_stop_pipeline { iter_cnt interval prompt } {\n    for { set i 1 } { $i < $iter_cnt } { incr i 1 } {\n        send \"stop_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"stop_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n} \n\nspawn picocom -b $baudrate $device\nexpect \"Terminal ready\\r\"\nsend \"\\r\"\n\n# send \"xvr_client_dbus\\r\" \n# expect $prompt\n\nstart_xvr_debug $prompt\ntest_switch_channel_display $iter_cnt $interval $prompt \n# test_start_stop_pipeline $iter_cnt $interval $prompt \n\nexpect eof\n# interact\nwait\n~~~\n\n在具体使用中遇到的有几个小坑:\n\n1. 集成到 jenkins 时，jenkins 用户无法获得 `/dev/ttyUSB0` 权限。\n2. `sudo ` 执行 Expect 脚本进程 kill\n\n详情见尾注意小节。\n\n## 参考\n\n- [SecureCRT-python-scripts](https://blog.csdn.net/qq_14935437/article/details/78043904)\n- [Expect manual](https://linux.die.net/man/1/expect)\n- [Expect 使用教程](https://www.cnblogs.com/arlenhou/p/learn_expect.html)\n- [Expect interact & expect eof](https://blog.csdn.net/qq_20745901/article/details/54692610)\n\n## 注意\n\n1. 关于 jenkins 用户无法获取 `/dev/ttyUSB0` 权限\n\n   在这里最好不要直接使用 `sudo` ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。\n\n   解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。\n\n   ~~~bash\n   sudo usermod aG dialout jenkins\n   ~~~\n\n    \n\n2. sudo 执行的 expect 进程kill\n\n   `sudo killall -u USER expect `\n\n","source":"_posts/DevOps/serial-port-debug-env-automation.md","raw":"---\ntitle: 关于串口调试自动化的解决方案\ntags:\n  - automation\n  - tool\ncategories:\n  - DevOps\n---\n\n## 问题\n\n在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个\n\n- 重复命令手动输入执行\n- 交互性输入\n- 等待执行信息，不能自动保存到文件\n- 串口调试环境本身edit 便利性\n\n基于以上的问题，需要存在需求：\n\n- 可以将执行命令存放脚本中，而且可以去调用执行\n- 可处理交互性输入\n- 对于执行命令输出可以保存到 log 文件\n\n## 基本方案\n\n1. 基于 SecureCRT \n\n   SecureCRT 脚本，使用 python 语言\n\n   优点：\n\n   - GUI 界面，操作直观\n   - python syntax 语法特性支持强大\n\n   缺点：\n\n   - SecureCRT 过重，本身安装麻烦\n   - 仍然需要基本交互，SecureCRT 内调用脚本\n   - 与 jenkins 的集成\n\n2. 基于 Terminal 环境\n\n   首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。\n\n   其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）\n\n   最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。\n\n   优点：\n\n   - 轻量化，可通过命令行安装\n   - 所有过程都在 Terminal 操作\n   - 集成到 Jenkins，完全支持自动化流程\n\n   缺点：\n\n   - picocom 在功能性方面较弱\n\n##实际解决\n\n针对上面两种方案，如果是非重复性调试，使用前者上手更快。\n\n如果有需要多次重复性，或者自动化测试需求，选择后者。\n\n下面给出使用 Expect 的一个 demo：\n\n~~~tcl\n#!/usr/bin/expect \n# -d: debug mode\n\n# expect config\nset timeout 30\nlog_file test-expect.log\n\n# picocom config\nset baudrate \"115200\"\nset device \"/dev/ttyUSB0\"\nset prompt \"=>\"\n\n# function define\nset interval 5\nset iter_cnt 10\n\nproc start_xvr_debug { prompt } {\n    send \"xvr_client_dbus\\r\"\n    expect $prompt\n}\n\nproc test_switch_channel_display { iter_cnt interval prompt } {\n\n    for { set i 1 }  { $i < $iter_cnt } { incr i 1 } {\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n}\n\nproc test_start_stop_pipeline { iter_cnt interval prompt } {\n    for { set i 1 } { $i < $iter_cnt } { incr i 1 } {\n        send \"stop_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"stop_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-0\\r\"\n        expect $prompt\n        exec sleep $interval\n\n        send \"start_pipeline  /dev/xvr_pipeline-1\\r\"\n        expect $prompt\n        exec sleep $interval\n    }\n} \n\nspawn picocom -b $baudrate $device\nexpect \"Terminal ready\\r\"\nsend \"\\r\"\n\n# send \"xvr_client_dbus\\r\" \n# expect $prompt\n\nstart_xvr_debug $prompt\ntest_switch_channel_display $iter_cnt $interval $prompt \n# test_start_stop_pipeline $iter_cnt $interval $prompt \n\nexpect eof\n# interact\nwait\n~~~\n\n在具体使用中遇到的有几个小坑:\n\n1. 集成到 jenkins 时，jenkins 用户无法获得 `/dev/ttyUSB0` 权限。\n2. `sudo ` 执行 Expect 脚本进程 kill\n\n详情见尾注意小节。\n\n## 参考\n\n- [SecureCRT-python-scripts](https://blog.csdn.net/qq_14935437/article/details/78043904)\n- [Expect manual](https://linux.die.net/man/1/expect)\n- [Expect 使用教程](https://www.cnblogs.com/arlenhou/p/learn_expect.html)\n- [Expect interact & expect eof](https://blog.csdn.net/qq_20745901/article/details/54692610)\n\n## 注意\n\n1. 关于 jenkins 用户无法获取 `/dev/ttyUSB0` 权限\n\n   在这里最好不要直接使用 `sudo` ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。\n\n   解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。\n\n   ~~~bash\n   sudo usermod aG dialout jenkins\n   ~~~\n\n    \n\n2. sudo 执行的 expect 进程kill\n\n   `sudo killall -u USER expect `\n\n","slug":"DevOps/serial-port-debug-env-automation","published":1,"date":"2019-09-24T06:22:50.884Z","updated":"2019-09-24T06:51:24.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdqu0003qnn9w77l9ig6","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个</p>\n<ul>\n<li>重复命令手动输入执行</li>\n<li>交互性输入</li>\n<li>等待执行信息，不能自动保存到文件</li>\n<li>串口调试环境本身edit 便利性</li>\n</ul>\n<p>基于以上的问题，需要存在需求：</p>\n<ul>\n<li>可以将执行命令存放脚本中，而且可以去调用执行</li>\n<li>可处理交互性输入</li>\n<li>对于执行命令输出可以保存到 log 文件</li>\n</ul>\n<h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ol>\n<li><p>基于 SecureCRT </p>\n<p>SecureCRT 脚本，使用 python 语言</p>\n<p>优点：</p>\n<ul>\n<li>GUI 界面，操作直观</li>\n<li>python syntax 语法特性支持强大</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>SecureCRT 过重，本身安装麻烦</li>\n<li>仍然需要基本交互，SecureCRT 内调用脚本</li>\n<li>与 jenkins 的集成</li>\n</ul>\n</li>\n<li><p>基于 Terminal 环境</p>\n<p>首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。</p>\n<p>其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）</p>\n<p>最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。</p>\n<p>优点：</p>\n<ul>\n<li>轻量化，可通过命令行安装</li>\n<li>所有过程都在 Terminal 操作</li>\n<li>集成到 Jenkins，完全支持自动化流程</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>picocom 在功能性方面较弱</li>\n</ul>\n</li>\n</ol>\n<p>##实际解决</p>\n<p>针对上面两种方案，如果是非重复性调试，使用前者上手更快。</p>\n<p>如果有需要多次重复性，或者自动化测试需求，选择后者。</p>\n<p>下面给出使用 Expect 的一个 demo：</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/expect </span></span><br><span class=\"line\"><span class=\"comment\"># -d: debug mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># expect config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> timeout <span class=\"number\">30</span></span><br><span class=\"line\">log_file test-expect.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># picocom config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> baudrate <span class=\"string\">\"115200\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> device <span class=\"string\">\"/dev/ttyUSB0\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> prompt <span class=\"string\">\"=&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># function define</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> interval <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> iter_cnt <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> start_xvr_debug</span> &#123; prompt &#125; &#123;</span><br><span class=\"line\">    send <span class=\"string\">\"xvr_client_dbus\\r\"</span></span><br><span class=\"line\">    expect $prompt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">proc test_switch_channel_display &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125;  &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test_start_stop_pipeline</span> &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125; &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">spawn picocom -b $baudrate $device</span><br><span class=\"line\">expect <span class=\"string\">\"Terminal ready\\r\"</span></span><br><span class=\"line\">send <span class=\"string\">\"\\r\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send \"xvr_client_dbus\\r\" </span></span><br><span class=\"line\"><span class=\"comment\"># expect $prompt</span></span><br><span class=\"line\"></span><br><span class=\"line\">start_xvr_debug $prompt</span><br><span class=\"line\">test_switch_channel_display $iter_cnt $interval $prompt </span><br><span class=\"line\"><span class=\"comment\"># test_start_stop_pipeline $iter_cnt $interval $prompt </span></span><br><span class=\"line\"></span><br><span class=\"line\">expect <span class=\"keyword\">eof</span></span><br><span class=\"line\"><span class=\"comment\"># interact</span></span><br><span class=\"line\">wait</span><br></pre></td></tr></table></figure>\n<p>在具体使用中遇到的有几个小坑:</p>\n<ol>\n<li>集成到 jenkins 时，jenkins 用户无法获得 <code>/dev/ttyUSB0</code> 权限。</li>\n<li><code>sudo</code> 执行 Expect 脚本进程 kill</li>\n</ol>\n<p>详情见尾注意小节。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_14935437/article/details/78043904\" target=\"_blank\" rel=\"noopener\">SecureCRT-python-scripts</a></li>\n<li><a href=\"https://linux.die.net/man/1/expect\" target=\"_blank\" rel=\"noopener\">Expect manual</a></li>\n<li><a href=\"https://www.cnblogs.com/arlenhou/p/learn_expect.html\" target=\"_blank\" rel=\"noopener\">Expect 使用教程</a></li>\n<li><a href=\"https://blog.csdn.net/qq_20745901/article/details/54692610\" target=\"_blank\" rel=\"noopener\">Expect interact &amp; expect eof</a></li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li><p>关于 jenkins 用户无法获取 <code>/dev/ttyUSB0</code> 权限</p>\n<p>在这里最好不要直接使用 <code>sudo</code> ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。</p>\n<p>解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod aG dialout jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>sudo 执行的 expect 进程kill</p>\n<p><code>sudo killall -u USER expect</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在使用串口调试过程中，需要手动输入执行命令，交互性输入，以及等待执行结果。基本所有的信息都在 tty 中串行的进行显示。痛点有下面几个</p>\n<ul>\n<li>重复命令手动输入执行</li>\n<li>交互性输入</li>\n<li>等待执行信息，不能自动保存到文件</li>\n<li>串口调试环境本身edit 便利性</li>\n</ul>\n<p>基于以上的问题，需要存在需求：</p>\n<ul>\n<li>可以将执行命令存放脚本中，而且可以去调用执行</li>\n<li>可处理交互性输入</li>\n<li>对于执行命令输出可以保存到 log 文件</li>\n</ul>\n<h2 id=\"基本方案\"><a href=\"#基本方案\" class=\"headerlink\" title=\"基本方案\"></a>基本方案</h2><ol>\n<li><p>基于 SecureCRT </p>\n<p>SecureCRT 脚本，使用 python 语言</p>\n<p>优点：</p>\n<ul>\n<li>GUI 界面，操作直观</li>\n<li>python syntax 语法特性支持强大</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>SecureCRT 过重，本身安装麻烦</li>\n<li>仍然需要基本交互，SecureCRT 内调用脚本</li>\n<li>与 jenkins 的集成</li>\n</ul>\n</li>\n<li><p>基于 Terminal 环境</p>\n<p>首先要解决的是串口环境，这里使用 picocom 命令行工具，类似的有 minicom 等。</p>\n<p>其次，针对需要交互行输入，使用 Expect 处理，Expect 基于 TCL (Tool control language）</p>\n<p>最后，得到的 .expect 脚本可以通过 Jenkins pipeline 进行调用。</p>\n<p>优点：</p>\n<ul>\n<li>轻量化，可通过命令行安装</li>\n<li>所有过程都在 Terminal 操作</li>\n<li>集成到 Jenkins，完全支持自动化流程</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>picocom 在功能性方面较弱</li>\n</ul>\n</li>\n</ol>\n<p>##实际解决</p>\n<p>针对上面两种方案，如果是非重复性调试，使用前者上手更快。</p>\n<p>如果有需要多次重复性，或者自动化测试需求，选择后者。</p>\n<p>下面给出使用 Expect 的一个 demo：</p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/expect </span></span><br><span class=\"line\"><span class=\"comment\"># -d: debug mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># expect config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> timeout <span class=\"number\">30</span></span><br><span class=\"line\">log_file test-expect.log</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># picocom config</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> baudrate <span class=\"string\">\"115200\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> device <span class=\"string\">\"/dev/ttyUSB0\"</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> prompt <span class=\"string\">\"=&gt;\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># function define</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> interval <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> iter_cnt <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> start_xvr_debug</span> &#123; prompt &#125; &#123;</span><br><span class=\"line\">    send <span class=\"string\">\"xvr_client_dbus\\r\"</span></span><br><span class=\"line\">    expect $prompt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">proc test_switch_channel_display &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125;  &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 0 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"switch_channel_display -cam 0 -ch 1 -onoff 0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test_start_stop_pipeline</span> &#123; iter_cnt interval prompt &#125; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123; <span class=\"keyword\">set</span> i <span class=\"number\">1</span> &#125; &#123; $i &lt; $iter_cnt &#125; &#123; <span class=\"keyword\">incr</span> i <span class=\"number\">1</span> &#125; &#123;</span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"stop_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-0\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\"></span><br><span class=\"line\">        send <span class=\"string\">\"start_pipeline  /dev/xvr_pipeline-1\\r\"</span></span><br><span class=\"line\">        expect $prompt</span><br><span class=\"line\">        <span class=\"keyword\">exec</span> sleep $interval</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">spawn picocom -b $baudrate $device</span><br><span class=\"line\">expect <span class=\"string\">\"Terminal ready\\r\"</span></span><br><span class=\"line\">send <span class=\"string\">\"\\r\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send \"xvr_client_dbus\\r\" </span></span><br><span class=\"line\"><span class=\"comment\"># expect $prompt</span></span><br><span class=\"line\"></span><br><span class=\"line\">start_xvr_debug $prompt</span><br><span class=\"line\">test_switch_channel_display $iter_cnt $interval $prompt </span><br><span class=\"line\"><span class=\"comment\"># test_start_stop_pipeline $iter_cnt $interval $prompt </span></span><br><span class=\"line\"></span><br><span class=\"line\">expect <span class=\"keyword\">eof</span></span><br><span class=\"line\"><span class=\"comment\"># interact</span></span><br><span class=\"line\">wait</span><br></pre></td></tr></table></figure>\n<p>在具体使用中遇到的有几个小坑:</p>\n<ol>\n<li>集成到 jenkins 时，jenkins 用户无法获得 <code>/dev/ttyUSB0</code> 权限。</li>\n<li><code>sudo</code> 执行 Expect 脚本进程 kill</li>\n</ol>\n<p>详情见尾注意小节。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_14935437/article/details/78043904\" target=\"_blank\" rel=\"noopener\">SecureCRT-python-scripts</a></li>\n<li><a href=\"https://linux.die.net/man/1/expect\" target=\"_blank\" rel=\"noopener\">Expect manual</a></li>\n<li><a href=\"https://www.cnblogs.com/arlenhou/p/learn_expect.html\" target=\"_blank\" rel=\"noopener\">Expect 使用教程</a></li>\n<li><a href=\"https://blog.csdn.net/qq_20745901/article/details/54692610\" target=\"_blank\" rel=\"noopener\">Expect interact &amp; expect eof</a></li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ol>\n<li><p>关于 jenkins 用户无法获取 <code>/dev/ttyUSB0</code> 权限</p>\n<p>在这里最好不要直接使用 <code>sudo</code> ，使用 root 权限执行的坏处在于，当你想要中断 expect 脚本时，也必须使用 root 权限。并且在集成到 Jenkins 时，jenkins 用户起了 root 权限的进程，在中断 job 的时候。expect 任然在 jenkins node 上继续执行。</p>\n<p>解决的方案是将 jenkins 用户加入拥有 dev 设备权限的用户组。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod aG dialout jenkins</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>sudo 执行的 expect 进程kill</p>\n<p><code>sudo killall -u USER expect</code></p>\n</li>\n</ol>\n"},{"title":"Jenkins Testlink Plugin 源码笔记","_content":"\n\n## 需求\n\nTestlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。\n\njenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。\n\n## 思路\n\n首先查到官方 Testlink-plugin 的 repo https://github.com/jenkinsci/testlink-plugin\n\npull 到本地查看一下项目结构\n\n~~~bash\n├── pom.xml \t\t\t\t\t\t\n├── src\t\t\t\t\t\t\t\t\t\n│   ├── main\n│   │   ├── java\n│   │   ├── resources\n│   │   └── webapp\n│   └── test\n│       ├── java\n│       └── resources\n\n~~~\n\n其中主要代码存放在 src/main/hudson/plugins/testlink 下：\n\n~~~bash\n├── AbstractTestLinkBuilder.java\n├── AbstractTestLinkProjectAction.java\n├── GraphHelper.java\n├── Report.java\n├── TestLinkBuildAction.java\n├── TestLinkBuilder.java\n├── TestLinkBuilderDescriptor.java\n├── TestLinkInstallation.java\n├── TestLinkJunitWrapper.java\n├── TestLinkProjectAction.java\n├── TestLinkResult.java\n├── TestLinkSite.java\n├── result\n│   ├── AbstractJUnitResultSeeker.java\n│   ├── AbstractTAPFileNameResultSeeker.java\n│   ├── AbstractTestNGResultSeeker.java\n│   ├── JUnitCaseClassNameResultSeeker.java\n│   ├── JUnitCaseNameResultSeeker.java\n│   ├── JUnitMethodNameResultSeeker.java\n│   ├── JUnitSuiteNameResultSeeker.java\n│   ├── ResultSeeker.java\n│   ├── ResultSeekerDescriptor.java\n│   ├── ResultSeekerException.java\n│   ├── TAPFileNameMultiTestPointsResultSeeker.java\n│   ├── TAPFileNameResultSeeker.java\n│   ├── TestCaseWrapper.java\n│   ├── TestNGClassNameResultSeeker.java\n│   ├── TestNGMethodNameDataProviderNameResultSeeker.java\n│   ├── TestNGMethodNameResultSeeker.java\n│   └── TestNGSuiteNameResultSeeker.java\n└── util\n    ├── ExecutionOrderComparator.java\n    └── TestLinkHelper.java\n\n\n~~~\n\n现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java\n\n定位到 `perfrom()` 函数\n\n~~~java\npublic boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n\t// function body\t\t\n}\n~~~\n\n可以看到入参列表：\n\n`AbstractBuild<?, ?> build` \n\n`Launcher`\n\n`BuildListener `\n\n接下来看函数体内容：\n\n~~~java\n// TestLink installation\nlistener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());\nfinal TestLinkInstallation installation = DESCRIPTOR\n.getInstallationByTestLinkName(this.testLinkName);\nif (installation == null) {\nthrow new AbortException(Messages.TestLinkBuilder_InvalidTLAPI());\n}\n\n~~~\n\nTestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:\n\n包括 `name`, `url`, `devKey`, `testlinkJavaAPIPr\toperties`\n\n接下来是初始化其他的东西\n\n~~~java\nTestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);\n\nfinal TestLinkSite testLinkSite;\nfinal TestCaseWrapper[] automatedTestCases;\nfinal String testLinkUrl = installation.getUrl();\nfinal String testLinkDevKey = installation.getDevKey();\nTestPlan testPlan;\nlistener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));\n...\ntestLinkSite = this.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);\n~~~\n\n`TestlinkSite` 成员里有 `TestlinkAPI`, 可以通过传入 configuration 里面所设置的参数对 `Testlink` 进行操作。\n\n~~~java\nfinal String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getCustomFields());\n// Array of automated test cases\nTestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);\n\n// Retrieve custom fields in test plan\nfinal String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getTestPlanCustomFields());\ntestPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);\n\n// Transforms test cases into test case wrappers\nautomatedTestCases = this.transform(testCases);\n~~~\n\n获取 `CustomFields` ， 通过`TestlinkSite` 拿到对应的 `(List)Testcase`，转换为`(List)TestlinkWrapper `,  针对其进行了一层封装，具体细节看 `result/TestcaseWrapper.java`. \n\n~~~java\nfor(TestCaseWrapper tcw : automatedTestCases) {\n  testLinkSite.getReport().addTestCase(tcw);\n  if(LOGGER.isLoggable(Level.FINE)) {\n    LOGGER.log(Level.FINE, \"TestLink automated test case ID [\" + tcw.getId() + \"], name [\" +tcw.getName()+ \"]\");\n  }\n}\n~~~\n\n`TestSite`中有成员 `Report`，用来存储基本的 Testcase，以及 TestStatus 这些信息\n\n~~~java\nif(getResultSeekers() != null) {\n  for (ResultSeeker resultSeeker : getResultSeekers()) {\n    LOGGER.log(Level.INFO, \"Seeking test results. Using: \" + resultSeeker.getDescriptor().getDisplayName());\n    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);\n  }\n}\n~~~\n\n`ResultSeeker` 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。\n\n~~~java\nfinal Report report = testLinkSite.getReport();\nreport.tally();\n...\nfinal TestLinkResult result = new TestLinkResult(report);\nfinal TestLinkBuildAction buildAction = new TestLinkBuildAction(result);\nbuild.addAction(buildAction);\n~~~\n\n最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。\n\n执行逻辑结束。\n\n## 后记\n\n在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。\n\n在阅读源码的时候，获得了以下几个小的知识点\n\n- 从入口到各个模块的调用，是阅读源码的脉络\n- 不要一开始纠结于细节。大致了解各个功能模块的作用就行\n- 良好的抽象能力是关键技能","source":"_posts/DevOps/jenkins-testlink-plugin-source-code-note.md","raw":"---\ntitle: Jenkins Testlink Plugin 源码笔记\ntags:\n  - jenkins\n  - testlink\n  - plugin\ncategories:\n  - DevOps\n---\n\n\n## 需求\n\nTestlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。\n\njenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。\n\n## 思路\n\n首先查到官方 Testlink-plugin 的 repo https://github.com/jenkinsci/testlink-plugin\n\npull 到本地查看一下项目结构\n\n~~~bash\n├── pom.xml \t\t\t\t\t\t\n├── src\t\t\t\t\t\t\t\t\t\n│   ├── main\n│   │   ├── java\n│   │   ├── resources\n│   │   └── webapp\n│   └── test\n│       ├── java\n│       └── resources\n\n~~~\n\n其中主要代码存放在 src/main/hudson/plugins/testlink 下：\n\n~~~bash\n├── AbstractTestLinkBuilder.java\n├── AbstractTestLinkProjectAction.java\n├── GraphHelper.java\n├── Report.java\n├── TestLinkBuildAction.java\n├── TestLinkBuilder.java\n├── TestLinkBuilderDescriptor.java\n├── TestLinkInstallation.java\n├── TestLinkJunitWrapper.java\n├── TestLinkProjectAction.java\n├── TestLinkResult.java\n├── TestLinkSite.java\n├── result\n│   ├── AbstractJUnitResultSeeker.java\n│   ├── AbstractTAPFileNameResultSeeker.java\n│   ├── AbstractTestNGResultSeeker.java\n│   ├── JUnitCaseClassNameResultSeeker.java\n│   ├── JUnitCaseNameResultSeeker.java\n│   ├── JUnitMethodNameResultSeeker.java\n│   ├── JUnitSuiteNameResultSeeker.java\n│   ├── ResultSeeker.java\n│   ├── ResultSeekerDescriptor.java\n│   ├── ResultSeekerException.java\n│   ├── TAPFileNameMultiTestPointsResultSeeker.java\n│   ├── TAPFileNameResultSeeker.java\n│   ├── TestCaseWrapper.java\n│   ├── TestNGClassNameResultSeeker.java\n│   ├── TestNGMethodNameDataProviderNameResultSeeker.java\n│   ├── TestNGMethodNameResultSeeker.java\n│   └── TestNGSuiteNameResultSeeker.java\n└── util\n    ├── ExecutionOrderComparator.java\n    └── TestLinkHelper.java\n\n\n~~~\n\n现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java\n\n定位到 `perfrom()` 函数\n\n~~~java\npublic boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n\t// function body\t\t\n}\n~~~\n\n可以看到入参列表：\n\n`AbstractBuild<?, ?> build` \n\n`Launcher`\n\n`BuildListener `\n\n接下来看函数体内容：\n\n~~~java\n// TestLink installation\nlistener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());\nfinal TestLinkInstallation installation = DESCRIPTOR\n.getInstallationByTestLinkName(this.testLinkName);\nif (installation == null) {\nthrow new AbortException(Messages.TestLinkBuilder_InvalidTLAPI());\n}\n\n~~~\n\nTestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:\n\n包括 `name`, `url`, `devKey`, `testlinkJavaAPIPr\toperties`\n\n接下来是初始化其他的东西\n\n~~~java\nTestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);\n\nfinal TestLinkSite testLinkSite;\nfinal TestCaseWrapper[] automatedTestCases;\nfinal String testLinkUrl = installation.getUrl();\nfinal String testLinkDevKey = installation.getDevKey();\nTestPlan testPlan;\nlistener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));\n...\ntestLinkSite = this.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);\n~~~\n\n`TestlinkSite` 成员里有 `TestlinkAPI`, 可以通过传入 configuration 里面所设置的参数对 `Testlink` 进行操作。\n\n~~~java\nfinal String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getCustomFields());\n// Array of automated test cases\nTestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);\n\n// Retrieve custom fields in test plan\nfinal String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), this.getTestPlanCustomFields());\ntestPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);\n\n// Transforms test cases into test case wrappers\nautomatedTestCases = this.transform(testCases);\n~~~\n\n获取 `CustomFields` ， 通过`TestlinkSite` 拿到对应的 `(List)Testcase`，转换为`(List)TestlinkWrapper `,  针对其进行了一层封装，具体细节看 `result/TestcaseWrapper.java`. \n\n~~~java\nfor(TestCaseWrapper tcw : automatedTestCases) {\n  testLinkSite.getReport().addTestCase(tcw);\n  if(LOGGER.isLoggable(Level.FINE)) {\n    LOGGER.log(Level.FINE, \"TestLink automated test case ID [\" + tcw.getId() + \"], name [\" +tcw.getName()+ \"]\");\n  }\n}\n~~~\n\n`TestSite`中有成员 `Report`，用来存储基本的 Testcase，以及 TestStatus 这些信息\n\n~~~java\nif(getResultSeekers() != null) {\n  for (ResultSeeker resultSeeker : getResultSeekers()) {\n    LOGGER.log(Level.INFO, \"Seeking test results. Using: \" + resultSeeker.getDescriptor().getDisplayName());\n    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);\n  }\n}\n~~~\n\n`ResultSeeker` 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。\n\n~~~java\nfinal Report report = testLinkSite.getReport();\nreport.tally();\n...\nfinal TestLinkResult result = new TestLinkResult(report);\nfinal TestLinkBuildAction buildAction = new TestLinkBuildAction(result);\nbuild.addAction(buildAction);\n~~~\n\n最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。\n\n执行逻辑结束。\n\n## 后记\n\n在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。\n\n在阅读源码的时候，获得了以下几个小的知识点\n\n- 从入口到各个模块的调用，是阅读源码的脉络\n- 不要一开始纠结于细节。大致了解各个功能模块的作用就行\n- 良好的抽象能力是关键技能","slug":"DevOps/jenkins-testlink-plugin-source-code-note","published":1,"date":"2019-09-29T03:07:48.843Z","updated":"2019-09-29T03:21:25.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdr30006qnn90ycuxgf3","content":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>Testlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。</p>\n<p>jenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查到官方 Testlink-plugin 的 repo <a href=\"https://github.com/jenkinsci/testlink-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/testlink-plugin</a></p>\n<p>pull 到本地查看一下项目结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml \t\t\t\t\t\t</span><br><span class=\"line\">├── src\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java</span><br><span class=\"line\">│   │   ├── resources</span><br><span class=\"line\">│   │   └── webapp</span><br><span class=\"line\">│   └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│       ├── java</span><br><span class=\"line\">│       └── resources</span><br></pre></td></tr></table></figure>\n<p>其中主要代码存放在 src/main/hudson/plugins/testlink 下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── AbstractTestLinkBuilder.java</span><br><span class=\"line\">├── AbstractTestLinkProjectAction.java</span><br><span class=\"line\">├── GraphHelper.java</span><br><span class=\"line\">├── Report.java</span><br><span class=\"line\">├── TestLinkBuildAction.java</span><br><span class=\"line\">├── TestLinkBuilder.java</span><br><span class=\"line\">├── TestLinkBuilderDescriptor.java</span><br><span class=\"line\">├── TestLinkInstallation.java</span><br><span class=\"line\">├── TestLinkJunitWrapper.java</span><br><span class=\"line\">├── TestLinkProjectAction.java</span><br><span class=\"line\">├── TestLinkResult.java</span><br><span class=\"line\">├── TestLinkSite.java</span><br><span class=\"line\">├── result</span><br><span class=\"line\">│   ├── AbstractJUnitResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTestNGResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitMethodNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitSuiteNameResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeekerDescriptor.java</span><br><span class=\"line\">│   ├── ResultSeekerException.java</span><br><span class=\"line\">│   ├── TAPFileNameMultiTestPointsResultSeeker.java</span><br><span class=\"line\">│   ├── TAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestCaseWrapper.java</span><br><span class=\"line\">│   ├── TestNGClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameDataProviderNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameResultSeeker.java</span><br><span class=\"line\">│   └── TestNGSuiteNameResultSeeker.java</span><br><span class=\"line\">└── util</span><br><span class=\"line\">    ├── ExecutionOrderComparator.java</span><br><span class=\"line\">    └── TestLinkHelper.java</span><br></pre></td></tr></table></figure>\n<p>现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java</p>\n<p>定位到 <code>perfrom()</code> 函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">perform</span><span class=\"params\">(AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// function body\t\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入参列表：</p>\n<p><code>AbstractBuild&lt;?, ?&gt; build</code> </p>\n<p><code>Launcher</code></p>\n<p><code>BuildListener</code></p>\n<p>接下来看函数体内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestLink installation</span></span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkInstallation installation = DESCRIPTOR</span><br><span class=\"line\">.getInstallationByTestLinkName(<span class=\"keyword\">this</span>.testLinkName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installation == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AbortException(Messages.TestLinkBuilder_InvalidTLAPI());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:</p>\n<p>包括 <code>name</code>, <code>url</code>, <code>devKey</code>, <code>testlinkJavaAPIPr    operties</code></p>\n<p>接下来是初始化其他的东西</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkSite testLinkSite;</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestCaseWrapper[] automatedTestCases;</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkUrl = installation.getUrl();</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkDevKey = installation.getDevKey();</span><br><span class=\"line\">TestPlan testPlan;</span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));</span><br><span class=\"line\">...</span><br><span class=\"line\">testLinkSite = <span class=\"keyword\">this</span>.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);</span><br></pre></td></tr></table></figure>\n<p><code>TestlinkSite</code> 成员里有 <code>TestlinkAPI</code>, 可以通过传入 configuration 里面所设置的参数对 <code>Testlink</code> 进行操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getCustomFields());</span><br><span class=\"line\"><span class=\"comment\">// Array of automated test cases</span></span><br><span class=\"line\">TestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve custom fields in test plan</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getTestPlanCustomFields());</span><br><span class=\"line\">testPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Transforms test cases into test case wrappers</span></span><br><span class=\"line\">automatedTestCases = <span class=\"keyword\">this</span>.transform(testCases);</span><br></pre></td></tr></table></figure>\n<p>获取 <code>CustomFields</code> ， 通过<code>TestlinkSite</code> 拿到对应的 <code>(List)Testcase</code>，转换为<code>(List)TestlinkWrapper</code>,  针对其进行了一层封装，具体细节看 <code>result/TestcaseWrapper.java</code>. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(TestCaseWrapper tcw : automatedTestCases) &#123;</span><br><span class=\"line\">  testLinkSite.getReport().addTestCase(tcw);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.FINE, <span class=\"string\">\"TestLink automated test case ID [\"</span> + tcw.getId() + <span class=\"string\">\"], name [\"</span> +tcw.getName()+ <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TestSite</code>中有成员 <code>Report</code>，用来存储基本的 Testcase，以及 TestStatus 这些信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getResultSeekers() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ResultSeeker resultSeeker : getResultSeekers()) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.INFO, <span class=\"string\">\"Seeking test results. Using: \"</span> + resultSeeker.getDescriptor().getDisplayName());</span><br><span class=\"line\">    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ResultSeeker</code> 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Report report = testLinkSite.getReport();</span><br><span class=\"line\">report.tally();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkResult result = <span class=\"keyword\">new</span> TestLinkResult(report);</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkBuildAction buildAction = <span class=\"keyword\">new</span> TestLinkBuildAction(result);</span><br><span class=\"line\">build.addAction(buildAction);</span><br></pre></td></tr></table></figure>\n<p>最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。</p>\n<p>执行逻辑结束。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。</p>\n<p>在阅读源码的时候，获得了以下几个小的知识点</p>\n<ul>\n<li>从入口到各个模块的调用，是阅读源码的脉络</li>\n<li>不要一开始纠结于细节。大致了解各个功能模块的作用就行</li>\n<li>良好的抽象能力是关键技能</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>Testlink 的 testcase 可以通过 Jenkins 去执行，当 Jenkins job 执行完之后，可以将执行结果保存到 Testlink 中。</p>\n<p>jenkins 中 testlink plugin 仅仅可以在 freestyle 项目类型中使用，但目前大多数的 job 已经转移到 pipeline 类型，所以 testlink plugin 支持 pipeline 是一个自然的需要。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先查到官方 Testlink-plugin 的 repo <a href=\"https://github.com/jenkinsci/testlink-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/testlink-plugin</a></p>\n<p>pull 到本地查看一下项目结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── pom.xml \t\t\t\t\t\t</span><br><span class=\"line\">├── src\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java</span><br><span class=\"line\">│   │   ├── resources</span><br><span class=\"line\">│   │   └── webapp</span><br><span class=\"line\">│   └── <span class=\"built_in\">test</span></span><br><span class=\"line\">│       ├── java</span><br><span class=\"line\">│       └── resources</span><br></pre></td></tr></table></figure>\n<p>其中主要代码存放在 src/main/hudson/plugins/testlink 下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── AbstractTestLinkBuilder.java</span><br><span class=\"line\">├── AbstractTestLinkProjectAction.java</span><br><span class=\"line\">├── GraphHelper.java</span><br><span class=\"line\">├── Report.java</span><br><span class=\"line\">├── TestLinkBuildAction.java</span><br><span class=\"line\">├── TestLinkBuilder.java</span><br><span class=\"line\">├── TestLinkBuilderDescriptor.java</span><br><span class=\"line\">├── TestLinkInstallation.java</span><br><span class=\"line\">├── TestLinkJunitWrapper.java</span><br><span class=\"line\">├── TestLinkProjectAction.java</span><br><span class=\"line\">├── TestLinkResult.java</span><br><span class=\"line\">├── TestLinkSite.java</span><br><span class=\"line\">├── result</span><br><span class=\"line\">│   ├── AbstractJUnitResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── AbstractTestNGResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitCaseNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitMethodNameResultSeeker.java</span><br><span class=\"line\">│   ├── JUnitSuiteNameResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeeker.java</span><br><span class=\"line\">│   ├── ResultSeekerDescriptor.java</span><br><span class=\"line\">│   ├── ResultSeekerException.java</span><br><span class=\"line\">│   ├── TAPFileNameMultiTestPointsResultSeeker.java</span><br><span class=\"line\">│   ├── TAPFileNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestCaseWrapper.java</span><br><span class=\"line\">│   ├── TestNGClassNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameDataProviderNameResultSeeker.java</span><br><span class=\"line\">│   ├── TestNGMethodNameResultSeeker.java</span><br><span class=\"line\">│   └── TestNGSuiteNameResultSeeker.java</span><br><span class=\"line\">└── util</span><br><span class=\"line\">    ├── ExecutionOrderComparator.java</span><br><span class=\"line\">    └── TestLinkHelper.java</span><br></pre></td></tr></table></figure>\n<p>现在可以来对代码进行分析了，首先我们寻找到调用的入口 TestlinkBuilder.java</p>\n<p>定位到 <code>perfrom()</code> 函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">perform</span><span class=\"params\">(AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener)</span> <span class=\"keyword\">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// function body\t\t</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入参列表：</p>\n<p><code>AbstractBuild&lt;?, ?&gt; build</code> </p>\n<p><code>Launcher</code></p>\n<p><code>BuildListener</code></p>\n<p>接下来看函数体内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TestLink installation</span></span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_PreparingTLAPI());</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkInstallation installation = DESCRIPTOR</span><br><span class=\"line\">.getInstallationByTestLinkName(<span class=\"keyword\">this</span>.testLinkName);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (installation == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AbortException(Messages.TestLinkBuilder_InvalidTLAPI());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TestlinkInstallation 保存 configuration 里面对 Testlink 的配置信息:</p>\n<p>包括 <code>name</code>, <code>url</code>, <code>devKey</code>, <code>testlinkJavaAPIPr    operties</code></p>\n<p>接下来是初始化其他的东西</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestLinkHelper.setTestLinkJavaAPIProperties(installation.getTestLinkJavaAPIProperties(), listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkSite testLinkSite;</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestCaseWrapper[] automatedTestCases;</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkUrl = installation.getUrl();</span><br><span class=\"line\"><span class=\"keyword\">final</span> String testLinkDevKey = installation.getDevKey();</span><br><span class=\"line\">TestPlan testPlan;</span><br><span class=\"line\">listener.getLogger().println(Messages.TestLinkBuilder_UsedTLURL(testLinkUrl));</span><br><span class=\"line\">...</span><br><span class=\"line\">testLinkSite = <span class=\"keyword\">this</span>.getTestLinkSite(testLinkUrl, testLinkDevKey, testProjectName, testPlanName, platformName, buildName, buildCustomFields, buildNotes);</span><br></pre></td></tr></table></figure>\n<p><code>TestlinkSite</code> 成员里有 <code>TestlinkAPI</code>, 可以通过传入 configuration 里面所设置的参数对 <code>Testlink</code> 进行操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String[] testCaseCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getCustomFields());</span><br><span class=\"line\"><span class=\"comment\">// Array of automated test cases</span></span><br><span class=\"line\">TestCase[] testCases = testLinkSite.getAutomatedTestCases(testCaseCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve custom fields in test plan</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String[] testPlanCustomFieldsNames = TestLinkHelper.createArrayOfCustomFieldsNames(build.getBuildVariableResolver(), build.getEnvironment(listener), <span class=\"keyword\">this</span>.getTestPlanCustomFields());</span><br><span class=\"line\">testPlan = testLinkSite.getTestPlanWithCustomFields(testPlanCustomFieldsNames);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Transforms test cases into test case wrappers</span></span><br><span class=\"line\">automatedTestCases = <span class=\"keyword\">this</span>.transform(testCases);</span><br></pre></td></tr></table></figure>\n<p>获取 <code>CustomFields</code> ， 通过<code>TestlinkSite</code> 拿到对应的 <code>(List)Testcase</code>，转换为<code>(List)TestlinkWrapper</code>,  针对其进行了一层封装，具体细节看 <code>result/TestcaseWrapper.java</code>. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(TestCaseWrapper tcw : automatedTestCases) &#123;</span><br><span class=\"line\">  testLinkSite.getReport().addTestCase(tcw);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.FINE, <span class=\"string\">\"TestLink automated test case ID [\"</span> + tcw.getId() + <span class=\"string\">\"], name [\"</span> +tcw.getName()+ <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TestSite</code>中有成员 <code>Report</code>，用来存储基本的 Testcase，以及 TestStatus 这些信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getResultSeekers() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (ResultSeeker resultSeeker : getResultSeekers()) &#123;</span><br><span class=\"line\">    LOGGER.log(Level.INFO, <span class=\"string\">\"Seeking test results. Using: \"</span> + resultSeeker.getDescriptor().getDisplayName());</span><br><span class=\"line\">    resultSeeker.seek(automatedTestCases, build, build.getWorkspace(), launcher, listener, testLinkSite);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ResultSeeker</code> 通过执行测试用例得到的 *report.xml 文件解析得到相应 Testcase 的执行结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Report report = testLinkSite.getReport();</span><br><span class=\"line\">report.tally();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkResult result = <span class=\"keyword\">new</span> TestLinkResult(report);</span><br><span class=\"line\"><span class=\"keyword\">final</span> TestLinkBuildAction buildAction = <span class=\"keyword\">new</span> TestLinkBuildAction(result);</span><br><span class=\"line\">build.addAction(buildAction);</span><br></pre></td></tr></table></figure>\n<p>最后一步，生成 TestlinkReport，这里的对应的是 Jenkins 显示的report，而不是 TestlinkAPI 的 report。</p>\n<p>执行逻辑结束。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>在完成这篇文章之前，我对于能否清晰的表达出我的分析有很大的怀疑。我之前也曾阅读过源码，是关于数据结构的。针对大的，互相有依赖的，以一定代码规模的，我不曾分析过。</p>\n<p>在阅读源码的时候，获得了以下几个小的知识点</p>\n<ul>\n<li>从入口到各个模块的调用，是阅读源码的脉络</li>\n<li>不要一开始纠结于细节。大致了解各个功能模块的作用就行</li>\n<li>良好的抽象能力是关键技能</li>\n</ul>\n"},{"title":"VSCode插件开发入门","_content":"\n\n\n# VSCode 插件开发\n\n## 核心组件\n\n- Electron\n- Monaco Editor\n- Language Server Protocol\n- Debug Adapter Protocol\n\n### Electorn (formerly Atom Shell)\n\n- 基于 Node.js（作为后端）和 Chromium（作为前端)\n\n- 使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序\n\n-   使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …\n\n[Github传送门](https://github.com/electron/electron)\n\n### Monaca Editor\n\n- 基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …\n\n- 支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera\n\n- 使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools\n\n[GitHub传送门](https://github.com/Microsoft/monaco-editor )\n\n### Language Server Protocol (LSP)\n\n- 它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。\n\n- 支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs\n\n[GitHub传送门](https://github.com/Microsoft/language-server-protocol)\n\n### Debug Adapter Protocol (DAP)\n\n- DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。\n\n- 支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim \n\n[GitHub传送门](https://github.com/Microsoft/debug-adapter-protocol)\n\n## 插件开发流程\n\n### 开发环境\n\n- Visual Studio Code\n\n- Node.js\n\n  `npm -v` 查看是否安装成功\n\n- Yeoman and VS Code Extension generator:\n\n  `npm install -g yo generator-code`\n\n### 插件类型\n\n- Themes\n\n- Snippets\n\n- Formatters\n\n- Linters\n\n- Debuggers\n\n- Programming Languages\n\n- Keymaps\n\n- SCM Provides\n\n- Extensions Packs\n\n- Others\n\n### 如何搭建工程\n\n1. `yo code`\n2. 选择你搭建项目的类型\n3. 是否导入相关资源\n4. 选择名字\n\n\n\n### e.g. Color Thems\n\n### e.g. Code Snippet\n\n## VSCode 界面功能拓展\n\n- Workbench\n- Editor area\n\n### Workbench\n\n![image-20190331110014505](https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg)\n\n### Editor Area\n\n- Codelens\n- Decoration\n- Gutter\n- Hover\n- Context Menu\n\n### e.g. Translator Extension\n\n\n\n","source":"_posts/Tools/vscode-plugin-dev-intro.md","raw":"---\ntitle: VSCode插件开发入门\ntags:\n  - vscode\n  - plugin\ncategories:\n  - Tools\n---\n\n\n\n# VSCode 插件开发\n\n## 核心组件\n\n- Electron\n- Monaco Editor\n- Language Server Protocol\n- Debug Adapter Protocol\n\n### Electorn (formerly Atom Shell)\n\n- 基于 Node.js（作为后端）和 Chromium（作为前端)\n\n- 使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序\n\n-   使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …\n\n[Github传送门](https://github.com/electron/electron)\n\n### Monaca Editor\n\n- 基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …\n\n- 支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera\n\n- 使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools\n\n[GitHub传送门](https://github.com/Microsoft/monaco-editor )\n\n### Language Server Protocol (LSP)\n\n- 它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。\n\n- 支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs\n\n[GitHub传送门](https://github.com/Microsoft/language-server-protocol)\n\n### Debug Adapter Protocol (DAP)\n\n- DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。\n\n- 支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim \n\n[GitHub传送门](https://github.com/Microsoft/debug-adapter-protocol)\n\n## 插件开发流程\n\n### 开发环境\n\n- Visual Studio Code\n\n- Node.js\n\n  `npm -v` 查看是否安装成功\n\n- Yeoman and VS Code Extension generator:\n\n  `npm install -g yo generator-code`\n\n### 插件类型\n\n- Themes\n\n- Snippets\n\n- Formatters\n\n- Linters\n\n- Debuggers\n\n- Programming Languages\n\n- Keymaps\n\n- SCM Provides\n\n- Extensions Packs\n\n- Others\n\n### 如何搭建工程\n\n1. `yo code`\n2. 选择你搭建项目的类型\n3. 是否导入相关资源\n4. 选择名字\n\n\n\n### e.g. Color Thems\n\n### e.g. Code Snippet\n\n## VSCode 界面功能拓展\n\n- Workbench\n- Editor area\n\n### Workbench\n\n![image-20190331110014505](https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg)\n\n### Editor Area\n\n- Codelens\n- Decoration\n- Gutter\n- Hover\n- Context Menu\n\n### e.g. Translator Extension\n\n\n\n","slug":"Tools/vscode-plugin-dev-intro","published":1,"date":"2019-03-31T02:58:05.709Z","updated":"2019-09-24T06:51:24.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdr40007qnn9uagsz8tg","content":"<h1 id=\"VSCode-插件开发\"><a href=\"#VSCode-插件开发\" class=\"headerlink\" title=\"VSCode 插件开发\"></a>VSCode 插件开发</h1><h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><ul>\n<li>Electron</li>\n<li>Monaco Editor</li>\n<li>Language Server Protocol</li>\n<li>Debug Adapter Protocol</li>\n</ul>\n<h3 id=\"Electorn-formerly-Atom-Shell\"><a href=\"#Electorn-formerly-Atom-Shell\" class=\"headerlink\" title=\"Electorn (formerly Atom Shell)\"></a>Electorn (formerly Atom Shell)</h3><ul>\n<li><p>基于 Node.js（作为后端）和 Chromium（作为前端)</p>\n</li>\n<li><p>使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序</p>\n</li>\n<li><p>使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/electron/electron\" target=\"_blank\" rel=\"noopener\">Github传送门</a></p>\n<h3 id=\"Monaca-Editor\"><a href=\"#Monaca-Editor\" class=\"headerlink\" title=\"Monaca Editor\"></a>Monaca Editor</h3><ul>\n<li><p>基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …</p>\n</li>\n<li><p>支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera</p>\n</li>\n<li><p>使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/monaco-editor\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Language-Server-Protocol-LSP\"><a href=\"#Language-Server-Protocol-LSP\" class=\"headerlink\" title=\"Language Server Protocol (LSP)\"></a>Language Server Protocol (LSP)</h3><ul>\n<li><p>它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。</p>\n</li>\n<li><p>支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/language-server-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Debug-Adapter-Protocol-DAP\"><a href=\"#Debug-Adapter-Protocol-DAP\" class=\"headerlink\" title=\"Debug Adapter Protocol (DAP)\"></a>Debug Adapter Protocol (DAP)</h3><ul>\n<li><p>DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。</p>\n</li>\n<li><p>支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim </p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/debug-adapter-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h2 id=\"插件开发流程\"><a href=\"#插件开发流程\" class=\"headerlink\" title=\"插件开发流程\"></a>插件开发流程</h2><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><ul>\n<li><p>Visual Studio Code</p>\n</li>\n<li><p>Node.js</p>\n<p><code>npm -v</code> 查看是否安装成功</p>\n</li>\n<li><p>Yeoman and VS Code Extension generator:</p>\n<p><code>npm install -g yo generator-code</code></p>\n</li>\n</ul>\n<h3 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"插件类型\"></a>插件类型</h3><ul>\n<li><p>Themes</p>\n</li>\n<li><p>Snippets</p>\n</li>\n<li><p>Formatters</p>\n</li>\n<li><p>Linters</p>\n</li>\n<li><p>Debuggers</p>\n</li>\n<li><p>Programming Languages</p>\n</li>\n<li><p>Keymaps</p>\n</li>\n<li><p>SCM Provides</p>\n</li>\n<li><p>Extensions Packs</p>\n</li>\n<li><p>Others</p>\n</li>\n</ul>\n<h3 id=\"如何搭建工程\"><a href=\"#如何搭建工程\" class=\"headerlink\" title=\"如何搭建工程\"></a>如何搭建工程</h3><ol>\n<li><code>yo code</code></li>\n<li>选择你搭建项目的类型</li>\n<li>是否导入相关资源</li>\n<li>选择名字</li>\n</ol>\n<h3 id=\"e-g-Color-Thems\"><a href=\"#e-g-Color-Thems\" class=\"headerlink\" title=\"e.g. Color Thems\"></a>e.g. Color Thems</h3><h3 id=\"e-g-Code-Snippet\"><a href=\"#e-g-Code-Snippet\" class=\"headerlink\" title=\"e.g. Code Snippet\"></a>e.g. Code Snippet</h3><h2 id=\"VSCode-界面功能拓展\"><a href=\"#VSCode-界面功能拓展\" class=\"headerlink\" title=\"VSCode 界面功能拓展\"></a>VSCode 界面功能拓展</h2><ul>\n<li>Workbench</li>\n<li>Editor area</li>\n</ul>\n<h3 id=\"Workbench\"><a href=\"#Workbench\" class=\"headerlink\" title=\"Workbench\"></a>Workbench</h3><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg\" alt=\"image-20190331110014505\"></p>\n<h3 id=\"Editor-Area\"><a href=\"#Editor-Area\" class=\"headerlink\" title=\"Editor Area\"></a>Editor Area</h3><ul>\n<li>Codelens</li>\n<li>Decoration</li>\n<li>Gutter</li>\n<li>Hover</li>\n<li>Context Menu</li>\n</ul>\n<h3 id=\"e-g-Translator-Extension\"><a href=\"#e-g-Translator-Extension\" class=\"headerlink\" title=\"e.g. Translator Extension\"></a>e.g. Translator Extension</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"VSCode-插件开发\"><a href=\"#VSCode-插件开发\" class=\"headerlink\" title=\"VSCode 插件开发\"></a>VSCode 插件开发</h1><h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><ul>\n<li>Electron</li>\n<li>Monaco Editor</li>\n<li>Language Server Protocol</li>\n<li>Debug Adapter Protocol</li>\n</ul>\n<h3 id=\"Electorn-formerly-Atom-Shell\"><a href=\"#Electorn-formerly-Atom-Shell\" class=\"headerlink\" title=\"Electorn (formerly Atom Shell)\"></a>Electorn (formerly Atom Shell)</h3><ul>\n<li><p>基于 Node.js（作为后端）和 Chromium（作为前端)</p>\n</li>\n<li><p>使用 HTML, CSS 和 JavaScript 开发跨平台桌面GUI应用程序</p>\n</li>\n<li><p>使用者：Atom, Skype, GitHub Desktop, Slack, Microsoft Teams …</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/electron/electron\" target=\"_blank\" rel=\"noopener\">Github传送门</a></p>\n<h3 id=\"Monaca-Editor\"><a href=\"#Monaca-Editor\" class=\"headerlink\" title=\"Monaca Editor\"></a>Monaca Editor</h3><ul>\n<li><p>基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮，文件比较 …</p>\n</li>\n<li><p>支持主流浏览器：IE 11, Edge, Chrome, Firefox, Safari 和 Opera</p>\n</li>\n<li><p>使用者：Gitee Web IDE, Cloud Studio, Eclipse Che, Eclipse Theia,  Azure DevOps (原为 Visual Studio Team Services), OneDrive, Edge Dev Tools</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/monaco-editor\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Language-Server-Protocol-LSP\"><a href=\"#Language-Server-Protocol-LSP\" class=\"headerlink\" title=\"Language Server Protocol (LSP)\"></a>Language Server Protocol (LSP)</h3><ul>\n<li><p>它是 Editor/IDE 与语言服务器之间的一种协议，可以让不同的 Editor/IDE 方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。</p>\n</li>\n<li><p>支持 LSP 的开发工具: Eclipse IDE, Eclipse Theia, Atom, Sublime Text, Emacs</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/language-server-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h3 id=\"Debug-Adapter-Protocol-DAP\"><a href=\"#Debug-Adapter-Protocol-DAP\" class=\"headerlink\" title=\"Debug Adapter Protocol (DAP)\"></a>Debug Adapter Protocol (DAP)</h3><ul>\n<li><p>DAP 与 LSP 的目的类似，DAP 把 Editor/IDE 与 不同语言的 debugger 解耦，极大地方便了 Editor/IDE 与其他 Debugger 的集成。</p>\n</li>\n<li><p>支持 DAP 的开发工具: Eclipse IDE, Eclipse Theia, Emacs, Vim </p>\n</li>\n</ul>\n<p><a href=\"https://github.com/Microsoft/debug-adapter-protocol\" target=\"_blank\" rel=\"noopener\">GitHub传送门</a></p>\n<h2 id=\"插件开发流程\"><a href=\"#插件开发流程\" class=\"headerlink\" title=\"插件开发流程\"></a>插件开发流程</h2><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><ul>\n<li><p>Visual Studio Code</p>\n</li>\n<li><p>Node.js</p>\n<p><code>npm -v</code> 查看是否安装成功</p>\n</li>\n<li><p>Yeoman and VS Code Extension generator:</p>\n<p><code>npm install -g yo generator-code</code></p>\n</li>\n</ul>\n<h3 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"插件类型\"></a>插件类型</h3><ul>\n<li><p>Themes</p>\n</li>\n<li><p>Snippets</p>\n</li>\n<li><p>Formatters</p>\n</li>\n<li><p>Linters</p>\n</li>\n<li><p>Debuggers</p>\n</li>\n<li><p>Programming Languages</p>\n</li>\n<li><p>Keymaps</p>\n</li>\n<li><p>SCM Provides</p>\n</li>\n<li><p>Extensions Packs</p>\n</li>\n<li><p>Others</p>\n</li>\n</ul>\n<h3 id=\"如何搭建工程\"><a href=\"#如何搭建工程\" class=\"headerlink\" title=\"如何搭建工程\"></a>如何搭建工程</h3><ol>\n<li><code>yo code</code></li>\n<li>选择你搭建项目的类型</li>\n<li>是否导入相关资源</li>\n<li>选择名字</li>\n</ol>\n<h3 id=\"e-g-Color-Thems\"><a href=\"#e-g-Color-Thems\" class=\"headerlink\" title=\"e.g. Color Thems\"></a>e.g. Color Thems</h3><h3 id=\"e-g-Code-Snippet\"><a href=\"#e-g-Code-Snippet\" class=\"headerlink\" title=\"e.g. Code Snippet\"></a>e.g. Code Snippet</h3><h2 id=\"VSCode-界面功能拓展\"><a href=\"#VSCode-界面功能拓展\" class=\"headerlink\" title=\"VSCode 界面功能拓展\"></a>VSCode 界面功能拓展</h2><ul>\n<li>Workbench</li>\n<li>Editor area</li>\n</ul>\n<h3 id=\"Workbench\"><a href=\"#Workbench\" class=\"headerlink\" title=\"Workbench\"></a>Workbench</h3><p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcgy1g1lsn7x262j30uy0lk7bn.jpg\" alt=\"image-20190331110014505\"></p>\n<h3 id=\"Editor-Area\"><a href=\"#Editor-Area\" class=\"headerlink\" title=\"Editor Area\"></a>Editor Area</h3><ul>\n<li>Codelens</li>\n<li>Decoration</li>\n<li>Gutter</li>\n<li>Hover</li>\n<li>Context Menu</li>\n</ul>\n<h3 id=\"e-g-Translator-Extension\"><a href=\"#e-g-Translator-Extension\" class=\"headerlink\" title=\"e.g. Translator Extension\"></a>e.g. Translator Extension</h3>"},{"title":"Git 基础","_content":"\n## 版本控制\n\n### 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n### 为什么要版本控制\n\n有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n### 本地版本控制系统\n\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n![本地版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png)\n\n### 集中化的版本控制系统\n\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 \n\n集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n![集中化的版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png)\n\n这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：\n\n- **单点故障：** 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n- **必须联网才能工作：** 受网络状况、带宽影响。\n\n### 分布式版本控制系统\n\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。\n\n这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n\n![分布式版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png)\n\n分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n## 认识 Git\n\n### Git 简史\n\nLinux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 \n\n### Git 与其他版本管理系统的主要区别\n\n Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。\n\n下面我们主要说一个关于 Git 其他版本管理系统的主要差别：**对待数据的方式**。\n\n**Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。**\n\n大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统**将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。**\n\n具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"/>\n</br>\n</div>\n\n**我们怎样才能得到一个文件的最终版本呢？**\n\n很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。\n\n**这种方式有什么问题呢？**\n\n比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"/>\n</br>\n</div>\n\n\n### Git 的三种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n1. **已提交（committed）**：数据已经安全的保存在本地数据库中。\n2. **已修改（modified）**：已修改表示修改了文件，但还没保存到数据库中。\n3. **已暂存（staged）**：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：**Git 仓库(.git directoty) **、**工作目录(Working Directory)** 以及 **暂存区域(Staging Area)** 。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"/>\n</div>\n\n**基本的 Git 工作流程如下：**\n\n1. 在工作目录中修改文件。\n2. 暂存文件，将文件的快照放入暂存区域。\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n## Git 使用快速入门\n\n### 获取 Git 仓库\n\n有两种取得 Git 项目仓库的方法。\n\n1. 在现有目录中初始化仓库: 进入项目目录运行  `git init`  命令,该命令将创建一个名为 `.git` 的子目录。\n2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url]` directoryname \n\n### 记录每次更新到仓库\n\n1. **检测当前文件状态** : `git status`\n2. **提出更改（把它们添加到暂存区**）：`git add filename ` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）\n3. **忽略文件**：`.gitignore` 文件\n4. **提交更新:** `git commit -m \"代码提交信息\"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）\n5. **跳过使用暂存区域更新的方式** : `git commit -a -m \"代码提交信息\"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。\n6. **移除文件** ：`git rm filename`  （从暂存区域移除，然后提交。）\n7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)\n\n### 推送改动到远程仓库\n\n- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git` \n- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)\n\n  如此你就能够将你的改动推送到所添加的服务器上去了。\n\n### 远程仓库的移除与重命名\n\n- 将 test 重命名位 test1：`git remote rename test test1`\n- 移除远程仓库 test1:`git remote rm test1`\n\n### 查看提交历史\n\n在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。\n\n**可以添加一些参数来查看自己希望看到的内容：**\n\n只看某个人的提交记录：\n\n```shell\ngit log --author=bob\n```\n\n### 撤销操作\n\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：\n\n```console\ngit commit --amend\n```\n\n取消暂存的文件\n\n```console\ngit reset filename\n```\n\n撤消对文件的修改:\n\n```\ngit checkout -- filename\n```\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n\n```\ngit fetch origin\ngit reset --hard origin/master\n```\n\n\n\n### 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n\n创建一个名字叫做 test 的分支\n\n```console\ngit branch test\n```\n\n切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n\n```console\ngit checkout test\n```\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"/>\n</div>\n\n你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n\n```console\ngit checkout -b feature_x\n```\n\n切换到主分支\n\n```\ngit checkout master\n```\n\n合并分支(可能会有冲突)\n\n```java\n git merge test\n```\n\n把新建的分支删掉\n\n```\ngit branch -d feature_x\n```\n\n将分支推送到远端仓库（推送成功后其他人可见）：\n\n```\ngit push origin \n```\n\n\n\n## 推荐阅读\n\n- [Git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n- [图解Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n- [猴子都能懂得Git入门](https://backlog.com/git-tutorial/cn/intro/intro1_1.html)\n- [Pro Git](https://git-scm.com/book/en/v2)\n","source":"_posts/Git/introduce-git.md","raw":"---\ntitle: Git 基础\ncategories:\n  - Git\ntags:\n  - tools\n---\n\n## 版本控制\n\n### 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n### 为什么要版本控制\n\n有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n### 本地版本控制系统\n\n许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n![本地版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png)\n\n### 集中化的版本控制系统\n\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 \n\n集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n![集中化的版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png)\n\n这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：\n\n- **单点故障：** 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n- **必须联网才能工作：** 受网络状况、带宽影响。\n\n### 分布式版本控制系统\n\n于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。\n\n这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n\n![分布式版本控制系统](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png)\n\n分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n## 认识 Git\n\n### Git 简史\n\nLinux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 \n\n### Git 与其他版本管理系统的主要区别\n\n Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。\n\n下面我们主要说一个关于 Git 其他版本管理系统的主要差别：**对待数据的方式**。\n\n**Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。**\n\n大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统**将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。**\n\n具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"/>\n</br>\n</div>\n\n**我们怎样才能得到一个文件的最终版本呢？**\n\n很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。\n\n**这种方式有什么问题呢？**\n\n比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。\n\nGit 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"/>\n</br>\n</div>\n\n\n### Git 的三种状态\n\nGit 有三种状态，你的文件可能处于其中之一：\n\n1. **已提交（committed）**：数据已经安全的保存在本地数据库中。\n2. **已修改（modified）**：已修改表示修改了文件，但还没保存到数据库中。\n3. **已暂存（staged）**：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n由此引入 Git 项目的三个工作区域的概念：**Git 仓库(.git directoty) **、**工作目录(Working Directory)** 以及 **暂存区域(Staging Area)** 。\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"/>\n</div>\n\n**基本的 Git 工作流程如下：**\n\n1. 在工作目录中修改文件。\n2. 暂存文件，将文件的快照放入暂存区域。\n3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n## Git 使用快速入门\n\n### 获取 Git 仓库\n\n有两种取得 Git 项目仓库的方法。\n\n1. 在现有目录中初始化仓库: 进入项目目录运行  `git init`  命令,该命令将创建一个名为 `.git` 的子目录。\n2. 从一个服务器克隆一个现有的 Git 仓库: `git clone [url]` 自定义本地仓库的名字: `git clone [url]` directoryname \n\n### 记录每次更新到仓库\n\n1. **检测当前文件状态** : `git status`\n2. **提出更改（把它们添加到暂存区**）：`git add filename ` (针对特定文件)、`git add *`(所有文件)、`git add *.txt`（支持通配符，所有 .txt 文件）\n3. **忽略文件**：`.gitignore` 文件\n4. **提交更新:** `git commit -m \"代码提交信息\"` （每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`）\n5. **跳过使用暂存区域更新的方式** : `git commit -a -m \"代码提交信息\"`。 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤。\n6. **移除文件** ：`git rm filename`  （从暂存区域移除，然后提交。）\n7. **对文件重命名** ：`git mv README.md README`(这个命令相当于`mv README.md README`、`git rm README.md`、`git add README` 这三条命令的集合)\n\n### 推送改动到远程仓库\n\n- 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·`git remote add origin <server>` ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样`git remote add origin https://github.com/Snailclimb/test.git` \n- 将这些改动提交到远端仓库：`git push origin master` (可以把 *master* 换成你想要推送的任何分支)\n\n  如此你就能够将你的改动推送到所添加的服务器上去了。\n\n### 远程仓库的移除与重命名\n\n- 将 test 重命名位 test1：`git remote rename test test1`\n- 移除远程仓库 test1:`git remote rm test1`\n\n### 查看提交历史\n\n在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 `git log` 命令。`git log` 会按提交时间列出所有的更新，最近的更新排在最上面。\n\n**可以添加一些参数来查看自己希望看到的内容：**\n\n只看某个人的提交记录：\n\n```shell\ngit log --author=bob\n```\n\n### 撤销操作\n\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 `--amend` 选项的提交命令尝试重新提交：\n\n```console\ngit commit --amend\n```\n\n取消暂存的文件\n\n```console\ngit reset filename\n```\n\n撤消对文件的修改:\n\n```\ngit checkout -- filename\n```\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n\n```\ngit fetch origin\ngit reset --hard origin/master\n```\n\n\n\n### 分支\n\n分支是用来将特性开发绝缘开来的。在你创建仓库的时候，*master* 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n\n创建一个名字叫做 test 的分支\n\n```console\ngit branch test\n```\n\n切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n\n```console\ngit checkout test\n```\n\n<div align=\"center\">  \n<img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"/>\n</div>\n\n你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n\n```console\ngit checkout -b feature_x\n```\n\n切换到主分支\n\n```\ngit checkout master\n```\n\n合并分支(可能会有冲突)\n\n```java\n git merge test\n```\n\n把新建的分支删掉\n\n```\ngit branch -d feature_x\n```\n\n将分支推送到远端仓库（推送成功后其他人可见）：\n\n```\ngit push origin \n```\n\n\n\n## 推荐阅读\n\n- [Git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n- [图解Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n- [猴子都能懂得Git入门](https://backlog.com/git-tutorial/cn/intro/intro1_1.html)\n- [Pro Git](https://git-scm.com/book/en/v2)\n","slug":"Git/introduce-git","published":1,"date":"2019-03-22T10:16:45.422Z","updated":"2019-03-24T04:54:50.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gds6000uqnn92mzcdqj1","content":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><h3 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>\n<h3 id=\"为什么要版本控制\"><a href=\"#为什么要版本控制\" class=\"headerlink\" title=\"为什么要版本控制\"></a>为什么要版本控制</h3><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>\n<h3 id=\"本地版本控制系统\"><a href=\"#本地版本控制系统\" class=\"headerlink\" title=\"本地版本控制系统\"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>\n<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png\" alt=\"本地版本控制系统\"></p>\n<h3 id=\"集中化的版本控制系统\"><a href=\"#集中化的版本控制系统\" class=\"headerlink\" title=\"集中化的版本控制系统\"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 </p>\n<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png\" alt=\"集中化的版本控制系统\"></p>\n<p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>\n<ul>\n<li><strong>单点故障：</strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</li>\n<li><strong>必须联网才能工作：</strong> 受网络状况、带宽影响。</li>\n</ul>\n<h3 id=\"分布式版本控制系统\"><a href=\"#分布式版本控制系统\" class=\"headerlink\" title=\"分布式版本控制系统\"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p>\n<p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png\" alt=\"分布式版本控制系统\"></p>\n<p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>\n<p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。</p>\n<h2 id=\"认识-Git\"><a href=\"#认识-Git\" class=\"headerlink\" title=\"认识 Git\"></a>认识 Git</h2><h3 id=\"Git-简史\"><a href=\"#Git-简史\" class=\"headerlink\" title=\"Git 简史\"></a>Git 简史</h3><p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 </p>\n<h3 id=\"Git-与其他版本管理系统的主要区别\"><a href=\"#Git-与其他版本管理系统的主要区别\" class=\"headerlink\" title=\"Git 与其他版本管理系统的主要区别\"></a>Git 与其他版本管理系统的主要区别</h3><p> Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p>\n<p>下面我们主要说一个关于 Git 其他版本管理系统的主要差别：<strong>对待数据的方式</strong>。</p>\n<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>\n<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>\n<p>具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"><br><br><br></div>\n\n<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>\n<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>\n<p><strong>这种方式有什么问题呢？</strong></p>\n<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>\n<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"><br><br><br></div>\n\n\n<h3 id=\"Git-的三种状态\"><a href=\"#Git-的三种状态\" class=\"headerlink\" title=\"Git 的三种状态\"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>\n<ol>\n<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>\n<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>\n<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>\n</ol>\n<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) </strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"><br></div>\n\n<p><strong>基本的 Git 工作流程如下：</strong></p>\n<ol>\n<li>在工作目录中修改文件。</li>\n<li>暂存文件，将文件的快照放入暂存区域。</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>\n</ol>\n<h2 id=\"Git-使用快速入门\"><a href=\"#Git-使用快速入门\" class=\"headerlink\" title=\"Git 使用快速入门\"></a>Git 使用快速入门</h2><h3 id=\"获取-Git-仓库\"><a href=\"#获取-Git-仓库\" class=\"headerlink\" title=\"获取 Git 仓库\"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>\n<ol>\n<li>在现有目录中初始化仓库: 进入项目目录运行  <code>git init</code>  命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>\n<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname </li>\n</ol>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><ol>\n<li><strong>检测当前文件状态</strong> : <code>git status</code></li>\n<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>\n<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>\n<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>\n<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>\n<li><strong>移除文件</strong> ：<code>git rm filename</code>  （从暂存区域移除，然后提交。）</li>\n<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>\n</ol>\n<h3 id=\"推送改动到远程仓库\"><a href=\"#推送改动到远程仓库\" class=\"headerlink\" title=\"推送改动到远程仓库\"></a>推送改动到远程仓库</h3><ul>\n<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code> </li>\n<li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>\n<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库的移除与重命名\"><a href=\"#远程仓库的移除与重命名\" class=\"headerlink\" title=\"远程仓库的移除与重命名\"></a>远程仓库的移除与重命名</h3><ul>\n<li>将 test 重命名位 test1：<code>git remote rename test test1</code></li>\n<li>移除远程仓库 test1:<code>git remote rm test1</code></li>\n</ul>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>\n<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>\n<p>只看某个人的提交记录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --author=bob</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>取消暂存的文件</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset filename</span><br></pre></td></tr></table></figure>\n<p>撤消对文件的修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>\n<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>\n<p>创建一个名字叫做 test 的分支</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch test</span><br></pre></td></tr></table></figure>\n<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout test</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"><br></div>\n\n<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature_x</span><br></pre></td></tr></table></figure>\n<p>切换到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>合并分支(可能会有冲突)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n<p>把新建的分支删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature_x</span><br></pre></td></tr></table></figure>\n<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git - 简明指南</a></li>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"https://backlog.com/git-tutorial/cn/intro/intro1_1.html\" target=\"_blank\" rel=\"noopener\">猴子都能懂得Git入门</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><h3 id=\"什么是版本控制\"><a href=\"#什么是版本控制\" class=\"headerlink\" title=\"什么是版本控制\"></a>什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>\n<h3 id=\"为什么要版本控制\"><a href=\"#为什么要版本控制\" class=\"headerlink\" title=\"为什么要版本控制\"></a>为什么要版本控制</h3><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>\n<h3 id=\"本地版本控制系统\"><a href=\"#本地版本控制系统\" class=\"headerlink\" title=\"本地版本控制系统\"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p>\n<p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/本地版本控制系统.png\" alt=\"本地版本控制系统\"></p>\n<h3 id=\"集中化的版本控制系统\"><a href=\"#集中化的版本控制系统\" class=\"headerlink\" title=\"集中化的版本控制系统\"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 </p>\n<p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/集中化的版本控制系统.png\" alt=\"集中化的版本控制系统\"></p>\n<p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>\n<ul>\n<li><strong>单点故障：</strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</li>\n<li><strong>必须联网才能工作：</strong> 受网络状况、带宽影响。</li>\n</ul>\n<h3 id=\"分布式版本控制系统\"><a href=\"#分布式版本控制系统\" class=\"headerlink\" title=\"分布式版本控制系统\"></a>分布式版本控制系统</h3><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p>\n<p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/分布式版本控制系统.png\" alt=\"分布式版本控制系统\"></p>\n<p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>\n<p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。</p>\n<h2 id=\"认识-Git\"><a href=\"#认识-Git\" class=\"headerlink\" title=\"认识 Git\"></a>认识 Git</h2><h3 id=\"Git-简史\"><a href=\"#Git-简史\" class=\"headerlink\" title=\"Git 简史\"></a>Git 简史</h3><p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。 </p>\n<h3 id=\"Git-与其他版本管理系统的主要区别\"><a href=\"#Git-与其他版本管理系统的主要区别\" class=\"headerlink\" title=\"Git 与其他版本管理系统的主要区别\"></a>Git 与其他版本管理系统的主要区别</h3><p> Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。</p>\n<p>下面我们主要说一个关于 Git 其他版本管理系统的主要差别：<strong>对待数据的方式</strong>。</p>\n<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>\n<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>\n<p>具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号Δ(Delta)表示。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3deltas.png\" width=\"500px\"><br><br><br></div>\n\n<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>\n<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>\n<p><strong>这种方式有什么问题呢？</strong></p>\n<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>\n<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3snapshots.png\" width=\"500px\"><br><br><br></div>\n\n\n<h3 id=\"Git-的三种状态\"><a href=\"#Git-的三种状态\" class=\"headerlink\" title=\"Git 的三种状态\"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>\n<ol>\n<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>\n<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>\n<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>\n</ol>\n<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) </strong>、<strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png\" width=\"500px\"><br></div>\n\n<p><strong>基本的 Git 工作流程如下：</strong></p>\n<ol>\n<li>在工作目录中修改文件。</li>\n<li>暂存文件，将文件的快照放入暂存区域。</li>\n<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>\n</ol>\n<h2 id=\"Git-使用快速入门\"><a href=\"#Git-使用快速入门\" class=\"headerlink\" title=\"Git 使用快速入门\"></a>Git 使用快速入门</h2><h3 id=\"获取-Git-仓库\"><a href=\"#获取-Git-仓库\" class=\"headerlink\" title=\"获取 Git 仓库\"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>\n<ol>\n<li>在现有目录中初始化仓库: 进入项目目录运行  <code>git init</code>  命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>\n<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname </li>\n</ol>\n<h3 id=\"记录每次更新到仓库\"><a href=\"#记录每次更新到仓库\" class=\"headerlink\" title=\"记录每次更新到仓库\"></a>记录每次更新到仓库</h3><ol>\n<li><strong>检测当前文件状态</strong> : <code>git status</code></li>\n<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>\n<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>\n<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>\n<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>\n<li><strong>移除文件</strong> ：<code>git rm filename</code>  （从暂存区域移除，然后提交。）</li>\n<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>\n</ol>\n<h3 id=\"推送改动到远程仓库\"><a href=\"#推送改动到远程仓库\" class=\"headerlink\" title=\"推送改动到远程仓库\"></a>推送改动到远程仓库</h3><ul>\n<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code> </li>\n<li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>\n<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库的移除与重命名\"><a href=\"#远程仓库的移除与重命名\" class=\"headerlink\" title=\"远程仓库的移除与重命名\"></a>远程仓库的移除与重命名</h3><ul>\n<li>将 test 重命名位 test1：<code>git remote rename test test1</code></li>\n<li>移除远程仓库 test1:<code>git remote rm test1</code></li>\n</ul>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>\n<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>\n<p>只看某个人的提交记录：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --author=bob</span><br></pre></td></tr></table></figure>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n<p>取消暂存的文件</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset filename</span><br></pre></td></tr></table></figure>\n<p>撤消对文件的修改:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>\n<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>\n<p>创建一个名字叫做 test 的分支</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch test</span><br></pre></td></tr></table></figure>\n<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout test</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><br><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3切换分支.png\" width=\"500px\"><br></div>\n\n<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature_x</span><br></pre></td></tr></table></figure>\n<p>切换到主分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>合并分支(可能会有冲突)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge test</span><br></pre></td></tr></table></figure>\n<p>把新建的分支删掉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature_x</span><br></pre></td></tr></table></figure>\n<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><ul>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git - 简明指南</a></li>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">图解Git</a></li>\n<li><a href=\"https://backlog.com/git-tutorial/cn/intro/intro1_1.html\" target=\"_blank\" rel=\"noopener\">猴子都能懂得Git入门</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"noopener\">Pro Git</a></li>\n</ul>\n"},{"title":"判断是否为二叉搜索树（BST）","_content":"\n\n\n## 问题描述\n\n实现一个函数，判断一棵二叉树是否为二叉搜索树。\n\n\n\n## 算法思路\n\n- 二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。\n- 上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。\n- 基于left < current < right的特性，可以递归用大小值比较进行判断\n\n\n\n## 代码实现\n\n~~~cpp\n/* \n题目描述 \n \n请实现一个函数，检查一棵二叉树是否为二叉搜索树。 \n给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 \n*/  \n  \n#include <iostream>  \n#include <cstdlib>  \n#include <vector>  \n#include <queue>  \n  \nusing namespace std;  \n  \n/*二叉树节点数据结构*/  \nstruct TreeNode {  \n    int val;  \n    struct TreeNode *left;  \n    struct TreeNode *right;  \n    TreeNode(int x) :  \n        val(x), left(NULL), right(NULL) {  \n    }  \n};  \n  \nconst int flag = INT_MAX;  \nTreeNode *generateTree(vector<int> &nums)  \n{  \n    if (nums.empty())  \n        return NULL;  \n  \n    TreeNode *root = new TreeNode(nums[0]);  \n    queue<TreeNode *> que;  \n    que.push(root);  \n    //求出所给元素个数，对应二叉查找树节点个数  \n    int size = nums.size();  \n    for (int i = 1; i < size; i += 2)  \n    {  \n        //处理队首节点的左右子树  \n        TreeNode *tmp = que.front();  \n        TreeNode *left = NULL, *right = NULL;  \n        //定义非空左子树  \n        if (nums[i] != flag)  \n        {  \n            left = new TreeNode(nums[i]);  \n            que.push(left);  \n        }  \n  \n        //定义非空右子树  \n        if (i + 1 < size && nums[i + 1] != flag)  \n        {  \n            right = new TreeNode(nums[i + 1]);  \n            que.push(right);  \n        }  \n  \n        tmp->left = left;  \n        tmp->right = right;  \n        //弹出当前处理的节点  \n        que.pop();  \n    }  \n    return root;  \n}  \n  \nclass Checker {  \npublic:  \n  \n    /*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/  \n    void inOrder(TreeNode *root,vector<int> &v)  \n    {  \n        if (root == NULL)  \n            return;  \n        inOrder(root->left, v);  \n        v.push_back(root->val);  \n        inOrder(root->right, v);  \n    }  \n  \n    bool checkBST1(TreeNode* root)  \n    {  \n        vector<int> ret;  \n        inOrder(root, ret);  \n        for (auto i = ret.begin()+1; i != ret.end(); ++i)  \n        {  \n            if (*i < *(i - 1))  \n                return false;  \n        }  \n        return true;  \n    }  \n  \n    /*方法二、省掉线性空间，保存遍历的最后一个节点*/  \n    int lastVal = INT_MIN;  \n    bool checkBST2(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n  \n        /*递归检查左子树*/  \n        if (!checkBST2(root->left))  \n            return false;  \n  \n        /*比较当前节点，并更新已遍历节点最后的值*/  \n        if (root->val <= lastVal)  \n            return false;  \n        lastVal = root->val;  \n  \n        /*递归检查右子树*/  \n        if (!checkBST2(root->right))  \n            return false;  \n        return true;  \n    }  \n  \n    /*方法三，最大最小值法*/  \n    bool checkBST3(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n        return checkBST3(root, INT_MAX, INT_MIN);  \n    }  \n    bool checkBST3(TreeNode *root, int maxVal, int minVal)  \n    {  \n        if (!root)  \n            return true;  \n        if (root->val < minVal || root->val >= maxVal)  \n            return false;  \n        if (!checkBST3(root->left, root->val, minVal) || !checkBST3(root->right, maxVal, root->val))  \n            return false;  \n        return true;  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v = { 7, 6, flag, 4, flag, 2, 5, 8, 3, flag, flag, flag, flag, flag, flag };  \n    TreeNode *root = generateTree(v);  \n  \n    Checker c;  \n    bool ret = c.checkBST1(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST2(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST3(root);  \n  \n    cout << ret << endl;  \n  \n    system(\"pause\");  \n    return 0;  \n}  \n~~~\n\n","source":"_posts/Algorithm/Data-Structure/isBST.md","raw":"---\ntitle: 判断是否为二叉搜索树（BST）\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - tree\n---\n\n\n\n## 问题描述\n\n实现一个函数，判断一棵二叉树是否为二叉搜索树。\n\n\n\n## 算法思路\n\n- 二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。\n- 上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。\n- 基于left < current < right的特性，可以递归用大小值比较进行判断\n\n\n\n## 代码实现\n\n~~~cpp\n/* \n题目描述 \n \n请实现一个函数，检查一棵二叉树是否为二叉搜索树。 \n给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 \n*/  \n  \n#include <iostream>  \n#include <cstdlib>  \n#include <vector>  \n#include <queue>  \n  \nusing namespace std;  \n  \n/*二叉树节点数据结构*/  \nstruct TreeNode {  \n    int val;  \n    struct TreeNode *left;  \n    struct TreeNode *right;  \n    TreeNode(int x) :  \n        val(x), left(NULL), right(NULL) {  \n    }  \n};  \n  \nconst int flag = INT_MAX;  \nTreeNode *generateTree(vector<int> &nums)  \n{  \n    if (nums.empty())  \n        return NULL;  \n  \n    TreeNode *root = new TreeNode(nums[0]);  \n    queue<TreeNode *> que;  \n    que.push(root);  \n    //求出所给元素个数，对应二叉查找树节点个数  \n    int size = nums.size();  \n    for (int i = 1; i < size; i += 2)  \n    {  \n        //处理队首节点的左右子树  \n        TreeNode *tmp = que.front();  \n        TreeNode *left = NULL, *right = NULL;  \n        //定义非空左子树  \n        if (nums[i] != flag)  \n        {  \n            left = new TreeNode(nums[i]);  \n            que.push(left);  \n        }  \n  \n        //定义非空右子树  \n        if (i + 1 < size && nums[i + 1] != flag)  \n        {  \n            right = new TreeNode(nums[i + 1]);  \n            que.push(right);  \n        }  \n  \n        tmp->left = left;  \n        tmp->right = right;  \n        //弹出当前处理的节点  \n        que.pop();  \n    }  \n    return root;  \n}  \n  \nclass Checker {  \npublic:  \n  \n    /*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/  \n    void inOrder(TreeNode *root,vector<int> &v)  \n    {  \n        if (root == NULL)  \n            return;  \n        inOrder(root->left, v);  \n        v.push_back(root->val);  \n        inOrder(root->right, v);  \n    }  \n  \n    bool checkBST1(TreeNode* root)  \n    {  \n        vector<int> ret;  \n        inOrder(root, ret);  \n        for (auto i = ret.begin()+1; i != ret.end(); ++i)  \n        {  \n            if (*i < *(i - 1))  \n                return false;  \n        }  \n        return true;  \n    }  \n  \n    /*方法二、省掉线性空间，保存遍历的最后一个节点*/  \n    int lastVal = INT_MIN;  \n    bool checkBST2(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n  \n        /*递归检查左子树*/  \n        if (!checkBST2(root->left))  \n            return false;  \n  \n        /*比较当前节点，并更新已遍历节点最后的值*/  \n        if (root->val <= lastVal)  \n            return false;  \n        lastVal = root->val;  \n  \n        /*递归检查右子树*/  \n        if (!checkBST2(root->right))  \n            return false;  \n        return true;  \n    }  \n  \n    /*方法三，最大最小值法*/  \n    bool checkBST3(TreeNode* root) {  \n        // write code here  \n        if (!root)  \n            return true;  \n        return checkBST3(root, INT_MAX, INT_MIN);  \n    }  \n    bool checkBST3(TreeNode *root, int maxVal, int minVal)  \n    {  \n        if (!root)  \n            return true;  \n        if (root->val < minVal || root->val >= maxVal)  \n            return false;  \n        if (!checkBST3(root->left, root->val, minVal) || !checkBST3(root->right, maxVal, root->val))  \n            return false;  \n        return true;  \n    }  \n};  \n  \nint main()  \n{  \n    vector<int> v = { 7, 6, flag, 4, flag, 2, 5, 8, 3, flag, flag, flag, flag, flag, flag };  \n    TreeNode *root = generateTree(v);  \n  \n    Checker c;  \n    bool ret = c.checkBST1(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST2(root);  \n  \n    cout << ret << endl;  \n  \n    ret = c.checkBST3(root);  \n  \n    cout << ret << endl;  \n  \n    system(\"pause\");  \n    return 0;  \n}  \n~~~\n\n","slug":"Algorithm/Data-Structure/isBST","published":1,"date":"2018-05-05T15:37:26.658Z","updated":"2019-03-23T03:38:05.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtc000zqnn9emi77tcj","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>实现一个函数，判断一棵二叉树是否为二叉搜索树。</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ul>\n<li>二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。</li>\n<li>上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。</li>\n<li>基于left &lt; current &lt; right的特性，可以递归用大小值比较进行判断</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">题目描述 </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">请实现一个函数，检查一棵二叉树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*二叉树节点数据结构*/</span>  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span>  </span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) :  </span><br><span class=\"line\">        val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flag = INT_MAX;  </span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">generateTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty())  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; que;  </span><br><span class=\"line\">    que.push(root);  </span><br><span class=\"line\">    <span class=\"comment\">//求出所给元素个数，对应二叉查找树节点个数  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i += <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//处理队首节点的左右子树  </span></span><br><span class=\"line\">        TreeNode *tmp = que.front();  </span><br><span class=\"line\">        TreeNode *left = <span class=\"literal\">NULL</span>, *right = <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            left = <span class=\"keyword\">new</span> TreeNode(nums[i]);  </span><br><span class=\"line\">            que.push(left);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; size &amp;&amp; nums[i + <span class=\"number\">1</span>] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            right = <span class=\"keyword\">new</span> TreeNode(nums[i + <span class=\"number\">1</span>]);  </span><br><span class=\"line\">            que.push(right);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        tmp-&gt;left = left;  </span><br><span class=\"line\">        tmp-&gt;right = right;  </span><br><span class=\"line\">        <span class=\"comment\">//弹出当前处理的节点  </span></span><br><span class=\"line\">        que.pop();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Checker</span> &#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        inOrder(root-&gt;left, v);  </span><br><span class=\"line\">        v.push_back(root-&gt;val);  </span><br><span class=\"line\">        inOrder(root-&gt;right, v);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST1</span><span class=\"params\">(TreeNode* root)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;  </span><br><span class=\"line\">        inOrder(root, ret);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = ret.begin()+<span class=\"number\">1</span>; i != ret.end(); ++i)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*i &lt; *(i - <span class=\"number\">1</span>))  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法二、省掉线性空间，保存遍历的最后一个节点*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastVal = INT_MIN;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查左子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;left))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*比较当前节点，并更新已遍历节点最后的值*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt;= lastVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        lastVal = root-&gt;val;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查右子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;right))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法三，最大最小值法*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkBST3(root, INT_MAX, INT_MIN);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt;= maxVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST3(root-&gt;left, root-&gt;val, minVal) || !checkBST3(root-&gt;right, maxVal, root-&gt;val))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">7</span>, <span class=\"number\">6</span>, flag, <span class=\"number\">4</span>, flag, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, flag, flag, flag, flag, flag, flag &#125;;  </span><br><span class=\"line\">    TreeNode *root = generateTree(v);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Checker c;  </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = c.checkBST1(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST2(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST3(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>实现一个函数，判断一棵二叉树是否为二叉搜索树。</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ul>\n<li>二叉搜索树的中序遍历序列是有序的，所以只需求出中序遍历结果，再依次判断该序列是否有序即可。</li>\n<li>上述方法需要额外线程空间保存遍历结果，在此可以省去该空间开销，只需一个变量保存访问当前节点时上一节点的值即可。</li>\n<li>基于left &lt; current &lt; right的特性，可以递归用大小值比较进行判断</li>\n</ul>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">题目描述 </span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\">请实现一个函数，检查一棵二叉树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二叉搜索树。 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*二叉树节点数据结构*/</span>  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">left</span>;</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> *<span class=\"title\">right</span>;</span>  </span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> x) :  </span><br><span class=\"line\">        val(x), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> flag = INT_MAX;  </span><br><span class=\"line\"><span class=\"function\">TreeNode *<span class=\"title\">generateTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums.empty())  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    TreeNode *root = <span class=\"keyword\">new</span> TreeNode(nums[<span class=\"number\">0</span>]);  </span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;TreeNode *&gt; que;  </span><br><span class=\"line\">    que.push(root);  </span><br><span class=\"line\">    <span class=\"comment\">//求出所给元素个数，对应二叉查找树节点个数  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = nums.size();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; size; i += <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//处理队首节点的左右子树  </span></span><br><span class=\"line\">        TreeNode *tmp = que.front();  </span><br><span class=\"line\">        TreeNode *left = <span class=\"literal\">NULL</span>, *right = <span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            left = <span class=\"keyword\">new</span> TreeNode(nums[i]);  </span><br><span class=\"line\">            que.push(left);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//定义非空右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; size &amp;&amp; nums[i + <span class=\"number\">1</span>] != flag)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            right = <span class=\"keyword\">new</span> TreeNode(nums[i + <span class=\"number\">1</span>]);  </span><br><span class=\"line\">            que.push(right);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        tmp-&gt;left = left;  </span><br><span class=\"line\">        tmp-&gt;right = right;  </span><br><span class=\"line\">        <span class=\"comment\">//弹出当前处理的节点  </span></span><br><span class=\"line\">        que.pop();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Checker</span> &#123;</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法一，将中序遍历结果保存到数组 T(n)=O(n) S(n)=O(n)*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode *root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        inOrder(root-&gt;left, v);  </span><br><span class=\"line\">        v.push_back(root-&gt;val);  </span><br><span class=\"line\">        inOrder(root-&gt;right, v);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST1</span><span class=\"params\">(TreeNode* root)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ret;  </span><br><span class=\"line\">        inOrder(root, ret);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = ret.begin()+<span class=\"number\">1</span>; i != ret.end(); ++i)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*i &lt; *(i - <span class=\"number\">1</span>))  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法二、省掉线性空间，保存遍历的最后一个节点*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastVal = INT_MIN;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST2</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查左子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;left))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*比较当前节点，并更新已遍历节点最后的值*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt;= lastVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        lastVal = root-&gt;val;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/*递归检查右子树*/</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST2(root-&gt;right))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/*方法三，最大最小值法*/</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">// write code here  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkBST3(root, INT_MAX, INT_MIN);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkBST3</span><span class=\"params\">(TreeNode *root, <span class=\"keyword\">int</span> maxVal, <span class=\"keyword\">int</span> minVal)</span>  </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; minVal || root-&gt;val &gt;= maxVal)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!checkBST3(root-&gt;left, root-&gt;val, minVal) || !checkBST3(root-&gt;right, maxVal, root-&gt;val))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123; <span class=\"number\">7</span>, <span class=\"number\">6</span>, flag, <span class=\"number\">4</span>, flag, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, flag, flag, flag, flag, flag, flag &#125;;  </span><br><span class=\"line\">    TreeNode *root = generateTree(v);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Checker c;  </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = c.checkBST1(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST2(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ret = c.checkBST3(root);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ret &lt;&lt; <span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指offer】二维数组中的查找","_content":"\n## 题目描述\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n## 算法分析\n\n我们可以观察二维数组（m，n）中的4个顶点。\n\n左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。\n\n考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        int row = array.size();\n        int col = array[0].size();\n        \n        int i, j;\n        // 起始点在左下角\n        for(i = row - 1, j = 0; i >= 0 && j < col;) {\n            if(target == array[i][j])\n                return true;\n            if(target < array[i][j]){\n                i--;\n                continue;\n            }\n            if(target > array[i][j]){\n                j++;\n                continue;\n            }\n        }\n        \n        // 或者起始点在右上角\n//    for(i = 0, j = col - 1; i < row && j >= 0;) {\n//        if(target == array[i][j])\n//            return true;\n//        if(target < array[i][j]){\n//            j--;\n//            continue;\n//        }\n//        if(target > array[i][j]){\n//\n//            i++;\n//            continue;\n//        }\n//    }\n        \n        return false;\n    }\n\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/find-in-two-dimensional-array.md","raw":"---\ntitle: 【剑指offer】二维数组中的查找\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - array\n---\n\n## 题目描述\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n## 算法分析\n\n我们可以观察二维数组（m，n）中的4个顶点。\n\n左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。\n\n考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        int row = array.size();\n        int col = array[0].size();\n        \n        int i, j;\n        // 起始点在左下角\n        for(i = row - 1, j = 0; i >= 0 && j < col;) {\n            if(target == array[i][j])\n                return true;\n            if(target < array[i][j]){\n                i--;\n                continue;\n            }\n            if(target > array[i][j]){\n                j++;\n                continue;\n            }\n        }\n        \n        // 或者起始点在右上角\n//    for(i = 0, j = col - 1; i < row && j >= 0;) {\n//        if(target == array[i][j])\n//            return true;\n//        if(target < array[i][j]){\n//            j--;\n//            continue;\n//        }\n//        if(target > array[i][j]){\n//\n//            i++;\n//            continue;\n//        }\n//    }\n        \n        return false;\n    }\n\n};\n~~~\n\n","slug":"Algorithm/ForOffer/find-in-two-dimensional-array","published":1,"date":"2018-07-08T03:14:24.031Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtd0010qnn934t8tb0q","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我们可以观察二维数组（m，n）中的4个顶点。</p>\n<p>左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。</p>\n<p>考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"built_in\">array</span>.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = <span class=\"built_in\">array</span>[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"comment\">// 起始点在左下角</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = row - <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; col;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target == <span class=\"built_in\">array</span>[i][j])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &gt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 或者起始点在右上角</span></span><br><span class=\"line\"><span class=\"comment\">//    for(i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target == array[i][j])</span></span><br><span class=\"line\"><span class=\"comment\">//            return true;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &lt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            j--;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &gt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            i++;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我们可以观察二维数组（m，n）中的4个顶点。</p>\n<p>左上角（0，0），向右和向下都是递增。右下角（m，n），向左和向上都是递增，所以我们无法确认哪一个方向能更快找到目标值。</p>\n<p>考虑左下角（m，0），向右是递增的，向上的递减的，所以通过比较 target 和 current value 大小，我们可以判断其所在的相对方向。同理右上角。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; <span class=\"built_in\">array</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"built_in\">array</span>.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col = <span class=\"built_in\">array</span>[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">        <span class=\"comment\">// 起始点在左下角</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = row - <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; col;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target == <span class=\"built_in\">array</span>[i][j])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &gt; <span class=\"built_in\">array</span>[i][j])&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 或者起始点在右上角</span></span><br><span class=\"line\"><span class=\"comment\">//    for(i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0;) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target == array[i][j])</span></span><br><span class=\"line\"><span class=\"comment\">//            return true;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &lt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            j--;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(target &gt; array[i][j])&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            i++;</span></span><br><span class=\"line\"><span class=\"comment\">//            continue;</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"求有向图全部拓扑序列","_content":"**All Topological Sorts**，在前一章中[Topological Sorting](https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/)，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。\n\n## 问题描述\n\n因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。\n\n那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，\n\n## 算法思路\n\n1. 初始化所有顶点为未访问状态；\n2. 依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；\n3. 在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。\n\n## 代码实现\n\n~~~cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    int V;    // No. of vertices\n\n    // Pointer to an array containing adjacency list\n    list<int> *adj;\n\n    // Vector to store indegree of vertices\n    vector<int> indegree;\n\n    // A function used by alltopologicalSort\n    void alltopologicalSortUtil(vector<int>& res,\n                                bool visited[]);\n\npublic:\n    Graph(int V);   // Constructor\n\n    // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // Prints all Topological Sorts\n    void alltopologicalSort();\n};\n\n//  Constructor of graph\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    // Initialising all indegree with 0\n    for (int i = 0; i < V; i++)\n        indegree.push_back(0);\n}\n\n//  Utility function to add edge\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v's list.\n\n    // increasing inner degree of w by 1\n    indegree[w]++;\n}\n\n//  Main recursive function to print all possible\n//  topological sorts\nvoid Graph::alltopologicalSortUtil(vector<int>& res,\n                                   bool visited[])\n{\n    // To indicate whether all topological are found\n    // or not\n    bool flag = false; \n\n    for (int i = 0; i < V; i++)\n    {\n        //  If indegree is 0 and not yet visited then\n        //  only choose that vertex\n        if (indegree[i] == 0 && !visited[i])\n        {\n            //  reducing indegree of adjacent vertices\n            list<int>:: iterator j;\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]--;\n\n            //  including in result\n            res.push_back(i);\n            visited[i] = true;\n            alltopologicalSortUtil(res, visited);\n\n            // resetting visited, res and indegree for\n            // backtracking\n            visited[i] = false;\n            res.erase(res.end() - 1);\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]++;\n\n            flag = true;\n        }\n    }\n\n    //  We reach here if all vertices are visited.\n    //  So we print the solution here\n    if (!flag)\n    {\n        for (int i = 0; i < res.size(); i++)\n            cout << res[i] << \" \";\n        cout << endl;\n    }\n}\n\n//  The function does all Topological Sort.\n//  It uses recursive alltopologicalSortUtil()\nvoid Graph::alltopologicalSort()\n{\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    vector<int> res;\n    alltopologicalSortUtil(res, visited);\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"All Topological sorts\\\\n\";\n\n    g.alltopologicalSort();\n\n    return 0;\n}\n~~~\n\n","source":"_posts/Algorithm/Data-Structure/topological-sort-all.md","raw":"---\ntitle: 求有向图全部拓扑序列\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - graph\n  - topological-sort\n---\n**All Topological Sorts**，在前一章中[Topological Sorting](https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/)，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。\n\n## 问题描述\n\n因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。\n\n那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，\n\n## 算法思路\n\n1. 初始化所有顶点为未访问状态；\n2. 依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；\n3. 在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。\n\n## 代码实现\n\n~~~cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph\n{\n    int V;    // No. of vertices\n\n    // Pointer to an array containing adjacency list\n    list<int> *adj;\n\n    // Vector to store indegree of vertices\n    vector<int> indegree;\n\n    // A function used by alltopologicalSort\n    void alltopologicalSortUtil(vector<int>& res,\n                                bool visited[]);\n\npublic:\n    Graph(int V);   // Constructor\n\n    // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // Prints all Topological Sorts\n    void alltopologicalSort();\n};\n\n//  Constructor of graph\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n\n    // Initialising all indegree with 0\n    for (int i = 0; i < V; i++)\n        indegree.push_back(0);\n}\n\n//  Utility function to add edge\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v's list.\n\n    // increasing inner degree of w by 1\n    indegree[w]++;\n}\n\n//  Main recursive function to print all possible\n//  topological sorts\nvoid Graph::alltopologicalSortUtil(vector<int>& res,\n                                   bool visited[])\n{\n    // To indicate whether all topological are found\n    // or not\n    bool flag = false; \n\n    for (int i = 0; i < V; i++)\n    {\n        //  If indegree is 0 and not yet visited then\n        //  only choose that vertex\n        if (indegree[i] == 0 && !visited[i])\n        {\n            //  reducing indegree of adjacent vertices\n            list<int>:: iterator j;\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]--;\n\n            //  including in result\n            res.push_back(i);\n            visited[i] = true;\n            alltopologicalSortUtil(res, visited);\n\n            // resetting visited, res and indegree for\n            // backtracking\n            visited[i] = false;\n            res.erase(res.end() - 1);\n            for (j = adj[i].begin(); j != adj[i].end(); j++)\n                indegree[*j]++;\n\n            flag = true;\n        }\n    }\n\n    //  We reach here if all vertices are visited.\n    //  So we print the solution here\n    if (!flag)\n    {\n        for (int i = 0; i < res.size(); i++)\n            cout << res[i] << \" \";\n        cout << endl;\n    }\n}\n\n//  The function does all Topological Sort.\n//  It uses recursive alltopologicalSortUtil()\nvoid Graph::alltopologicalSort()\n{\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    vector<int> res;\n    alltopologicalSortUtil(res, visited);\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"All Topological sorts\\\\n\";\n\n    g.alltopologicalSort();\n\n    return 0;\n}\n~~~\n\n","slug":"Algorithm/Data-Structure/topological-sort-all","published":1,"date":"2018-04-24T15:10:55.937Z","updated":"2019-03-23T03:38:05.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtf0013qnn9k5q1l26a","content":"<p><strong>All Topological Sorts</strong>，在前一章中<a href=\"https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/\" target=\"_blank\" rel=\"noopener\">Topological Sorting</a>，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。</p>\n<p>那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>初始化所有顶点为未访问状态；</li>\n<li>依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；</li>\n<li>在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Vector to store indegree of vertices</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; indegree;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by alltopologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSortUtil</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">bool</span> visited[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prints all Topological Sorts</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Constructor of graph</span></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialising all indegree with 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        indegree.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Utility function to add edge</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v's list.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increasing inner degree of w by 1</span></span><br><span class=\"line\">    indegree[w]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Main recursive function to print all possible</span></span><br><span class=\"line\"><span class=\"comment\">//  topological sorts</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSortUtil(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span><br><span class=\"line\">                                   <span class=\"keyword\">bool</span> visited[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// To indicate whether all topological are found</span></span><br><span class=\"line\">    <span class=\"comment\">// or not</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  If indegree is 0 and not yet visited then</span></span><br><span class=\"line\">        <span class=\"comment\">//  only choose that vertex</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span> &amp;&amp; !visited[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  reducing indegree of adjacent vertices</span></span><br><span class=\"line\">            <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;:: iterator j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//  including in result</span></span><br><span class=\"line\">            res.push_back(i);</span><br><span class=\"line\">            visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            alltopologicalSortUtil(res, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// resetting visited, res and indegree for</span></span><br><span class=\"line\">            <span class=\"comment\">// backtracking</span></span><br><span class=\"line\">            visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            res.erase(res.end() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  We reach here if all vertices are visited.</span></span><br><span class=\"line\">    <span class=\"comment\">//  So we print the solution here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res.size(); i++)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  The function does all Topological Sort.</span></span><br><span class=\"line\"><span class=\"comment\">//  It uses recursive alltopologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    alltopologicalSortUtil(res, visited);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"All Topological sorts\\\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    g.alltopologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>All Topological Sorts</strong>，在前一章中<a href=\"https://yuechuanx.com/2018/05/01/DataStructure/%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/\" target=\"_blank\" rel=\"noopener\">Topological Sorting</a>，已经讨论了拓扑排序的原理及其实现算法，但只是实现了从单一一个入度为0的节点进行的拓扑排序。本章主要来讨论一下，如何求一个有向无环图的所有拓扑排序序列。</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>因为在一个有向无环图中，并非所有顶点间都有路径可达，而且可能有些点是孤立点，这导致了同一个有向图可能会有多个拓扑排序，因为显然孤立点在拓扑序列中的位置是任意的，各子连通子图间的先后次序也可以互换。</p>\n<p>那么如何来求一个有向无环图的所有拓扑排序序列呢？我们可以通过修改前一篇文章中的算法达到这个目标，即在原有拓扑排序过程的基础上，加上回溯法，并对所有入度为0的顶点应用这个带回溯的拓扑排序算法，</p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>初始化所有顶点为未访问状态；</li>\n<li>依次对所有入度为0的顶点，先把其入度降1，然后把该顶点放到排序序列中，然后递归访问它的所有邻接点，最后回溯；</li>\n<li>在函数最终返回后，就得到了一个拓扑序列，然后重置访问状态和入度，继续寻找其它拓扑序列。</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Vector to store indegree of vertices</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; indegree;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by alltopologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSortUtil</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">bool</span> visited[])</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prints all Topological Sorts</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alltopologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Constructor of graph</span></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialising all indegree with 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        indegree.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Utility function to add edge</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v's list.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increasing inner degree of w by 1</span></span><br><span class=\"line\">    indegree[w]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Main recursive function to print all possible</span></span><br><span class=\"line\"><span class=\"comment\">//  topological sorts</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSortUtil(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; res,</span><br><span class=\"line\">                                   <span class=\"keyword\">bool</span> visited[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// To indicate whether all topological are found</span></span><br><span class=\"line\">    <span class=\"comment\">// or not</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  If indegree is 0 and not yet visited then</span></span><br><span class=\"line\">        <span class=\"comment\">//  only choose that vertex</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indegree[i] == <span class=\"number\">0</span> &amp;&amp; !visited[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//  reducing indegree of adjacent vertices</span></span><br><span class=\"line\">            <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;:: iterator j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]--;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//  including in result</span></span><br><span class=\"line\">            res.push_back(i);</span><br><span class=\"line\">            visited[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            alltopologicalSortUtil(res, visited);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// resetting visited, res and indegree for</span></span><br><span class=\"line\">            <span class=\"comment\">// backtracking</span></span><br><span class=\"line\">            visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            res.erase(res.end() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = adj[i].begin(); j != adj[i].end(); j++)</span><br><span class=\"line\">                indegree[*j]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  We reach here if all vertices are visited.</span></span><br><span class=\"line\">    <span class=\"comment\">//  So we print the solution here</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res.size(); i++)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  The function does all Topological Sort.</span></span><br><span class=\"line\"><span class=\"comment\">//  It uses recursive alltopologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::alltopologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">    alltopologicalSortUtil(res, visited);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"All Topological sorts\\\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    g.alltopologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指offer】旋转数组的最小数字","_content":"\n## 题目描述\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n\n\n## 算法分析\n\n我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        if(rotateArray.size() == 0){\n            return 0;\n        } else{\n            int first = rotateArray[0];\n            int i = 1;\n            while(rotateArray[i] != '\\0'){\n                if(rotateArray[i] < first){\n                    break;\n                    //return rotateArray[i];\n                }\n                i++;\n            }\n            return rotateArray[i];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        int n = rotateArray.size();\n        if (n == 0) return 0;\n        else {\n            int min = rotateArray[0];\n            for (auto i : rotateArray) {\n                if (i < min) min = i;\n            }\n            \n            return min;\n        }\n    }\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/min-number-in-rotate-array.md","raw":"---\ntitle: 【剑指offer】旋转数组的最小数字\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - search\n---\n\n## 题目描述\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n\n\n## 算法分析\n\n我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        if(rotateArray.size() == 0){\n            return 0;\n        } else{\n            int first = rotateArray[0];\n            int i = 1;\n            while(rotateArray[i] != '\\0'){\n                if(rotateArray[i] < first){\n                    break;\n                    //return rotateArray[i];\n                }\n                i++;\n            }\n            return rotateArray[i];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int minNumberInRotateArray(vector<int> rotateArray) {\n        int n = rotateArray.size();\n        if (n == 0) return 0;\n        else {\n            int min = rotateArray[0];\n            for (auto i : rotateArray) {\n                if (i < min) min = i;\n            }\n            \n            return min;\n        }\n    }\n};\n~~~\n\n","slug":"Algorithm/ForOffer/min-number-in-rotate-array","published":1,"date":"2018-07-08T03:20:51.629Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtk0014qnn9dg3wydo7","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotateArray.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(rotateArray[i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rotateArray[i] &lt; first)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//return rotateArray[i];</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rotateArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = rotateArray.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : rotateArray) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; min) min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>我觉得这道题目挺没有意思，最直接的一个做法是遍历整个数组，它举了一个递减排序的数组，这里只需要找到旋转点是可以用二分的，不确定旋转数组是否是有序的话，就只能用第一个方法了。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotateArray.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> first = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(rotateArray[i] != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(rotateArray[i] &lt; first)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//return rotateArray[i];</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rotateArray[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = rotateArray.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = rotateArray[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : rotateArray) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; min) min = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指offer】栈实现队列","_content":"\n## 题目描述\n\n用两个栈来实现一个队列，完成队列的`Push`和`Pop`操作。 队列中的元素为`int`类型。\n\n\n\n## 算法分析\n\n队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：\n\n`push`操作用一个栈进行存储，`pop`操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，\n\n第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution\n{\npublic:\n    void push(int node) {\n        stack1.push(node);\n    }\n\n    int pop() {\n        int res;\n        while (!stack1.empty()) {\n            stack2.push(stack1.top());\n            stack1.pop();\n        }\n        \n        res = stack2.top();\n        stack2.pop();\n        \n        while (!stack2.empty()) {\n            stack1.push(stack2.top());\n            stack2.pop();\n        }\n        \n        return res;\n    }\n\nprivate:\n    stack<int> stack1;\n    stack<int> stack2;\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/implement-queue-with-stack.md","raw":"---\ntitle: 【剑指offer】栈实现队列\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - queue\n  - stack\n---\n\n## 题目描述\n\n用两个栈来实现一个队列，完成队列的`Push`和`Pop`操作。 队列中的元素为`int`类型。\n\n\n\n## 算法分析\n\n队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：\n\n`push`操作用一个栈进行存储，`pop`操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，\n\n第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution\n{\npublic:\n    void push(int node) {\n        stack1.push(node);\n    }\n\n    int pop() {\n        int res;\n        while (!stack1.empty()) {\n            stack2.push(stack1.top());\n            stack1.pop();\n        }\n        \n        res = stack2.top();\n        stack2.pop();\n        \n        while (!stack2.empty()) {\n            stack1.push(stack2.top());\n            stack2.pop();\n        }\n        \n        return res;\n    }\n\nprivate:\n    stack<int> stack1;\n    stack<int> stack2;\n};\n~~~\n\n","slug":"Algorithm/ForOffer/implement-queue-with-stack","published":1,"date":"2018-07-08T03:20:51.622Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtm0015qnn9j81d178h","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：</p>\n<p><code>push</code>操作用一个栈进行存储，<code>pop</code>操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，</p>\n<p>第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.top());</span><br><span class=\"line\">            stack1.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        res = stack2.top();</span><br><span class=\"line\">        stack2.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.top());</span><br><span class=\"line\">            stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack1;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>队列具有先进先出的性质，栈具有后进先出的性质，根据他们性质的联系，使用两个栈实现队列的思路如下：</p>\n<p><code>push</code>操作用一个栈进行存储，<code>pop</code>操作用存储数据的栈向另一栈进行存放，这样数据两次倒转不变，</p>\n<p>第二个栈的栈顶元素作为返回值，然后在倒转回第一个栈。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.empty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.top());</span><br><span class=\"line\">            stack1.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        res = stack2.top();</span><br><span class=\"line\">        stack2.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.top());</span><br><span class=\"line\">            stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack1;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stack2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指offer】从尾到头打印链表","_content":"\n## 题目描述\n\n输入一个链表，按链表值从尾到头的顺序返回一个`ArrayList`。\n\n\n\n## 算法分析\n\n1. 使用递归的方法：\n\n   我们可以使用递归函数，`head`和`head->next`存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。\n\n2. 使用栈的方法：\n\n   首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n*  struct ListNode {\n*        int val;\n*        struct ListNode *next;\n*        ListNode(int x) :\n*              val(x), next(NULL) {\n*        }\n*  };\n*/\n\n// 递归\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n\t\tvector<int> result;\n        helper(head, result);\n        return result;\n    }\n    \nprivate:\n    void helper(ListNode* head, vector<int> &result){\n        if(head){\n            if(head -> next){\n                helper(head -> next, result);\n            }\n            result.push_back(head -> val);\n        }\n    }\n};\n\n\n// 栈\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        vector<int> res;\n        stack<int> st;\n        \n        while (head) {\n            st.push(head->val);\n            head = head->next;\n        }\n        \n        while (!st.empty()) {\n            res.push_back(st.top());\n            st.pop();\n        }\n        \n        return res;\n    }\n};\n~~~\n\n\n\n\n\n","source":"_posts/Algorithm/ForOffer/print-list-from-tail-to-head.md","raw":"---\ntitle: 【剑指offer】从尾到头打印链表\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - linked-list\n---\n\n## 题目描述\n\n输入一个链表，按链表值从尾到头的顺序返回一个`ArrayList`。\n\n\n\n## 算法分析\n\n1. 使用递归的方法：\n\n   我们可以使用递归函数，`head`和`head->next`存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。\n\n2. 使用栈的方法：\n\n   首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n*  struct ListNode {\n*        int val;\n*        struct ListNode *next;\n*        ListNode(int x) :\n*              val(x), next(NULL) {\n*        }\n*  };\n*/\n\n// 递归\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n\t\tvector<int> result;\n        helper(head, result);\n        return result;\n    }\n    \nprivate:\n    void helper(ListNode* head, vector<int> &result){\n        if(head){\n            if(head -> next){\n                helper(head -> next, result);\n            }\n            result.push_back(head -> val);\n        }\n    }\n};\n\n\n// 栈\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(ListNode* head) {\n        vector<int> res;\n        stack<int> st;\n        \n        while (head) {\n            st.push(head->val);\n            head = head->next;\n        }\n        \n        while (!st.empty()) {\n            res.push_back(st.top());\n            st.pop();\n        }\n        \n        return res;\n    }\n};\n~~~\n\n\n\n\n\n","slug":"Algorithm/ForOffer/print-list-from-tail-to-head","published":1,"date":"2018-07-08T03:20:51.635Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtp0018qnn91pxgww7q","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><ol>\n<li><p>使用递归的方法：</p>\n<p>我们可以使用递归函数，<code>head</code>和<code>head-&gt;next</code>存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。</p>\n</li>\n<li><p>使用栈的方法：</p>\n<p>首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        int val;</span></span><br><span class=\"line\"><span class=\"comment\">*        struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*        ListNode(int x) :</span></span><br><span class=\"line\"><span class=\"comment\">*              val(x), next(NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*  &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        helper(head, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head -&gt; next)&#123;</span><br><span class=\"line\">                helper(head -&gt; next, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(head -&gt; val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            st.push(head-&gt;val);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.empty()) &#123;</span><br><span class=\"line\">            res.push_back(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><ol>\n<li><p>使用递归的方法：</p>\n<p>我们可以使用递归函数，<code>head</code>和<code>head-&gt;next</code>存在的时候进入下一层，当进入最后一层的时候开始从尾部返回。</p>\n</li>\n<li><p>使用栈的方法：</p>\n<p>首先遍历一遍链表，将顺序的值压栈，然后利用栈的性质（后进先出）进行打印。</p>\n</li>\n</ol>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        int val;</span></span><br><span class=\"line\"><span class=\"comment\">*        struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*        ListNode(int x) :</span></span><br><span class=\"line\"><span class=\"comment\">*              val(x), next(NULL) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*  &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        helper(head, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(ListNode* head, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;result)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head -&gt; next)&#123;</span><br><span class=\"line\">                helper(head -&gt; next, result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.push_back(head -&gt; val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 栈</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            st.push(head-&gt;val);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.empty()) &#123;</span><br><span class=\"line\">            res.push_back(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指Offer】替换空格","_content":"\n## 题目描述\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n\n\n## 算法分析\n\n首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n\tvoid replaceSpace(char *str,int length) {\n\t\tchar *t = str;\n        int strLen = 0, newStrLen = 0, spaceCount = 0;\n        int p,q;\n        \n        if(str == NULL || length <0) return; // 首先判定进入算法的有效条件\n        \n        while(*t != '\\0'){\n            strLen++;\n            if(*t == ' ') spaceCount++;\n            t++;\n        }\t// 取字符串长度， 空格的个数\n        \n        newStrLen = strLen + 2 * spaceCount;  // 新的字符串的长度\n        if(newStrLen > length) return ;\n        \n        for(p = strLen, q = newStrLen; p >= 0; p-- ){\n            if(str[p] == ' '){\n                str[q--] = '0';\n                str[q--] = '2';\n                str[q--] = '%';\n            } else {\n                str[q--] = str[p];\n            }\n        }\n\t}\n};\n~~~\n\n","source":"_posts/Algorithm/ForOffer/replace-sapce.md","raw":"---\ntitle: 【剑指Offer】替换空格\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - string\n---\n\n## 题目描述\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n\n\n## 算法分析\n\n首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。\n\n\n\n## 代码实现\n\n~~~cpp\nclass Solution {\npublic:\n\tvoid replaceSpace(char *str,int length) {\n\t\tchar *t = str;\n        int strLen = 0, newStrLen = 0, spaceCount = 0;\n        int p,q;\n        \n        if(str == NULL || length <0) return; // 首先判定进入算法的有效条件\n        \n        while(*t != '\\0'){\n            strLen++;\n            if(*t == ' ') spaceCount++;\n            t++;\n        }\t// 取字符串长度， 空格的个数\n        \n        newStrLen = strLen + 2 * spaceCount;  // 新的字符串的长度\n        if(newStrLen > length) return ;\n        \n        for(p = strLen, q = newStrLen; p >= 0; p-- ){\n            if(str[p] == ' '){\n                str[q--] = '0';\n                str[q--] = '2';\n                str[q--] = '%';\n            } else {\n                str[q--] = str[p];\n            }\n        }\n\t}\n};\n~~~\n\n","slug":"Algorithm/ForOffer/replace-sapce","published":1,"date":"2018-07-08T03:20:51.656Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtr0019qnn97u9ht7qf","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *t = str;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> strLen = <span class=\"number\">0</span>, newStrLen = <span class=\"number\">0</span>, spaceCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,q;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span> || length &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 首先判定进入算法的有效条件</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*t != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            strLen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(*t == <span class=\"string\">' '</span>) spaceCount++;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;\t<span class=\"comment\">// 取字符串长度， 空格的个数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newStrLen = strLen + <span class=\"number\">2</span> * spaceCount;  <span class=\"comment\">// 新的字符串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(newStrLen &gt; length) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = strLen, q = newStrLen; p &gt;= <span class=\"number\">0</span>; p-- )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[p] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'2'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'%'</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                str[q--] = str[p];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>首先复制一份字符串的备份，我们需要知道字符串原始长度，空格数来计算替换后字符串的长度，之后就只需要根据字符串原始长度和新长度对字符串进行拷贝。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">replaceSpace</span><span class=\"params\">(<span class=\"keyword\">char</span> *str,<span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *t = str;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> strLen = <span class=\"number\">0</span>, newStrLen = <span class=\"number\">0</span>, spaceCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,q;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str == <span class=\"literal\">NULL</span> || length &lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// 首先判定进入算法的有效条件</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*t != <span class=\"string\">'\\0'</span>)&#123;</span><br><span class=\"line\">            strLen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(*t == <span class=\"string\">' '</span>) spaceCount++;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;\t<span class=\"comment\">// 取字符串长度， 空格的个数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newStrLen = strLen + <span class=\"number\">2</span> * spaceCount;  <span class=\"comment\">// 新的字符串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(newStrLen &gt; length) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(p = strLen, q = newStrLen; p &gt;= <span class=\"number\">0</span>; p-- )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[p] == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'2'</span>;</span><br><span class=\"line\">                str[q--] = <span class=\"string\">'%'</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                str[q--] = str[p];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"【剑指offer】重建二叉树","_content":"\n## 问题描述\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n\n\n## 算法分析\n\n算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {\n\t\tif (pre.size() == 0) return NULL;\n        else if (pre.size() == 1){\n            TreeNode* root = new TreeNode(pre.back());\n            root -> left = NULL;\n            root -> right = NULL;\n            return root;\n        }\n        else {\n            TreeNode* root = new TreeNode(pre.at(0));\n            vector<int>::iterator it = vin.begin();\n            while(it != vin.end() && *it != pre.at(0)) ++it;\n            int dis = it - vin.begin();\n            vector<int> subPreLeft(pre.begin() + 1, pre.begin() + dis + 1);\n            vector<int> subPreRight(pre.begin() + dis + 1, pre.end());\n            vector<int> subVinLeft(vin.begin(), it);\n            vector<int> subVinRight(it + 1, vin.end() );\n            root -> left = reConstructBinaryTree(subPreLeft, subVinLeft);\n            root -> right = reConstructBinaryTree(subPreRight, subVinRight);\n            return root;\n        }\n    }\n    \n};\n~~~\n\n\n\n","source":"_posts/Algorithm/ForOffer/reconstruct-binary-tree.md","raw":"---\ntitle: 【剑指offer】重建二叉树\ncategories:\n  - Algorithm\n  - ForOffer\ntags:\n  - algorithm\n  - binary-tree\n---\n\n## 问题描述\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n\n\n## 算法分析\n\n算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程\n\n\n\n## 代码实现\n\n~~~cpp\n/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {\n\t\tif (pre.size() == 0) return NULL;\n        else if (pre.size() == 1){\n            TreeNode* root = new TreeNode(pre.back());\n            root -> left = NULL;\n            root -> right = NULL;\n            return root;\n        }\n        else {\n            TreeNode* root = new TreeNode(pre.at(0));\n            vector<int>::iterator it = vin.begin();\n            while(it != vin.end() && *it != pre.at(0)) ++it;\n            int dis = it - vin.begin();\n            vector<int> subPreLeft(pre.begin() + 1, pre.begin() + dis + 1);\n            vector<int> subPreRight(pre.begin() + dis + 1, pre.end());\n            vector<int> subVinLeft(vin.begin(), it);\n            vector<int> subVinRight(it + 1, vin.end() );\n            root -> left = reConstructBinaryTree(subPreLeft, subVinLeft);\n            root -> right = reConstructBinaryTree(subPreRight, subVinRight);\n            return root;\n        }\n    }\n    \n};\n~~~\n\n\n\n","slug":"Algorithm/ForOffer/reconstruct-binary-tree","published":1,"date":"2018-07-08T03:20:51.642Z","updated":"2019-03-23T03:36:36.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtt001cqnn9ap05uxfm","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pre,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vin)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.back());</span><br><span class=\"line\">            root -&gt; left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root -&gt; right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.at(<span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = vin.begin();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(it != vin.end() &amp;&amp; *it != pre.at(<span class=\"number\">0</span>)) ++it;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = it - vin.begin();</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreLeft(pre.begin() + <span class=\"number\">1</span>, pre.begin() + dis + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreRight(pre.begin() + dis + <span class=\"number\">1</span>, pre.end());</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinLeft(vin.begin(), it);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinRight(it + <span class=\"number\">1</span>, vin.end() );</span><br><span class=\"line\">            root -&gt; left = reConstructBinaryTree(subPreLeft, subVinLeft);</span><br><span class=\"line\">            root -&gt; right = reConstructBinaryTree(subPreRight, subVinRight);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>算法的基本思路是分治法，divide and conquer，可以拆解这个为相似的小问题，pre的第一个元素是根节点，树或者子树，然后可以拆解为左右子树的pre和vin，进行同样的过程</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for binary tree</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pre,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vin)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pre.size() == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.back());</span><br><span class=\"line\">            root -&gt; left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            root -&gt; right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            TreeNode* root = <span class=\"keyword\">new</span> TreeNode(pre.at(<span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = vin.begin();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(it != vin.end() &amp;&amp; *it != pre.at(<span class=\"number\">0</span>)) ++it;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = it - vin.begin();</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreLeft(pre.begin() + <span class=\"number\">1</span>, pre.begin() + dis + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subPreRight(pre.begin() + dis + <span class=\"number\">1</span>, pre.end());</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinLeft(vin.begin(), it);</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; subVinRight(it + <span class=\"number\">1</span>, vin.end() );</span><br><span class=\"line\">            root -&gt; left = reConstructBinaryTree(subPreLeft, subVinLeft);</span><br><span class=\"line\">            root -&gt; right = reConstructBinaryTree(subPreRight, subVinRight);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"P1. Two Sum","_content":"\n\n\n## Description\n\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\n\n**Example:**\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n## Analysis\n\n我们可以用二重循环遍历所有的下标组合，这样的时间复杂度为O（n^2）\n\n进一步优化，我们可以通过一重循环遍历和Map查找，这样的时间复杂度为O（ nlog(n) ）\n\n## Code\n\n### C++\n\n~~~cpp\n// Recommended answer\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        for (int i = 0;  i < nums.size(); ++i) {\n            if (m.count(target - nums[i])) {\n                return {i, m[target - nums[i]]};\n            }\n            m[nums[i]] = i;\n        }\n        return {};\n    }\n};\n\nclass Solution {\npublic:\n    // 使用二重循环遍历\n    // 时间复杂度 O（n^2）\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        for(int i = 0; i < nums.size(); ++i) {\n            int tmp = target - nums[i];\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[j] == tmp) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    // 使用一重循环，Map\n    // 时间复杂度 O（nlog(n)）\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        vector<int> res;\n        for (int i = 0; i < nums.size(); ++i) {\n            m[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); ++i) {\n            int t = target - nums[i];\n            if (m.count(t) && m[t] != i) {\n                res.push_back(i);\n                res.push_back(m[t]);\n                break;\n            }\n        }\n        return res;\n    }\n};\n~~~\n\n\n\n## Java\n\n~~~java\n\n// Your runtime beats 55.03 % of java submissions.\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            if (m.containsKey(target - nums[i])) {\n                res[0] = i;\n                res[1] = m.get(target - nums[i]);\n            }\n            m.put(nums[i], i);\n        }\n        return res;\n    }\n}\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            m.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            int t = target - nums[i];\n            if (m.containsKey(t) && m.get(t) != i) {\n                res[0] = i;\n                res[1] = m.get(t);\n            }\n        }\n        return res;\n    }\n}\n~~~\n\n","source":"_posts/Algorithm/LeetCode/p1-two-sum.md","raw":"---\ntitle: P1. Two Sum\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n\n\n## Description\n\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\n\n**Example:**\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n## Analysis\n\n我们可以用二重循环遍历所有的下标组合，这样的时间复杂度为O（n^2）\n\n进一步优化，我们可以通过一重循环遍历和Map查找，这样的时间复杂度为O（ nlog(n) ）\n\n## Code\n\n### C++\n\n~~~cpp\n// Recommended answer\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        for (int i = 0;  i < nums.size(); ++i) {\n            if (m.count(target - nums[i])) {\n                return {i, m[target - nums[i]]};\n            }\n            m[nums[i]] = i;\n        }\n        return {};\n    }\n};\n\nclass Solution {\npublic:\n    // 使用二重循环遍历\n    // 时间复杂度 O（n^2）\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        for(int i = 0; i < nums.size(); ++i) {\n            int tmp = target - nums[i];\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[j] == tmp) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    // 使用一重循环，Map\n    // 时间复杂度 O（nlog(n)）\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        vector<int> res;\n        for (int i = 0; i < nums.size(); ++i) {\n            m[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); ++i) {\n            int t = target - nums[i];\n            if (m.count(t) && m[t] != i) {\n                res.push_back(i);\n                res.push_back(m[t]);\n                break;\n            }\n        }\n        return res;\n    }\n};\n~~~\n\n\n\n## Java\n\n~~~java\n\n// Your runtime beats 55.03 % of java submissions.\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            if (m.containsKey(target - nums[i])) {\n                res[0] = i;\n                res[1] = m.get(target - nums[i]);\n            }\n            m.put(nums[i], i);\n        }\n        return res;\n    }\n}\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            m.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            int t = target - nums[i];\n            if (m.containsKey(t) && m.get(t) != i) {\n                res[0] = i;\n                res[1] = m.get(t);\n            }\n        }\n        return res;\n    }\n}\n~~~\n\n","slug":"Algorithm/LeetCode/p1-two-sum","published":1,"date":"2018-04-28T11:36:44.707Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtu001eqnn94n9yhkwf","content":"<h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class=\"line\"></span><br><span class=\"line\">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n<h2 id=\"Analysis\"><a href=\"#Analysis\" class=\"headerlink\" title=\"Analysis\"></a>Analysis</h2><p>我们可以用二重循环遍历所有的下标组合，这样的时间复杂度为O（n^2）</p>\n<p>进一步优化，我们可以通过一重循环遍历和Map查找，这样的时间复杂度为O（ nlog(n) ）</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Recommended answer</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;  i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.count(target - nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用二重循环遍历</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度 O（n^2）</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == tmp) &#123;</span><br><span class=\"line\">                    res.push_back(i);</span><br><span class=\"line\">                    res.push_back(j);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用一重循环，Map</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度 O（nlog(n)）</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            m[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;</span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">                res.push_back(m[t]);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Your runtime beats 55.03 % of java submissions.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Description\"><a href=\"#Description\" class=\"headerlink\" title=\"Description\"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>\n<p><strong>Example:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class=\"line\"></span><br><span class=\"line\">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n<h2 id=\"Analysis\"><a href=\"#Analysis\" class=\"headerlink\" title=\"Analysis\"></a>Analysis</h2><p>我们可以用二重循环遍历所有的下标组合，这样的时间复杂度为O（n^2）</p>\n<p>进一步优化，我们可以通过一重循环遍历和Map查找，这样的时间复杂度为O（ nlog(n) ）</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Recommended answer</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;  i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.count(target - nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用二重循环遍历</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度 O（n^2）</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == tmp) &#123;</span><br><span class=\"line\">                    res.push_back(i);</span><br><span class=\"line\">                    res.push_back(j);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用一重循环，Map</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度 O（nlog(n)）</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            m[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;</span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">                res.push_back(m[t]);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Your runtime beats 55.03 % of java submissions.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"100. Same Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(p && !q || !p && q || p -> val != q -> val) return false;\n        return isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p100-same-tree.md","raw":"---\ntitle: 100. Same Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(p && !q || !p && q || p -> val != q -> val) return false;\n        return isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p100-same-tree","published":1,"date":"2018-04-28T14:59:29.286Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtv001iqnn9m034umn9","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p &amp;&amp; !q) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p &amp;&amp; !q || !p &amp;&amp; q || p -&gt; val != q -&gt; val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSameTree</span><span class=\"params\">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p &amp;&amp; !q) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p &amp;&amp; !q || !p &amp;&amp; q || p -&gt; val != q -&gt; val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"101. Symmetric Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        // check the input\n        if(!root) return true;\n\n        TreeNode *left, *right;\n        queue<TreeNode*> q1, q2;\n        q1.push(root -> left);\n        q2.push(root -> right);\n        while(!q1.empty() && !q2.empty()) {\n            left = q1.front();\n            q1.pop();\n            right = q2.front();\n            q2.pop();\n            if(NULL == left && NULL == right) {\n                continue;\n            } else if(NULL == left || NULL == right) {\n                return false;\n            } else if(left -> val != right -> val) {\n                return false;\n            }\n            q1.push(left -> left);\n            q1.push(left -> right);\n            // 这里需要注意对称\n            q2.push(right -> right);\n            q2.push(right -> left);\n        }\n        return true;\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p101-symmetric-tree.md","raw":"---\ntitle: 101. Symmetric Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        // check the input\n        if(!root) return true;\n\n        TreeNode *left, *right;\n        queue<TreeNode*> q1, q2;\n        q1.push(root -> left);\n        q2.push(root -> right);\n        while(!q1.empty() && !q2.empty()) {\n            left = q1.front();\n            q1.pop();\n            right = q2.front();\n            q2.pop();\n            if(NULL == left && NULL == right) {\n                continue;\n            } else if(NULL == left || NULL == right) {\n                return false;\n            } else if(left -> val != right -> val) {\n                return false;\n            }\n            q1.push(left -> left);\n            q1.push(left -> right);\n            // 这里需要注意对称\n            q2.push(right -> right);\n            q2.push(right -> left);\n        }\n        return true;\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p101-symmetric-tree","published":1,"date":"2018-04-28T14:59:29.298Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdtw001kqnn9sy93l922","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode *left, *right;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class=\"line\">        q1.push(root -&gt; left);</span><br><span class=\"line\">        q2.push(root -&gt; right);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;</span><br><span class=\"line\">            left = q1.front();</span><br><span class=\"line\">            q1.pop();</span><br><span class=\"line\">            right = q2.front();</span><br><span class=\"line\">            q2.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == left &amp;&amp; <span class=\"literal\">NULL</span> == right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == left || <span class=\"literal\">NULL</span> == right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(left -&gt; val != right -&gt; val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            q1.push(left -&gt; left);</span><br><span class=\"line\">            q1.push(left -&gt; right);</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要注意对称</span></span><br><span class=\"line\">            q2.push(right -&gt; right);</span><br><span class=\"line\">            q2.push(right -&gt; left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode *left, *right;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class=\"line\">        q1.push(root -&gt; left);</span><br><span class=\"line\">        q2.push(root -&gt; right);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;</span><br><span class=\"line\">            left = q1.front();</span><br><span class=\"line\">            q1.pop();</span><br><span class=\"line\">            right = q2.front();</span><br><span class=\"line\">            q2.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == left &amp;&amp; <span class=\"literal\">NULL</span> == right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == left || <span class=\"literal\">NULL</span> == right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(left -&gt; val != right -&gt; val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            q1.push(left -&gt; left);</span><br><span class=\"line\">            q1.push(left -&gt; right);</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要注意对称</span></span><br><span class=\"line\">            q2.push(right -&gt; right);</span><br><span class=\"line\">            q2.push(right -&gt; left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"108. Convert Sorted Array to Binary Search Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return sortedArrayToBST(nums, 0, nums.size()-1);\n    }\n\n    TreeNode* sortedArrayToBST(vector<int>& nums, int left, int right) {\n        if(left > right) return NULL;\n        int mid = (left + right) / 2;\n        TreeNode* cur = new TreeNode(nums[mid]);\n        cur -> left = sortedArrayToBST(nums, left, mid - 1);\n        cur -> right = sortedArrayToBST(nums, mid + 1, right);\n        return cur;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p108-convert-sorted-array-to-binary-search-tree.md","raw":"---\ntitle: 108. Convert Sorted Array to Binary Search Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return sortedArrayToBST(nums, 0, nums.size()-1);\n    }\n\n    TreeNode* sortedArrayToBST(vector<int>& nums, int left, int right) {\n        if(left > right) return NULL;\n        int mid = (left + right) / 2;\n        TreeNode* cur = new TreeNode(nums[mid]);\n        cur -> left = sortedArrayToBST(nums, left, mid - 1);\n        cur -> right = sortedArrayToBST(nums, mid + 1, right);\n        return cur;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p108-convert-sorted-array-to-binary-search-tree","published":1,"date":"2018-04-28T14:59:29.323Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdu0001oqnn99xb102at","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sortedArrayToBST(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt; right) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode* cur = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        cur -&gt; left = sortedArrayToBST(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        cur -&gt; right = sortedArrayToBST(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sortedArrayToBST(nums, <span class=\"number\">0</span>, nums.size()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt; right) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode* cur = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        cur -&gt; left = sortedArrayToBST(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        cur -&gt; right = sortedArrayToBST(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"107. Binary Tree Level Order Traverse","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> res;\n        if(!root) return res;\n\n        queue<TreeNode*> q;\n        q.push(root); // 作为初始条件\n        while(!q.empty()) {\n            vector<int> level;  // 存储二叉树层次的值\n            int size = q.size();\n            for(int i = 0; i < size; ++i) { // 利用for循环遍历出队列\n                TreeNode *node = q.front();\n                q.pop();\n                level.push_back(node -> val);\n                if(node -> left) q.push(node -> left);\n                if(node -> right) q.push(node -> right);\n            }\n            res.insert(res.begin(), level);\n        }\n        return res;\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p107-binary-tree-level-order-traversal-ii.md","raw":"---\ntitle: 107. Binary Tree Level Order Traverse\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> res;\n        if(!root) return res;\n\n        queue<TreeNode*> q;\n        q.push(root); // 作为初始条件\n        while(!q.empty()) {\n            vector<int> level;  // 存储二叉树层次的值\n            int size = q.size();\n            for(int i = 0; i < size; ++i) { // 利用for循环遍历出队列\n                TreeNode *node = q.front();\n                q.pop();\n                level.push_back(node -> val);\n                if(node -> left) q.push(node -> left);\n                if(node -> right) q.push(node -> right);\n            }\n            res.insert(res.begin(), level);\n        }\n        return res;\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p107-binary-tree-level-order-traversal-ii","published":1,"date":"2018-04-28T14:59:29.310Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdu2001qqnn9269z1xlq","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.push(root); <span class=\"comment\">// 作为初始条件</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; level;  <span class=\"comment\">// 存储二叉树层次的值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = q.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123; <span class=\"comment\">// 利用for循环遍历出队列</span></span><br><span class=\"line\">                TreeNode *node = q.front();</span><br><span class=\"line\">                q.pop();</span><br><span class=\"line\">                level.push_back(node -&gt; val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node -&gt; left) q.push(node -&gt; left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node -&gt; right) q.push(node -&gt; right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.insert(res.begin(), level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.push(root); <span class=\"comment\">// 作为初始条件</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; level;  <span class=\"comment\">// 存储二叉树层次的值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = q.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123; <span class=\"comment\">// 利用for循环遍历出队列</span></span><br><span class=\"line\">                TreeNode *node = q.front();</span><br><span class=\"line\">                q.pop();</span><br><span class=\"line\">                level.push_back(node -&gt; val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node -&gt; left) q.push(node -&gt; left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node -&gt; right) q.push(node -&gt; right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.insert(res.begin(), level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"112. Path Sum","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if(root == NULL) return false;\n        if(root -> left == NULL && root -> right == NULL && root -> val == sum) return true;\n        return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p112-path-sum.md","raw":"---\ntitle: 112. Path Sum\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if(root == NULL) return false;\n        if(root -> left == NULL && root -> right == NULL && root -> val == sum) return true;\n        return hasPathSum(root -> left, sum - root -> val) || hasPathSum(root -> right, sum - root -> val);\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p112-path-sum","published":1,"date":"2018-04-28T14:59:29.359Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdu4001vqnn94bryx6ks","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root -&gt; left == <span class=\"literal\">NULL</span> &amp;&amp; root -&gt; right == <span class=\"literal\">NULL</span> &amp;&amp; root -&gt; val == sum) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root -&gt; left == <span class=\"literal\">NULL</span> &amp;&amp; root -&gt; right == <span class=\"literal\">NULL</span> &amp;&amp; root -&gt; val == sum) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"110. Balanced Binary Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if(!root) return true;\n        if(abs(getDepth(root -> left) - getDepth(root -> right)) > 1) return false;\n        return isBalanced(root -> left) && isBalanced(root -> right);\n    }\n    int getDepth(TreeNode* node) {\n        if(!node) return 0;\n        return 1 + max(getDepth(node -> left), getDepth(node -> right));\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p110-balanced-binary-tree.md","raw":"---\ntitle: 110. Balanced Binary Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if(!root) return true;\n        if(abs(getDepth(root -> left) - getDepth(root -> right)) > 1) return false;\n        return isBalanced(root -> left) && isBalanced(root -> right);\n    }\n    int getDepth(TreeNode* node) {\n        if(!node) return 0;\n        return 1 + max(getDepth(node -> left), getDepth(node -> right));\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p110-balanced-binary-tree","published":1,"date":"2018-04-28T14:59:29.335Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdu6001yqnn92wyqw2bm","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(getDepth(root -&gt; left) - getDepth(root -&gt; right)) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isBalanced(root -&gt; left) &amp;&amp; isBalanced(root -&gt; right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!node) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(getDepth(node -&gt; left), getDepth(node -&gt; right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(getDepth(root -&gt; left) - getDepth(root -&gt; right)) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isBalanced(root -&gt; left) &amp;&amp; isBalanced(root -&gt; right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDepth</span><span class=\"params\">(TreeNode* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!node) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(getDepth(node -&gt; left), getDepth(node -&gt; right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"111. Minimum Depth of Binary Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(!root) return 0;\n        if(!root->left) return 1 + minDepth(root->right);\n        if(!root->right) return 1 + minDepth(root->left);\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p111-minimum-depth-of-binary-tree.md","raw":"---\ntitle: 111. Minimum Depth of Binary Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(!root) return 0;\n        if(!root->left) return 1 + minDepth(root->right);\n        if(!root->right) return 1 + minDepth(root->left);\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p111-minimum-depth-of-binary-tree","published":1,"date":"2018-04-28T14:59:29.348Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdu90023qnn9nrtk0wsm","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;left) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + minDepth(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + minDepth(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;left) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + minDepth(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;right) <span class=\"keyword\">return</span> <span class=\"number\">1</span> + minDepth(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"118. Pascal's Triangle","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        // check the input\n        vector<vector<int>> res;\n        if(numRows <= 0) return res;\n        res.assign(numRows, vector<int>(1));\n        for(int i = 0; i < numRows; ++i) {\n            res[i][0] = 1;\n            if(i == 0) continue;\n            for(int j = 1; j < i; ++j) {\n                res[i].push_back(res[i - 1][j] + res[i -1][j - 1]);\n            }\n            res[i].push_back(1);\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p118-pascal's-triangle.md","raw":"---\ntitle: 118. Pascal's Triangle\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        // check the input\n        vector<vector<int>> res;\n        if(numRows <= 0) return res;\n        res.assign(numRows, vector<int>(1));\n        for(int i = 0; i < numRows; ++i) {\n            res[i][0] = 1;\n            if(i == 0) continue;\n            for(int j = 1; j < i; ++j) {\n                res[i].push_back(res[i - 1][j] + res[i -1][j - 1]);\n            }\n            res[i].push_back(1);\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p118-pascal's-triangle","published":1,"date":"2018-04-28T14:59:29.369Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdua0026qnn9vqigreif","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numRows &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        res.assign(numRows, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class=\"line\">            res[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                res[i].push_back(res[i - <span class=\"number\">1</span>][j] + res[i <span class=\"number\">-1</span>][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res[i].push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; generate(<span class=\"keyword\">int</span> numRows) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numRows &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        res.assign(numRows, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class=\"line\">            res[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                res[i].push_back(res[i - <span class=\"number\">1</span>][j] + res[i <span class=\"number\">-1</span>][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res[i].push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"122. Best Time to Buy and Sell Stock II","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        if(prices.size() <= 1) return 0;\n        for(int i = 0; i < prices.size() - 1; ++i) {\n            if(prices[i] < prices[i + 1])\n                res += prices[i + 1] - prices[i];\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p122-best-time-to-buy-and-sell-stock-ii.md","raw":"---\ntitle: 122. Best Time to Buy and Sell Stock II\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        if(prices.size() <= 1) return 0;\n        for(int i = 0; i < prices.size() - 1; ++i) {\n            if(prices[i] < prices[i + 1])\n                res += prices[i + 1] - prices[i];\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p122-best-time-to-buy-and-sell-stock-ii","published":1,"date":"2018-04-28T14:59:29.402Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gduc002aqnn9ex7xpznw","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size() - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i] &lt; prices[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                res += prices[i + <span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prices.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size() - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i] &lt; prices[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">                res += prices[i + <span class=\"number\">1</span>] - prices[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"121. Best Time to Buy and Sell Stock","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0, buy = INT_MAX;\n        for(int price : prices) {\n            buy = min(buy, price);\n            res = max(res, price - buy);\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p121-best-time-to-buy-and-sell-stock.md","raw":"---\ntitle: 121. Best Time to Buy and Sell Stock\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0, buy = INT_MAX;\n        for(int price : prices) {\n            buy = min(buy, price);\n            res = max(res, price - buy);\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p121-best-time-to-buy-and-sell-stock","published":1,"date":"2018-04-28T14:59:29.393Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdud002eqnn9z2finjfo","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, buy = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> price : prices) &#123;</span><br><span class=\"line\">            buy = min(buy, price);</span><br><span class=\"line\">            res = max(res, price - buy);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, buy = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> price : prices) &#123;</span><br><span class=\"line\">            buy = min(buy, price);</span><br><span class=\"line\">            res = max(res, price - buy);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"136. Single Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res = 0;\n        for(int num : nums) res ^= num;\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p136-single-number.md","raw":"---\ntitle: 136. Single Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res = 0;\n        for(int num : nums) res ^= num;\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p136-single-number","published":1,"date":"2018-04-28T14:59:29.428Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdui002iqnn9clg6vvf0","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) res ^= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) res ^= num;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"141. Linked List Cycle","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* slow = head, *fast = head;\n        while(fast && fast -> next) {\n            slow = slow -> next;\n            fast = fast -> next -> next;\n            if(slow == fast) return true;\n        }\n        return false;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p141-linked-list-cycle.md","raw":"---\ntitle: 141. Linked List Cycle\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* slow = head, *fast = head;\n        while(fast && fast -> next) {\n            slow = slow -> next;\n            fast = fast -> next -> next;\n            if(slow == fast) return true;\n        }\n        return false;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p141-linked-list-cycle","published":1,"date":"2018-04-28T14:59:29.441Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gduk002mqnn9sej1uqak","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &amp;&amp; fast -&gt; next) &#123;</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">            fast = fast -&gt; next -&gt; next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &amp;&amp; fast -&gt; next) &#123;</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">            fast = fast -&gt; next -&gt; next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"160. Intersection of Two Linked Lists","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // check the input\n        if(!headA || !headB) return NULL;\n        // get length of A & B\n        int lenA = getLength(headA), lenB = getLength(headB);\n        if(lenA > lenB) {\n            for(int i = 0; i < lenA - lenB; ++i) {\n                headA = headA -> next;\n            }\n        }\n        else {\n            for(int i = 0; i < lenB - lenA; ++i) {\n                headB = headB -> next;\n            }\n        }\n        while(headA && headB && headA != headB) {\n            headA = headA -> next;\n            headB = headB -> next;\n        }\n        return (headA && headB) ? headA : NULL;\n    }\n\n    int getLength(ListNode *head) {\n        int cnt = 0;\n        while (head) {\n            ++cnt;\n            head = head -> next;\n        }\n        return cnt;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p160-intersection-of-two-linked-lists.md","raw":"---\ntitle: 160. Intersection of Two Linked Lists\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // check the input\n        if(!headA || !headB) return NULL;\n        // get length of A & B\n        int lenA = getLength(headA), lenB = getLength(headB);\n        if(lenA > lenB) {\n            for(int i = 0; i < lenA - lenB; ++i) {\n                headA = headA -> next;\n            }\n        }\n        else {\n            for(int i = 0; i < lenB - lenA; ++i) {\n                headB = headB -> next;\n            }\n        }\n        while(headA && headB && headA != headB) {\n            headA = headA -> next;\n            headB = headB -> next;\n        }\n        return (headA && headB) ? headA : NULL;\n    }\n\n    int getLength(ListNode *head) {\n        int cnt = 0;\n        while (head) {\n            ++cnt;\n            head = head -> next;\n        }\n        return cnt;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p160-intersection-of-two-linked-lists","published":1,"date":"2018-04-28T14:59:29.451Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdum002qqnn9f8a98v7r","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!headA || !headB) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// get length of A &amp; B</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA = getLength(headA), lenB = getLength(headB);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lenA &gt; lenB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lenA - lenB; ++i) &#123;</span><br><span class=\"line\">                headA = headA -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lenB - lenA; ++i) &#123;</span><br><span class=\"line\">                headB = headB -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(headA &amp;&amp; headB &amp;&amp; headA != headB) &#123;</span><br><span class=\"line\">            headA = headA -&gt; next;</span><br><span class=\"line\">            headB = headB -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (headA &amp;&amp; headB) ? headA : <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">            head = head -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the input</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!headA || !headB) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// get length of A &amp; B</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA = getLength(headA), lenB = getLength(headB);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lenA &gt; lenB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lenA - lenB; ++i) &#123;</span><br><span class=\"line\">                headA = headA -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; lenB - lenA; ++i) &#123;</span><br><span class=\"line\">                headB = headB -&gt; next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(headA &amp;&amp; headB &amp;&amp; headA != headB) &#123;</span><br><span class=\"line\">            headA = headA -&gt; next;</span><br><span class=\"line\">            headB = headB -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (headA &amp;&amp; headB) ? headA : <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head) &#123;</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">            head = head -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"119. Pascal's Triangle II","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> res;\n        if(rowIndex < 0) return res;\n\n        res.assign(rowIndex + 1, 0);\n        for(int i = 0; i <= rowIndex; ++i) {\n            if(i == 0) {\n                res[0] = 1;\n                continue;\n            }\n            for(int j = rowIndex; j >= 1; --j) {\n                res[j] = res[j] + res[j - 1];\n            }\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p119-pascal's-triangle-ii.md","raw":"---\ntitle: 119. Pascal's Triangle II\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> res;\n        if(rowIndex < 0) return res;\n\n        res.assign(rowIndex + 1, 0);\n        for(int i = 0; i <= rowIndex; ++i) {\n            if(i == 0) {\n                res[0] = 1;\n                continue;\n            }\n            for(int j = rowIndex; j >= 1; --j) {\n                res[j] = res[j] + res[j - 1];\n            }\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p119-pascal's-triangle-ii","published":1,"date":"2018-04-28T14:59:29.382Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdup002uqnn9fxa9ut5o","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; getRow(<span class=\"keyword\">int</span> rowIndex) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rowIndex &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.assign(rowIndex + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = rowIndex; j &gt;= <span class=\"number\">1</span>; --j) &#123;</span><br><span class=\"line\">                res[j] = res[j] + res[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; getRow(<span class=\"keyword\">int</span> rowIndex) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rowIndex &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.assign(rowIndex + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = rowIndex; j &gt;= <span class=\"number\">1</span>; --j) &#123;</span><br><span class=\"line\">                res[j] = res[j] + res[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"169. Majority Element","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int res = 0, cnt = 0;\n        for(int num : nums) {\n            if(cnt == 0) {\n                res = num;\n                cnt++;\n            }\n            else (num == res) ? cnt++ : cnt--;\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p169-majority-element.md","raw":"---\ntitle: 169. Majority Element\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int res = 0, cnt = 0;\n        for(int num : nums) {\n            if(cnt == 0) {\n                res = num;\n                cnt++;\n            }\n            else (num == res) ? cnt++ : cnt--;\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p169-majority-element","published":1,"date":"2018-04-28T14:59:29.488Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdus002yqnn9908doukk","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res = num;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> (num == res) ? cnt++ : cnt--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res = num;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> (num == res) ? cnt++ : cnt--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"167. Two Sum II","_content":"\n~~~cpp\n// O(nlogn) incorrect!!!\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        for(int i = 0; i < numbers.size(); ++i) {\n            int t = target - numbers[i], left = i + 1, right = numbers.size() - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if(numbers[mid] == t) return {i + 1, mid + 1}; // +1 因为index相比下标增1\n                else if(numbers[mid] < t) left = mid + 1;\n                else right = mid - 1;\n            }\n        }\n        return {}; // 这标明使用函数返参类型进行默认构造\n    }\n};\n\n// O(n)\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int l = 0, r = numbers.size() - 1;\n        while(l < r) {\n            int sum = numbers[l] + numbers[r];\n            if(sum == target) return {l + 1, r + 1};\n            else if(sum < target) ++l;\n            else --r;\n        }\n        return {};\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p167-two-sum-ii---input-array-is-sorted.md","raw":"---\ntitle: 167. Two Sum II\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n// O(nlogn) incorrect!!!\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        for(int i = 0; i < numbers.size(); ++i) {\n            int t = target - numbers[i], left = i + 1, right = numbers.size() - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if(numbers[mid] == t) return {i + 1, mid + 1}; // +1 因为index相比下标增1\n                else if(numbers[mid] < t) left = mid + 1;\n                else right = mid - 1;\n            }\n        }\n        return {}; // 这标明使用函数返参类型进行默认构造\n    }\n};\n\n// O(n)\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int l = 0, r = numbers.size() - 1;\n        while(l < r) {\n            int sum = numbers[l] + numbers[r];\n            if(sum == target) return {l + 1, r + 1};\n            else if(sum < target) ++l;\n            else --r;\n        }\n        return {};\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p167-two-sum-ii---input-array-is-sorted","published":1,"date":"2018-04-28T14:59:29.466Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdut0032qnn9f637earg","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// O(nlogn) incorrect!!!</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - numbers[i], left = i + <span class=\"number\">1</span>, right = numbers.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(numbers[mid] == t) <span class=\"keyword\">return</span> &#123;i + <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>&#125;; <span class=\"comment\">// +1 因为index相比下标增1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[mid] &lt; t) left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;; <span class=\"comment\">// 这标明使用函数返参类型进行默认构造</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// O(n)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = numbers.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = numbers[l] + numbers[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target) <span class=\"keyword\">return</span> &#123;l + <span class=\"number\">1</span>, r + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; target) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> --r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// O(nlogn) incorrect!!!</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - numbers[i], left = i + <span class=\"number\">1</span>, right = numbers.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(numbers[mid] == t) <span class=\"keyword\">return</span> &#123;i + <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>&#125;; <span class=\"comment\">// +1 因为index相比下标增1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[mid] &lt; t) left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;; <span class=\"comment\">// 这标明使用函数返参类型进行默认构造</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// O(n)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = numbers.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = numbers[l] + numbers[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target) <span class=\"keyword\">return</span> &#123;l + <span class=\"number\">1</span>, r + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; target) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> --r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"168. Excel Sheet Column Title","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string res = \"\";\n        while(n) {\n            res += --n % 26 + 'A';\n            n /= 26;\n        }\n        return string(res.rbegin(), res.rend());\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p168-excel-sheet-column-title.md","raw":"---\ntitle: 168. Excel Sheet Column Title\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string res = \"\";\n        while(n) {\n            res += --n % 26 + 'A';\n            n /= 26;\n        }\n        return string(res.rbegin(), res.rend());\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p168-excel-sheet-column-title","published":1,"date":"2018-04-28T14:59:29.477Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gduy0036qnn9ochzx5cz","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convertToTitle</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">            res += --n % <span class=\"number\">26</span> + <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>(res.rbegin(), res.rend());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convertToTitle</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">            res += --n % <span class=\"number\">26</span> + <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>(res.rbegin(), res.rend());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"171. Excel Sheet Column Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int titleToNumber(string s) {\n        int n = s.size();\n        int res = 0;\n        int base = 1;\n        for(int i =n  - 1; i >= 0; --i) {\n            res += (s[i] - 'A' + 1) * base;\n            base *= 26;\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p171-excel-sheet-column-number.md","raw":"---\ntitle: 171. Excel Sheet Column Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int titleToNumber(string s) {\n        int n = s.size();\n        int res = 0;\n        int base = 1;\n        for(int i =n  - 1; i >= 0; --i) {\n            res += (s[i] - 'A' + 1) * base;\n            base *= 26;\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p171-excel-sheet-column-number","published":1,"date":"2018-04-28T14:59:29.501Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdv20039qnn92xj7hu21","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> base = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =n  - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            res += (s[i] - <span class=\"string\">'A'</span> + <span class=\"number\">1</span>) * base;</span><br><span class=\"line\">            base *= <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">titleToNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> base = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =n  - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            res += (s[i] - <span class=\"string\">'A'</span> + <span class=\"number\">1</span>) * base;</span><br><span class=\"line\">            base *= <span class=\"number\">26</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"125. Valid Palindrome","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            if(!isAlphaNum(s[left])) left++;\n            else if(!isAlphaNum(s[right])) right--;\n            else if((s[left] + 32 - 'a') % 32 != (s[right] + 32 - 'a') % 32) return false;\n            else {\n                ++left, --right;\n            }\n        }\n        return true;\n    }\n\n    bool isAlphaNum(char& ch) {\n        if(ch >= 'a' && ch <= 'z') return true;\n        if(ch >= 'A' && ch <= 'Z') return true;\n        if(ch >= '0' && ch <= '9') return true;\n        return false;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p125-valid-palindrome.md","raw":"---\ntitle: 125. Valid Palindrome\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            if(!isAlphaNum(s[left])) left++;\n            else if(!isAlphaNum(s[right])) right--;\n            else if((s[left] + 32 - 'a') % 32 != (s[right] + 32 - 'a') % 32) return false;\n            else {\n                ++left, --right;\n            }\n        }\n        return true;\n    }\n\n    bool isAlphaNum(char& ch) {\n        if(ch >= 'a' && ch <= 'z') return true;\n        if(ch >= 'A' && ch <= 'Z') return true;\n        if(ch >= '0' && ch <= '9') return true;\n        return false;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p125-valid-palindrome","published":1,"date":"2018-04-28T14:59:29.416Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdv6003eqnn939z9crwd","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!isAlphaNum(s[left])) left++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!isAlphaNum(s[right])) right--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((s[left] + <span class=\"number\">32</span> - <span class=\"string\">'a'</span>) % <span class=\"number\">32</span> != (s[right] + <span class=\"number\">32</span> - <span class=\"string\">'a'</span>) % <span class=\"number\">32</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++left, --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAlphaNum</span><span class=\"params\">(<span class=\"keyword\">char</span>&amp; ch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'a'</span> &amp;&amp; ch &lt;= <span class=\"string\">'z'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'A'</span> &amp;&amp; ch &lt;= <span class=\"string\">'Z'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!isAlphaNum(s[left])) left++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!isAlphaNum(s[right])) right--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((s[left] + <span class=\"number\">32</span> - <span class=\"string\">'a'</span>) % <span class=\"number\">32</span> != (s[right] + <span class=\"number\">32</span> - <span class=\"string\">'a'</span>) % <span class=\"number\">32</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++left, --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAlphaNum</span><span class=\"params\">(<span class=\"keyword\">char</span>&amp; ch)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'a'</span> &amp;&amp; ch &lt;= <span class=\"string\">'z'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'A'</span> &amp;&amp; ch &lt;= <span class=\"string\">'Z'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'0'</span> &amp;&amp; ch &lt;= <span class=\"string\">'9'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"189. Rotate Array","_content":"\n~~~cpp\n// O(n) space\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        vector<int> tmp = nums;\n        for(int i = 0; i < nums.size(); i++) {\n            nums[(i + k) % nums.size()] = tmp[i];\n        }\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p189-rotate-array.md","raw":"---\ntitle: 189. Rotate Array\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n// O(n) space\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        vector<int> tmp = nums;\n        for(int i = 0; i < nums.size(); i++) {\n            nums[(i + k) % nums.size()] = tmp[i];\n        }\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p189-rotate-array","published":1,"date":"2018-04-28T14:59:29.519Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdv8003hqnn9reexzcu8","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// O(n) space</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = nums;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            nums[(i + k) % nums.size()] = tmp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// O(n) space</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = nums;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            nums[(i + k) % nums.size()] = tmp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"20. Valid Parentheses","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> parentheses;\n        for(int i = 0; i < s.size(); ++i) {\n            if(s[i] == '(' || s[i] == '{' || s[i] == '[') parentheses.push(s[i]);\n            else {\n                if(parentheses.empty()) return false;\n                if(s[i] == ')' && parentheses.top() != '(') return false;\n                if(s[i] == ']' && parentheses.top() != '[') return false;\n                if(s[i] == '}' && parentheses.top() != '{') return false;\n                parentheses.pop();\n            }\n        }\n        return parentheses.empty();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p20-valid-parentheses.md","raw":"---\ntitle: 20. Valid Parentheses\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> parentheses;\n        for(int i = 0; i < s.size(); ++i) {\n            if(s[i] == '(' || s[i] == '{' || s[i] == '[') parentheses.push(s[i]);\n            else {\n                if(parentheses.empty()) return false;\n                if(s[i] == ')' && parentheses.top() != '(') return false;\n                if(s[i] == ']' && parentheses.top() != '[') return false;\n                if(s[i] == '}' && parentheses.top() != '{') return false;\n                parentheses.pop();\n            }\n        }\n        return parentheses.empty();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p20-valid-parentheses","published":1,"date":"2018-04-28T14:59:29.754Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvb003mqnn9895u4sgj","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; parentheses;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'('</span> || s[i] == <span class=\"string\">'&#123;'</span> || s[i] == <span class=\"string\">'['</span>) parentheses.push(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(parentheses.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">')'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'('</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">']'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'['</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'&#125;'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'&#123;'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                parentheses.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parentheses.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; parentheses;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'('</span> || s[i] == <span class=\"string\">'&#123;'</span> || s[i] == <span class=\"string\">'['</span>) parentheses.push(s[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(parentheses.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">')'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'('</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">']'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'['</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'&#125;'</span> &amp;&amp; parentheses.top() != <span class=\"string\">'&#123;'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                parentheses.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parentheses.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"190. Reverse Bits","_content":"\n~~~cpp\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t result = 0;\n        for(int i = 0; i < 32; ++i) {\n            result = (result << 1) + (n >> i & 1);\n        }\n        return result;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p190-reverse-bits.md","raw":"---\ntitle: 190. Reverse Bits\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t result = 0;\n        for(int i = 0; i < 32; ++i) {\n            result = (result << 1) + (n >> i & 1);\n        }\n        return result;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p190-reverse-bits","published":1,"date":"2018-04-28T14:59:29.528Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdve003pqnn99dnv58l2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reverseBits(<span class=\"keyword\">uint32_t</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">            result = (result &lt;&lt; <span class=\"number\">1</span>) + (n &gt;&gt; i &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reverseBits(<span class=\"keyword\">uint32_t</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint32_t</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">            result = (result &lt;&lt; <span class=\"number\">1</span>) + (n &gt;&gt; i &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"203. Remove Linked List Elements","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* preHead = new ListNode(0);\n        preHead -> next = head;\n        ListNode* cur = preHead;\n        while(cur) {\n            if(cur -> next && cur -> next -> val == val) cur -> next = cur -> next -> next;\n            else\n                cur = cur -> next;\n        }\n        return preHead -> next;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p203-remove-linked-list-elements.md","raw":"---\ntitle: 203. Remove Linked List Elements\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* preHead = new ListNode(0);\n        preHead -> next = head;\n        ListNode* cur = preHead;\n        while(cur) {\n            if(cur -> next && cur -> next -> val == val) cur -> next = cur -> next -> next;\n            else\n                cur = cur -> next;\n        }\n        return preHead -> next;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p203-remove-linked-list-elements","published":1,"date":"2018-04-28T14:59:29.545Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvg003tqnn9oeyla9o0","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeElements</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* preHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        preHead -&gt; next = head;</span><br><span class=\"line\">        ListNode* cur = preHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val == val) cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                cur = cur -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preHead -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeElements</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* preHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        preHead -&gt; next = head;</span><br><span class=\"line\">        ListNode* cur = preHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val == val) cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                cur = cur -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preHead -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"191. Number of 1 Bits","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int res = 0;\n        for(int i = 0; i < 32; ++i) {\n            res += (n & 1);\n            n = n >> 1;\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p191-number-of-1-bits.md","raw":"---\ntitle: 191. Number of 1 Bits\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int res = 0;\n        for(int i = 0; i < 32; ++i) {\n            res += (n & 1);\n            n = n >> 1;\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p191-number-of-1-bits","published":1,"date":"2018-04-28T14:59:29.536Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvi003wqnn9l5aru7vp","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">            res += (n &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">            n = n &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; ++i) &#123;</span><br><span class=\"line\">            res += (n &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">            n = n &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"204. Count Primes","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> prime(n, true);\n        prime[0] = false, prime[1] = false;\n        for (int i = 0; i < sqrt(n); ++i) {\n            if (prime[i]) {\n                for (int j = i*i; j < n; j += i) {\n                    prime[j] = false;\n                }\n            }\n        }\n        return count(prime.begin(), prime.end(), true);\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p204-count-primes.md","raw":"---\ntitle: 204. Count Primes\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> prime(n, true);\n        prime[0] = false, prime[1] = false;\n        for (int i = 0; i < sqrt(n); ++i) {\n            if (prime[i]) {\n                for (int j = i*i; j < n; j += i) {\n                    prime[j] = false;\n                }\n            }\n        }\n        return count(prime.begin(), prime.end(), true);\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p204-count-primes","published":1,"date":"2018-04-28T14:59:29.552Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvk0040qnn9l3nx5uly","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPrimes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; prime(n, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        prime[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>, prime[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">sqrt</span>(n); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prime[i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i*i; j &lt; n; j += i) &#123;</span><br><span class=\"line\">                    prime[j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count(prime.begin(), prime.end(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPrimes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">bool</span>&gt; prime(n, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        prime[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>, prime[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">sqrt</span>(n); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prime[i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i*i; j &lt; n; j += i) &#123;</span><br><span class=\"line\">                    prime[j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count(prime.begin(), prime.end(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"205. Isomorphic Strings","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int map1[256] = {0}, map2[256] = {0}, n = s.size();\n        for(int i = 0; i < n; ++i) {\n            // 这里存入的字符其实是Unicode的数值，由于if语句在前，所以只需要初始化第一个值\n            if(map1[s[i]] != map2[t[i]]) return false;\n            map1[s[i]] = i + 1;\n            map2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p205-isomorphic-strings.md","raw":"---\ntitle: 205. Isomorphic Strings\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int map1[256] = {0}, map2[256] = {0}, n = s.size();\n        for(int i = 0; i < n; ++i) {\n            // 这里存入的字符其实是Unicode的数值，由于if语句在前，所以只需要初始化第一个值\n            if(map1[s[i]] != map2[t[i]]) return false;\n            map1[s[i]] = i + 1;\n            map2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p205-isomorphic-strings","published":1,"date":"2018-04-28T14:59:29.556Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvm0043qnn9epuuylto","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> map1[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;, map2[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;, n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里存入的字符其实是Unicode的数值，由于if语句在前，所以只需要初始化第一个值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map1[s[i]] != map2[t[i]]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            map1[s[i]] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            map2[t[i]] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> map1[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;, map2[<span class=\"number\">256</span>] = &#123;<span class=\"number\">0</span>&#125;, n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里存入的字符其实是Unicode的数值，由于if语句在前，所以只需要初始化第一个值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map1[s[i]] != map2[t[i]]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            map1[s[i]] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            map2[t[i]] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"206. Reverse Linked List","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n // wrong version, find why it's wrong\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head == NULL) return NULL;\n        ListNode* pre = head;\n        ListNode* cur = head -> next;\n        while(cur != NULL){\n            pre -> next -> next = pre;\n            pre = cur;\n            cur = cur -> next;\n        }\n        return pre;\n    }\n};\n\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        ListNode* new_head = new ListNode(0);\n        new_head -> next = head;\n        ListNode* pre = new_head;\n        ListNode* cur = head;\n\n        while (cur && cur -> next) {\n            ListNode* temp = pre -> next;\n            pre -> next = cur -> next;\n            cur -> next = cur -> next -> next;\n            pre -> next -> next = temp;\n        }\n        return new_head -> next;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p206-reverse-linked-list.md","raw":"---\ntitle: 206. Reverse Linked List\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n // wrong version, find why it's wrong\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head == NULL) return NULL;\n        ListNode* pre = head;\n        ListNode* cur = head -> next;\n        while(cur != NULL){\n            pre -> next -> next = pre;\n            pre = cur;\n            cur = cur -> next;\n        }\n        return pre;\n    }\n};\n\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        ListNode* new_head = new ListNode(0);\n        new_head -> next = head;\n        ListNode* pre = new_head;\n        ListNode* cur = head;\n\n        while (cur && cur -> next) {\n            ListNode* temp = pre -> next;\n            pre -> next = cur -> next;\n            cur -> next = cur -> next -> next;\n            pre -> next -> next = temp;\n        }\n        return new_head -> next;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p206-reverse-linked-list","published":1,"date":"2018-04-28T14:59:29.561Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvn0047qnn9yw2zzk6z","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// wrong version, find why it's wrong</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode* pre = head;</span><br><span class=\"line\">        ListNode* cur = head -&gt; next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            pre -&gt; next -&gt; next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* new_head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        new_head -&gt; next = head;</span><br><span class=\"line\">        ListNode* pre = new_head;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur &amp;&amp; cur -&gt; next) &#123;</span><br><span class=\"line\">            ListNode* temp = pre -&gt; next;</span><br><span class=\"line\">            pre -&gt; next = cur -&gt; next;</span><br><span class=\"line\">            cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class=\"line\">            pre -&gt; next -&gt; next = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// wrong version, find why it's wrong</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode* pre = head;</span><br><span class=\"line\">        ListNode* cur = head -&gt; next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            pre -&gt; next -&gt; next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* new_head = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        new_head -&gt; next = head;</span><br><span class=\"line\">        ListNode* pre = new_head;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur &amp;&amp; cur -&gt; next) &#123;</span><br><span class=\"line\">            ListNode* temp = pre -&gt; next;</span><br><span class=\"line\">            pre -&gt; next = cur -&gt; next;</span><br><span class=\"line\">            cur -&gt; next = cur -&gt; next -&gt; next;</span><br><span class=\"line\">            pre -&gt; next -&gt; next = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"226. Invert Binary Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(!root) return root;\n        TreeNode *tmp = root -> left;\n        root -> left = invertTree(root -> right);\n        root -> right = invertTree(tmp);\n        return root;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p226-invert-binary-tree.md","raw":"---\ntitle: 226. Invert Binary Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(!root) return root;\n        TreeNode *tmp = root -> left;\n        root -> left = invertTree(root -> right);\n        root -> right = invertTree(tmp);\n        return root;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p226-invert-binary-tree","published":1,"date":"2018-04-28T14:59:29.569Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvp004aqnn9nxinyozx","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode *tmp = root -&gt; left;</span><br><span class=\"line\">        root -&gt; left = invertTree(root -&gt; right);</span><br><span class=\"line\">        root -&gt; right = invertTree(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        TreeNode *tmp = root -&gt; left;</span><br><span class=\"line\">        root -&gt; left = invertTree(root -&gt; right);</span><br><span class=\"line\">        root -&gt; right = invertTree(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"21. Merge Two Sorted Lists","_content":"\n~~~cpp\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n      ListNode *res = new ListNode(-1), *cur = res;\n      while(l1 && l2) {\n          if(l1 -> val > l2 -> val) {\n              cur -> next = l2;\n              l2 = l2 -> next;\n          } else {\n              cur -> next = l1;\n              l1 = l1 -> next;\n          }\n          cur = cur -> next;\n      }\n      cur -> next = l1 ? l1 : l2;\n      return res -> next;\n  }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p21-merge-two-sorted-lists.md","raw":"---\ntitle: 21. Merge Two Sorted Lists\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n      ListNode *res = new ListNode(-1), *cur = res;\n      while(l1 && l2) {\n          if(l1 -> val > l2 -> val) {\n              cur -> next = l2;\n              l2 = l2 -> next;\n          } else {\n              cur -> next = l1;\n              l1 = l1 -> next;\n          }\n          cur = cur -> next;\n      }\n      cur -> next = l1 ? l1 : l2;\n      return res -> next;\n  }\n};\n~~~","slug":"Algorithm/LeetCode/p21-merge-two-sorted-lists","published":1,"date":"2018-04-28T14:59:29.758Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvq004eqnn9e6lzsom5","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\">* struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*     int val;</span></span><br><span class=\"line\"><span class=\"comment\">*     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">* &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">      ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>), *cur = res;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(l1 -&gt; val &gt; l2 -&gt; val) &#123;</span><br><span class=\"line\">              cur -&gt; next = l2;</span><br><span class=\"line\">              l2 = l2 -&gt; next;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              cur -&gt; next = l1;</span><br><span class=\"line\">              l1 = l1 -&gt; next;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          cur = cur -&gt; next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cur -&gt; next = l1 ? l1 : l2;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res -&gt; next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\">* struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*     int val;</span></span><br><span class=\"line\"><span class=\"comment\">*     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\">*     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">* &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">      ListNode *res = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>), *cur = res;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(l1 -&gt; val &gt; l2 -&gt; val) &#123;</span><br><span class=\"line\">              cur -&gt; next = l2;</span><br><span class=\"line\">              l2 = l2 -&gt; next;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              cur -&gt; next = l1;</span><br><span class=\"line\">              l1 = l1 -&gt; next;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          cur = cur -&gt; next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cur -&gt; next = l1 ? l1 : l2;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res -&gt; next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"231. Power of Two","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int cnt = 0;\n        while (n > 0) {\n            cnt += (n & 1);\n            n >>= 1;\n        }\n        return cnt == 1;\n    }\n};\n\n\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if(n <= 0) return false;\n        while(n > 1) {\n            if(n%2 != 0) return false;\n            n /= 2;\n          }\n          return n == 1;\n      }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p231-power-of-two.md","raw":"---\ntitle: 231. Power of Two\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int cnt = 0;\n        while (n > 0) {\n            cnt += (n & 1);\n            n >>= 1;\n        }\n        return cnt == 1;\n    }\n};\n\n\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if(n <= 0) return false;\n        while(n > 1) {\n            if(n%2 != 0) return false;\n            n /= 2;\n          }\n          return n == 1;\n      }\n};\n~~~","slug":"Algorithm/LeetCode/p231-power-of-two","published":1,"date":"2018-04-28T14:59:29.572Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvs004hqnn99zg68hme","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cnt += (n &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            cnt += (n &amp; <span class=\"number\">1</span>);</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"217. Contains Duplicate","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            if(m.find(nums[i]) != m.end()) return true;\n            ++m[nums[i]];\n        }\n        return false;\n\n    }\n};\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for(int i = 1; i < nums.size(); ++i){\n            if(nums[i] == nums[i-1]) return true; // nums[i] == nums[i+1] 的情况下，进入循环后可能出现下标访问溢出\n        }\n        return false;\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p217-contains-duplicate.md","raw":"---\ntitle: 217. Contains Duplicate\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); ++i) {\n            if(m.find(nums[i]) != m.end()) return true;\n            ++m[nums[i]];\n        }\n        return false;\n\n    }\n};\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for(int i = 1; i < nums.size(); ++i){\n            if(nums[i] == nums[i-1]) return true; // nums[i] == nums[i+1] 的情况下，进入循环后可能出现下标访问溢出\n        }\n        return false;\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p217-contains-duplicate","published":1,"date":"2018-04-28T14:59:29.564Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvx004lqnn97msjfai9","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.find(nums[i]) != m.end()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            ++m[nums[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// nums[i] == nums[i+1] 的情况下，进入循环后可能出现下标访问溢出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m.find(nums[i]) != m.end()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            ++m[nums[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// nums[i] == nums[i+1] 的情况下，进入循环后可能出现下标访问溢出</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"232. Implement Queue using Stacks","_content":"\n~~~cpp\nclass MyQueue {\nprivate:\n    stack<int> st;\n\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stack<int> tmp;\n        while(!st.empty()) {\n            tmp.push(st.top());\n            st.pop();\n        }\n        st.push(x);\n        while(!tmp.empty()) {\n            st.push(tmp.top());\n            tmp.pop();\n        }\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int res = st.top();\n        st.pop();\n        return res;\n    }\n\n    /** Get the front element. */\n    int peek() {\n        return st.top();\n    }\n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return st.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * bool param_4 = obj.empty();\n */\n~~~","source":"_posts/Algorithm/LeetCode/p232-implement-queue-using-stacks.md","raw":"---\ntitle: 232. Implement Queue using Stacks\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass MyQueue {\nprivate:\n    stack<int> st;\n\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stack<int> tmp;\n        while(!st.empty()) {\n            tmp.push(st.top());\n            st.pop();\n        }\n        st.push(x);\n        while(!tmp.empty()) {\n            st.push(tmp.top());\n            tmp.pop();\n        }\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int res = st.top();\n        st.pop();\n        return res;\n    }\n\n    /** Get the front element. */\n    int peek() {\n        return st.top();\n    }\n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return st.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * bool param_4 = obj.empty();\n */\n~~~","slug":"Algorithm/LeetCode/p232-implement-queue-using-stacks","published":1,"date":"2018-04-28T14:59:29.575Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdvz004oqnn9842wec5f","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MyQueue() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">            tmp.push(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!tmp.empty()) &#123;</span><br><span class=\"line\">            st.push(tmp.top());</span><br><span class=\"line\">            tmp.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MyQueue() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.empty()) &#123;</span><br><span class=\"line\">            tmp.push(st.top());</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!tmp.empty()) &#123;</span><br><span class=\"line\">            st.push(tmp.top());</span><br><span class=\"line\">            tmp.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.top();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>"},{"title":"237. Delete Node in a Linked List","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node -> val = node -> next -> val;\n        node -> next = node -> next -> next;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p237-delete-node-in-a-linked-list.md","raw":"---\ntitle: 237. Delete Node in a Linked List\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node -> val = node -> next -> val;\n        node -> next = node -> next -> next;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p237-delete-node-in-a-linked-list","published":1,"date":"2018-04-28T14:59:29.581Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdw5004sqnn970iran1z","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node -&gt; val = node -&gt; next -&gt; val;</span><br><span class=\"line\">        node -&gt; next = node -&gt; next -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode* node)</span> </span>&#123;</span><br><span class=\"line\">        node -&gt; val = node -&gt; next -&gt; val;</span><br><span class=\"line\">        node -&gt; next = node -&gt; next -&gt; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"225. Implement Stack using Queues","_content":"\n~~~cpp\nclass MyStack {\nprivate:\n    queue<int> q;\n\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n\n    /** Push element x onto stack. */\n    void push(int x) {\n        queue<int> tmp;\n        while(!q.empty()){\n            tmp.push(q.front());\n            q.pop();\n        }\n        q.push(x);\n        while(!tmp.empty()){\n            q.push(tmp.front());\n            tmp.pop();\n        }\n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int res = q.front();\n        q.pop();\n        return res;\n    }\n\n    /** Get the top element. */\n    int top() {\n        return q.front();\n    }\n\n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q.empty();\n    }\n\n\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * bool param_4 = obj.empty();\n */\n~~~","source":"_posts/Algorithm/LeetCode/p225-implement-stack-using-queues.md","raw":"---\ntitle: 225. Implement Stack using Queues\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass MyStack {\nprivate:\n    queue<int> q;\n\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n\n    /** Push element x onto stack. */\n    void push(int x) {\n        queue<int> tmp;\n        while(!q.empty()){\n            tmp.push(q.front());\n            q.pop();\n        }\n        q.push(x);\n        while(!tmp.empty()){\n            q.push(tmp.front());\n            tmp.pop();\n        }\n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int res = q.front();\n        q.pop();\n        return res;\n    }\n\n    /** Get the top element. */\n    int top() {\n        return q.front();\n    }\n\n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q.empty();\n    }\n\n\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * bool param_4 = obj.empty();\n */\n~~~","slug":"Algorithm/LeetCode/p225-implement-stack-using-queues","published":1,"date":"2018-04-28T14:59:29.567Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdw8004vqnn98l5edvm2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MyStack() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Push element x onto stack. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">            tmp.push(q.front());</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!tmp.empty())&#123;</span><br><span class=\"line\">            q.push(tmp.front());</span><br><span class=\"line\">            tmp.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Get the top element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the stack is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyStack obj = new MyStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    MyStack() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Push element x onto stack. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">            tmp.push(q.front());</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!tmp.empty())&#123;</span><br><span class=\"line\">            q.push(tmp.front());</span><br><span class=\"line\">            tmp.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = q.front();</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Get the top element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the stack is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyStack obj = new MyStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>"},{"title":"242. Valid Anagram","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.size() != t.size()) return false;\n        int n = s.size();\n        unordered_map<char, int> m;\n        for(int i = 0; i < n; ++i) {\n            m[s[i]]++;\n            m[t[i]]--;\n        }\n        for(auto i : m) {\n            if(i.second) return false;\n        }\n        return true;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p242-valid-anagram.md","raw":"---\ntitle: 242. Valid Anagram\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.size() != t.size()) return false;\n        int n = s.size();\n        unordered_map<char, int> m;\n        for(int i = 0; i < n; ++i) {\n            m[s[i]]++;\n            m[t[i]]--;\n        }\n        for(auto i : m) {\n            if(i.second) return false;\n        }\n        return true;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p242-valid-anagram","published":1,"date":"2018-04-28T14:59:29.584Z","updated":"2019-03-23T03:36:10.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwd004zqnn9z0a4xuik","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAnagram</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() != t.size()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            m[s[i]]++;</span><br><span class=\"line\">            m[t[i]]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : m) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i.second) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isAnagram</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.size() != t.size()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.size();</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            m[s[i]]++;</span><br><span class=\"line\">            m[t[i]]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : m) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i.second) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"26. Remove Duplicates from Sorted Array","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() <= 1) return nums.size();\n        int pre = 0, cur = 0;\n        while(cur < nums.size()) {\n            if(nums[cur] == nums[pre]) ++cur;\n            else nums[++pre] = nums[cur++];\n        }\n        return pre+1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p26-remove-duplicates-from-sorted-array.md","raw":"---\ntitle: 26. Remove Duplicates from Sorted Array\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() <= 1) return nums.size();\n        int pre = 0, cur = 0;\n        while(cur < nums.size()) {\n            if(nums[cur] == nums[pre]) ++cur;\n            else nums[++pre] = nums[cur++];\n        }\n        return pre+1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p26-remove-duplicates-from-sorted-array","published":1,"date":"2018-04-28T14:59:29.761Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwf0052qnn9hp646n3p","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur &lt; nums.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[cur] == nums[pre]) ++cur;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nums[++pre] = nums[cur++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.size() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pre = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur &lt; nums.size()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[cur] == nums[pre]) ++cur;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> nums[++pre] = nums[cur++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"234. Palindrome Linked List","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n// wrong Solution, find the cause!\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL || head->next == NULL) return true;\n        ListNode *preHead = new ListNode(-1);\n        preHead -> next = head;\n        ListNode *slow = preHead;\n        ListNode *fast = preHead;\n\n        stack<int> st;\n\n        while(fast && fast -> next) {\n            slow = slow -> next;\n            st.push(slow -> val);\n            fast = fast -> next -> next;\n        }\n\n        if(fast == NULL) st.pop();\n\n        slow = slow -> next;\n\n        while(slow && slow -> val == st.top()) {\n            st.pop();\n            slow = slow -> next;\n        }\n        return st.empty();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p234-palindrome-linked-list.md","raw":"---\ntitle: 234. Palindrome Linked List\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n// wrong Solution, find the cause!\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if(head == NULL || head->next == NULL) return true;\n        ListNode *preHead = new ListNode(-1);\n        preHead -> next = head;\n        ListNode *slow = preHead;\n        ListNode *fast = preHead;\n\n        stack<int> st;\n\n        while(fast && fast -> next) {\n            slow = slow -> next;\n            st.push(slow -> val);\n            fast = fast -> next -> next;\n        }\n\n        if(fast == NULL) st.pop();\n\n        slow = slow -> next;\n\n        while(slow && slow -> val == st.top()) {\n            st.pop();\n            slow = slow -> next;\n        }\n        return st.empty();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p234-palindrome-linked-list","published":1,"date":"2018-04-28T14:59:29.578Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwj0056qnn9sbeew0r1","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// wrong Solution, find the cause!</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span> || head-&gt;next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ListNode *preHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        preHead -&gt; next = head;</span><br><span class=\"line\">        ListNode *slow = preHead;</span><br><span class=\"line\">        ListNode *fast = preHead;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &amp;&amp; fast -&gt; next) &#123;</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">            st.push(slow -&gt; val);</span><br><span class=\"line\">            fast = fast -&gt; next -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast == <span class=\"literal\">NULL</span>) st.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        slow = slow -&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow &amp;&amp; slow -&gt; val == st.top()) &#123;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// wrong Solution, find the cause!</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">NULL</span> || head-&gt;next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ListNode *preHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        preHead -&gt; next = head;</span><br><span class=\"line\">        ListNode *slow = preHead;</span><br><span class=\"line\">        ListNode *fast = preHead;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &amp;&amp; fast -&gt; next) &#123;</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">            st.push(slow -&gt; val);</span><br><span class=\"line\">            fast = fast -&gt; next -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast == <span class=\"literal\">NULL</span>) st.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        slow = slow -&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow &amp;&amp; slow -&gt; val == st.top()) &#123;</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            slow = slow -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"257. Binary Tree Paths","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> res;\n        if(root) dfs(root, \"\", res);\n        return res;\n    }\n\n    void dfs(TreeNode *root, string out, vector<string> &res) {\n        out += to_string(root->val);\n        if(!root->left && !root->right) res.push_back(out);\n        else {\n            if(root->left) dfs(root->left, out + \"->\", res);\n            if(root ->right) dfs(root->right, out + \"->\", res);\n        }\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p257-binary-tree-paths.md","raw":"---\ntitle: 257. Binary Tree Paths\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> res;\n        if(root) dfs(root, \"\", res);\n        return res;\n    }\n\n    void dfs(TreeNode *root, string out, vector<string> &res) {\n        out += to_string(root->val);\n        if(!root->left && !root->right) res.push_back(out);\n        else {\n            if(root->left) dfs(root->left, out + \"->\", res);\n            if(root ->right) dfs(root->right, out + \"->\", res);\n        }\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p257-binary-tree-paths","published":1,"date":"2018-04-28T14:59:29.586Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwk0059qnn9o1cubcgy","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root) dfs(root, <span class=\"string\">\"\"</span>, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">string</span> out, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class=\"line\">        out += to_string(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) res.push_back(out);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;left) dfs(root-&gt;left, out + <span class=\"string\">\"-&gt;\"</span>, res);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root -&gt;right) dfs(root-&gt;right, out + <span class=\"string\">\"-&gt;\"</span>, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root) dfs(root, <span class=\"string\">\"\"</span>, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode *root, <span class=\"built_in\">string</span> out, <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class=\"line\">        out += to_string(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) res.push_back(out);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;left) dfs(root-&gt;left, out + <span class=\"string\">\"-&gt;\"</span>, res);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root -&gt;right) dfs(root-&gt;right, out + <span class=\"string\">\"-&gt;\"</span>, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"258. Add Digits","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        int res = 0;\n        while(num > 0) {\n            res += num % 10;\n            num /= 10;\n        }\n        return res >= 10 ? addDigits(res) : res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p258-add-digits.md","raw":"---\ntitle: 258. Add Digits\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int addDigits(int num) {\n        int res = 0;\n        while(num > 0) {\n            res += num % 10;\n            num /= 10;\n        }\n        return res >= 10 ? addDigits(res) : res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p258-add-digits","published":1,"date":"2018-04-28T14:59:29.589Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwm005dqnn9bpxscj40","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addDigits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res += num % <span class=\"number\">10</span>;</span><br><span class=\"line\">            num /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res &gt;= <span class=\"number\">10</span> ? addDigits(res) : res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addDigits</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res += num % <span class=\"number\">10</span>;</span><br><span class=\"line\">            num /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res &gt;= <span class=\"number\">10</span> ? addDigits(res) : res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"268. Missing Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int sum = 0, n = nums.size();\n        for(auto &i : nums)\n            sum += i;\n        return 0.5 * n * (n + 1) - sum;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p268-missing-number.md","raw":"---\ntitle: 268. Missing Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int sum = 0, n = nums.size();\n        for(auto &i : nums)\n            sum += i;\n        return 0.5 * n * (n + 1) - sum;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p268-missing-number","published":1,"date":"2018-04-28T14:59:29.595Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdws005gqnn9fny530mr","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i : nums)</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span> * n * (n + <span class=\"number\">1</span>) - sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, n = nums.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;i : nums)</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.5</span> * n * (n + <span class=\"number\">1</span>) - sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"263. Ugly Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isUgly(int num) {\n        while(num >= 2) {\n            if(num % 2 == 0) num /= 2;\n            else if(num % 3 == 0) num /= 3;\n            else if(num % 5 == 0) num /= 5;\n            else return false;\n        }\n        return num == 1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p263-ugly-number.md","raw":"---\ntitle: 263. Ugly Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isUgly(int num) {\n        while(num >= 2) {\n            if(num % 2 == 0) num /= 2;\n            else if(num % 3 == 0) num /= 3;\n            else if(num % 5 == 0) num /= 5;\n            else return false;\n        }\n        return num == 1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p263-ugly-number","published":1,"date":"2018-04-28T14:59:29.592Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwv005kqnn90n77pppd","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUgly</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num % <span class=\"number\">2</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num % <span class=\"number\">3</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num % <span class=\"number\">5</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">5</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUgly</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt;= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num % <span class=\"number\">2</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num % <span class=\"number\">3</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num % <span class=\"number\">5</span> == <span class=\"number\">0</span>) num /= <span class=\"number\">5</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"27. Remove Element","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int res = 0;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] != val) nums[res++] = nums[i];\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p27-remove-element.md","raw":"---\ntitle: 27. Remove Element\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int res = 0;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] != val) nums[res++] = nums[i];\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p27-remove-element","published":1,"date":"2018-04-28T14:59:29.126Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdwx005nqnn9if3coh4v","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] != val) nums[res++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] != val) nums[res++] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"278. First Bad Version","_content":"\n~~~cpp\n// Forward declaration of isBadVersion API.\nbool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while(left < right) {\n            int mid = left + (right - left) / 2;\n            if(isBadVersion(mid)) {\n                right = mid;\n            }\n            else {\n                left = ++mid;\n            }\n        }\n        return left;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p278-first-bad-version.md","raw":"---\ntitle: 278. First Bad Version\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n// Forward declaration of isBadVersion API.\nbool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while(left < right) {\n            int mid = left + (right - left) / 2;\n            if(isBadVersion(mid)) {\n                right = mid;\n            }\n            else {\n                left = ++mid;\n            }\n        }\n        return left;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p278-first-bad-version","published":1,"date":"2018-04-28T14:59:29.598Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdx1005rqnn90jv956w2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forward declaration of isBadVersion API.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> version)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isBadVersion(mid)) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = ++mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forward declaration of isBadVersion API.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> version)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isBadVersion(mid)) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = ++mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"283. Move Zeroes","_content":"\n~~~cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        for(int i = 0, j = 0; i < nums.size(); ++i) {\n            if(nums[i]) {\n                swap(nums[i], nums[j++]);\n            }\n        }\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p283-move-zeroes.md","raw":"---\ntitle: 283. Move Zeroes\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        for(int i = 0, j = 0; i < nums.size(); ++i) {\n            if(nums[i]) {\n                swap(nums[i], nums[j++]);\n            }\n        }\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p283-move-zeroes","published":1,"date":"2018-04-28T14:59:29.602Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdx3005uqnn9aefcxi3m","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]) &#123;</span><br><span class=\"line\">                swap(nums[i], nums[j++]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]) &#123;</span><br><span class=\"line\">                swap(nums[i], nums[j++]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"292. Nim Game","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool canWinNim(int n) {\n        return n % 4;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p292-nim-game.md","raw":"---\ntitle: 292. Nim Game\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool canWinNim(int n) {\n        return n % 4;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p292-nim-game","published":1,"date":"2018-04-28T14:59:29.606Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdx4005yqnn9i6y9q0n1","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n % <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canWinNim</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n % <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"28. Implement strStr()","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.empty()) return 0;\n        int m = haystack.size(), n = needle.size();\n        if(m < n)\n            return -1;\n        for(int i = 0; i < m-n; ++i) {\n            int j = 0;\n            for(j = 0; j < n; ++j) {\n                if(haystack[i+j] != needle[j]) break;\n            }\n            if(j == n) return i;\n        }\n        return -1;\n\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p28-implement-strstr().md","raw":"---\ntitle: 28. Implement strStr()\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.empty()) return 0;\n        int m = haystack.size(), n = needle.size();\n        if(m < n)\n            return -1;\n        for(int i = 0; i < m-n; ++i) {\n            int j = 0;\n            for(j = 0; j < n; ++j) {\n                if(haystack[i+j] != needle[j]) break;\n            }\n            if(j == n) return i;\n        }\n        return -1;\n\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p28-implement-strstr()","published":1,"date":"2018-04-28T14:59:29.136Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdx70061qnn9my0oyfg7","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"built_in\">string</span> haystack, <span class=\"built_in\">string</span> needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(needle.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = haystack.size(), n = needle.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m &lt; n)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m-n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(haystack[i+j] != needle[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j == n) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"built_in\">string</span> haystack, <span class=\"built_in\">string</span> needle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(needle.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = haystack.size(), n = needle.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m &lt; n)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m-n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(haystack[i+j] != needle[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j == n) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"310. Minimum Height Trees","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\n        if (n == 1) return {0};\n        vector<int> res;\n        vector<unordered_set<int>> adj(n);\n        for (auto edge : edges) {\n            adj[edge.first].insert(edge.second);\n            adj[edge.second].insert(edge.first);\n        }\n        queue<int> q;\n        for (int i = 0; i < n; ++i) {\n            if (adj[i].size() == 1) q.push(i);\n        }\n        while (n > 2) {\n            int size = q.size();\n            n -= size;\n            for (int i = 0; i < size; ++i) {\n                int t = q.front();\n                q.pop();\n                for (auto a : adj[t]) {\n                    adj[a].erase(t);\n                    if (adj[a].size() == 1) q.push(a);\n                }\n            }\n        }\n        while (!q.empty()) {\n            res.push_back(q.front());\n            q.pop();\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p310-minimum-height-trees.md","raw":"---\ntitle: 310. Minimum Height Trees\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {\n        if (n == 1) return {0};\n        vector<int> res;\n        vector<unordered_set<int>> adj(n);\n        for (auto edge : edges) {\n            adj[edge.first].insert(edge.second);\n            adj[edge.second].insert(edge.first);\n        }\n        queue<int> q;\n        for (int i = 0; i < n; ++i) {\n            if (adj[i].size() == 1) q.push(i);\n        }\n        while (n > 2) {\n            int size = q.size();\n            n -= size;\n            for (int i = 0; i < size; ++i) {\n                int t = q.front();\n                q.pop();\n                for (auto a : adj[t]) {\n                    adj[a].erase(t);\n                    if (adj[a].size() == 1) q.push(a);\n                }\n            }\n        }\n        while (!q.empty()) {\n            res.push_back(q.front());\n            q.pop();\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p310-minimum-height-trees","published":1,"date":"2018-04-28T14:59:29.610Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxa0065qnn9ufo2x0o1","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; findMinHeightTrees(<span class=\"keyword\">int</span> n, <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; adj(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> edge : edges) &#123;</span><br><span class=\"line\">            adj[edge.first].insert(edge.second);</span><br><span class=\"line\">            adj[edge.second].insert(edge.first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adj[i].size() == <span class=\"number\">1</span>) q.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = q.size();</span><br><span class=\"line\">            n -= size;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = q.front();</span><br><span class=\"line\">                q.pop();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> a : adj[t]) &#123;</span><br><span class=\"line\">                    adj[a].erase(t);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (adj[a].size() == <span class=\"number\">1</span>) q.push(a);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">            res.push_back(q.front());</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; findMinHeightTrees(<span class=\"keyword\">int</span> n, <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; adj(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> edge : edges) &#123;</span><br><span class=\"line\">            adj[edge.first].insert(edge.second);</span><br><span class=\"line\">            adj[edge.second].insert(edge.first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (adj[i].size() == <span class=\"number\">1</span>) q.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = q.size();</span><br><span class=\"line\">            n -= size;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> t = q.front();</span><br><span class=\"line\">                q.pop();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> a : adj[t]) &#123;</span><br><span class=\"line\">                    adj[a].erase(t);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (adj[a].size() == <span class=\"number\">1</span>) q.push(a);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">            res.push_back(q.front());</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"326. Power of Three","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        while(n && (n % 3 == 0)) {\n          n /= 3;\n        }\n        return n == 1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p326-power-of-three.md","raw":"---\ntitle: 326. Power of Three\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        while(n && (n % 3 == 0)) {\n          n /= 3;\n        }\n        return n == 1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p326-power-of-three","published":1,"date":"2018-04-28T14:59:29.613Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxd0068qnn9f2d43pms","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfThree</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &amp;&amp; (n % <span class=\"number\">3</span> == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">          n /= <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfThree</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &amp;&amp; (n % <span class=\"number\">3</span> == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">          n /= <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"338. Counting Bits","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> countBits(int num) {\n        vector<int> res;\n        for(int i = 0; i <= num; ++i) {\n            res.push_back(bitset<32>(i).count());\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p338-counting-bits.md","raw":"---\ntitle: 338. Counting Bits\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> countBits(int num) {\n        vector<int> res;\n        for(int i = 0; i <= num; ++i) {\n            res.push_back(bitset<32>(i).count());\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p338-counting-bits","published":1,"date":"2018-04-28T14:59:29.616Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxf006cqnn9pgr3oc72","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; countBits(<span class=\"keyword\">int</span> num) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= num; ++i) &#123;</span><br><span class=\"line\">            res.push_back(<span class=\"built_in\">bitset</span>&lt;<span class=\"number\">32</span>&gt;(i).count());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; countBits(<span class=\"keyword\">int</span> num) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= num; ++i) &#123;</span><br><span class=\"line\">            res.push_back(<span class=\"built_in\">bitset</span>&lt;<span class=\"number\">32</span>&gt;(i).count());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"34. Search for a Range","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> res;\n        int start = -1, end = -1;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] == target) {\n                start = i;\n                break;\n            }\n        }\n        for(int i = nums.size()-1; i >= 0 ; --i) {\n            if(nums[i] == target) {\n                end = i;\n                break;\n            }\n        }\n        res.push_back(start);\n        res.push_back(end);\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p34-search-for-a-range.md","raw":"---\ntitle: 34. Search for a Range\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> res;\n        int start = -1, end = -1;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] == target) {\n                start = i;\n                break;\n            }\n        }\n        for(int i = nums.size()-1; i >= 0 ; --i) {\n            if(nums[i] == target) {\n                end = i;\n                break;\n            }\n        }\n        res.push_back(start);\n        res.push_back(end);\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p34-search-for-a-range","published":1,"date":"2018-04-28T14:59:29.148Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxh006fqnn9nff7ryda","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; searchRange(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">-1</span>, end = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == target) &#123;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span> ; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == target) &#123;</span><br><span class=\"line\">                end = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push_back(start);</span><br><span class=\"line\">        res.push_back(end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; searchRange(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">-1</span>, end = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == target) &#123;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nums.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span> ; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == target) &#123;</span><br><span class=\"line\">                end = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push_back(start);</span><br><span class=\"line\">        res.push_back(end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"349. Intersection of Two Arrays","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        set<int> s(nums1.begin(), nums1.end()), res;\n        for(auto a : nums2) {\n            if(s.count(a)) res.insert(a);\n        }\n        return vector<int>(res.begin(), res.end());\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p349-intersection-of-two-arrays.md","raw":"---\ntitle: 349. Intersection of Two Arrays\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        set<int> s(nums1.begin(), nums1.end()), res;\n        for(auto a : nums2) {\n            if(s.count(a)) res.insert(a);\n        }\n        return vector<int>(res.begin(), res.end());\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p349-intersection-of-two-arrays","published":1,"date":"2018-04-28T14:59:29.630Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxi006iqnn91vh75xiw","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersection(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; s(nums1.begin(), nums1.end()), res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.count(a)) res.insert(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersection(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; s(nums1.begin(), nums1.end()), res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.count(a)) res.insert(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"344. Reverse String","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string reverseString(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            swap(s[left++], s[right--]);\n        }\n        return s;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p344-reverse-string.md","raw":"---\ntitle: 344. Reverse String\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string reverseString(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            swap(s[left++], s[right--]);\n        }\n        return s;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p344-reverse-string","published":1,"date":"2018-04-28T14:59:29.624Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxk006lqnn9zfbl2nsv","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            swap(s[left++], s[right--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseString</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            swap(s[left++], s[right--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"342. Power of Four","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfFour(int num) {\n        while(num && (num % 4 == 0)) {\n            num /= 4;\n        }\n        return num == 1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p342-power-of-four.md","raw":"---\ntitle: 342. Power of Four\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPowerOfFour(int num) {\n        while(num && (num % 4 == 0)) {\n            num /= 4;\n        }\n        return num == 1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p342-power-of-four","published":1,"date":"2018-04-28T14:59:29.619Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxl006oqnn9miq6asag","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &amp;&amp; (num % <span class=\"number\">4</span> == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            num /= <span class=\"number\">4</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &amp;&amp; (num % <span class=\"number\">4</span> == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            num /= <span class=\"number\">4</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num == <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"35. Search Insert Position","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] >= target) return i;\n        }\n        return nums.size();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p35-search-insert-position.md","raw":"---\ntitle: 35. Search Insert Position\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); ++i) {\n            if(nums[i] >= target) return i;\n        }\n        return nums.size();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p35-search-insert-position","published":1,"date":"2018-04-28T14:59:29.161Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxo006rqnn979iji7io","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt;= target) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt;= target) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"345. Reverse Vowels of a String","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            if(isVowel(s[left]) && isVowel(s[right])) {\n                swap(s[left++], s[right--]);\n            } else if(isVowel(s[left])) {\n                --right;\n            } else {\n                ++left;\n            }\n        }\n        return s;\n    }\n\n    bool isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p345-reverse-vowels-of-a-string.md","raw":"---\ntitle: 345. Reverse Vowels of a String\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        int left = 0, right = s.size() - 1;\n        while(left < right) {\n            if(isVowel(s[left]) && isVowel(s[right])) {\n                swap(s[left++], s[right--]);\n            } else if(isVowel(s[left])) {\n                --right;\n            } else {\n                ++left;\n            }\n        }\n        return s;\n    }\n\n    bool isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p345-reverse-vowels-of-a-string","published":1,"date":"2018-04-28T14:59:29.627Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxr006uqnn96gg1pt1o","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseVowels</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isVowel(s[left]) &amp;&amp; isVowel(s[right])) &#123;</span><br><span class=\"line\">                swap(s[left++], s[right--]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isVowel(s[left])) &#123;</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isVowel</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c == <span class=\"string\">'a'</span> || c == <span class=\"string\">'e'</span> || c == <span class=\"string\">'i'</span> || c == <span class=\"string\">'o'</span> || c == <span class=\"string\">'u'</span> ||</span><br><span class=\"line\">               c == <span class=\"string\">'A'</span> || c == <span class=\"string\">'E'</span> || c == <span class=\"string\">'I'</span> || c == <span class=\"string\">'O'</span> || c == <span class=\"string\">'U'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseVowels</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = s.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isVowel(s[left]) &amp;&amp; isVowel(s[right])) &#123;</span><br><span class=\"line\">                swap(s[left++], s[right--]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isVowel(s[left])) &#123;</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isVowel</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c == <span class=\"string\">'a'</span> || c == <span class=\"string\">'e'</span> || c == <span class=\"string\">'i'</span> || c == <span class=\"string\">'o'</span> || c == <span class=\"string\">'u'</span> ||</span><br><span class=\"line\">               c == <span class=\"string\">'A'</span> || c == <span class=\"string\">'E'</span> || c == <span class=\"string\">'I'</span> || c == <span class=\"string\">'O'</span> || c == <span class=\"string\">'U'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"350. Intersection of Two Arrays II","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int, int> m;\n        vector<int> res;\n        for(auto a : nums1) m[a]++;\n        for(auto a : nums2) {\n            if(m[a]-- > 0) res.push_back(a);\n        }\n        return res;\n\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p350-intersection-of-two-arrays-ii.md","raw":"---\ntitle: 350. Intersection of Two Arrays II\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int, int> m;\n        vector<int> res;\n        for(auto a : nums1) m[a]++;\n        for(auto a : nums2) {\n            if(m[a]-- > 0) res.push_back(a);\n        }\n        return res;\n\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p350-intersection-of-two-arrays-ii","published":1,"date":"2018-04-28T14:59:29.633Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxs006xqnn98cpnhukq","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums1) m[a]++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m[a]-- &gt; <span class=\"number\">0</span>) res.push_back(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersect(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums1) m[a]++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m[a]-- &gt; <span class=\"number\">0</span>) res.push_back(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"367. Valid Perfect Square","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        long left = 1, right = num;\n        while (left <= right) {\n            long mid = left + (right - left) / 2, t = mid * mid;\n            if (t == num) return true;\n            else if (t > num) right = mid - 1;\n            else {\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p367-valid-perfect-square.md","raw":"---\ntitle: 367. Valid Perfect Square\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        long left = 1, right = num;\n        while (left <= right) {\n            long mid = left + (right - left) / 2, t = mid * mid;\n            if (t == num) return true;\n            else if (t > num) right = mid - 1;\n            else {\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p367-valid-perfect-square","published":1,"date":"2018-04-28T14:59:29.638Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxv0070qnn9bj4ca7ar","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> left = <span class=\"number\">1</span>, right = num;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>, t = mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == num) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t &gt; num) right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPerfectSquare</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> left = <span class=\"number\">1</span>, right = num;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> mid = left + (right - left) / <span class=\"number\">2</span>, t = mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == num) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t &gt; num) right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"371. Sum Of Two Integers","_content":"~~~cpp\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        // 解决思路是使用 逻辑运算\n        if(b == 0) return a;\n        int sum = a ^ b;\n        int carry = (a & b) << 1;\n        return getSum(sum, carry);\n    }\n};\n\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        while (b) {\n          int carry = (a & b) << 1;\n          a = a ^ b;\n          b = carry;\n        }\n        return a;\n    }\n};\n\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        return b == 0 ? a : getSum(a ^ b, (a & b) << 1);\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p371-sum-of-two-integers.md","raw":"---\ntitle: 371. Sum Of Two Integers\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n~~~cpp\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        // 解决思路是使用 逻辑运算\n        if(b == 0) return a;\n        int sum = a ^ b;\n        int carry = (a & b) << 1;\n        return getSum(sum, carry);\n    }\n};\n\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        while (b) {\n          int carry = (a & b) << 1;\n          a = a ^ b;\n          b = carry;\n        }\n        return a;\n    }\n};\n\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        return b == 0 ? a : getSum(a ^ b, (a & b) << 1);\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p371-sum-of-two-integers","published":1,"date":"2018-04-28T14:59:29.642Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxx0073qnn9vc2nnnu5","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解决思路是使用 逻辑运算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a ^ b;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSum(sum, carry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (b) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> carry = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">          a = a ^ b;</span><br><span class=\"line\">          b = carry;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b == <span class=\"number\">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解决思路是使用 逻辑运算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a ^ b;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSum(sum, carry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (b) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> carry = (a &amp; b) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">          a = a ^ b;</span><br><span class=\"line\">          b = carry;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b == <span class=\"number\">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"374. Guess Number Higher or Lower","_content":"\n~~~cpp\n// Forward declaration of guess API.\n// @param num, your guess\n// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\nint guess(int num);\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        // if(guess(n) == 0) return n;\n        int left = 1, right = n;\n        while(left < right) {\n            int mid = left + (right - left) / 2;\n            int t = guess(mid);\n            if(t == 0) return mid;\n            else if(t == 1) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p374-guess-number-higher-or-lower.md","raw":"---\ntitle: 374. Guess Number Higher or Lower\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n// Forward declaration of guess API.\n// @param num, your guess\n// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\nint guess(int num);\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        // if(guess(n) == 0) return n;\n        int left = 1, right = n;\n        while(left < right) {\n            int mid = left + (right - left) / 2;\n            int t = guess(mid);\n            if(t == 0) return mid;\n            else if(t == 1) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p374-guess-number-higher-or-lower","published":1,"date":"2018-04-28T14:59:29.645Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxy0076qnn9u9xhizcb","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forward declaration of guess API.</span></span><br><span class=\"line\"><span class=\"comment\">// @param num, your guess</span></span><br><span class=\"line\"><span class=\"comment\">// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">guess</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">guessNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// if(guess(n) == 0) return n;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = guess(mid);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t == <span class=\"number\">1</span>) left = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Forward declaration of guess API.</span></span><br><span class=\"line\"><span class=\"comment\">// @param num, your guess</span></span><br><span class=\"line\"><span class=\"comment\">// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">guess</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">guessNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// if(guess(n) == 0) return n;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = guess(mid);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(t == <span class=\"number\">1</span>) left = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"383. Ransom Note","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map<char, int> m;\n        for(char c : magazine) ++m[c];\n        for(char c : ransomNote) {\n            if(--m[c] < 0) return false;\n        }\n        return true;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p383-ransom-note.md","raw":"---\ntitle: 383. Ransom Note\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map<char, int> m;\n        for(char c : magazine) ++m[c];\n        for(char c : ransomNote) {\n            if(--m[c] < 0) return false;\n        }\n        return true;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p383-ransom-note","published":1,"date":"2018-04-28T14:59:29.648Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdxz0079qnn9alyk5ae4","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canConstruct</span><span class=\"params\">(<span class=\"built_in\">string</span> ransomNote, <span class=\"built_in\">string</span> magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : magazine) ++m[c];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : ransomNote) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--m[c] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canConstruct</span><span class=\"params\">(<span class=\"built_in\">string</span> ransomNote, <span class=\"built_in\">string</span> magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : magazine) ++m[c];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : ransomNote) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--m[c] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"387. First Unique Character in a String","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<char, int> m;\n        for(char c : s) m[c]++;\n        for(int i = 0; i < s.size(); ++i) {\n            if((m[s[i]]) == 1) return i;\n        }\n        return -1;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p387-first-unique-character-in-a-string.md","raw":"---\ntitle: 387. First Unique Character in a String\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<char, int> m;\n        for(char c : s) m[c]++;\n        for(int i = 0; i < s.size(); ++i) {\n            if((m[s[i]]) == 1) return i;\n        }\n        return -1;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p387-first-unique-character-in-a-string","published":1,"date":"2018-04-28T14:59:29.651Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdy0007cqnn91vitcfht","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : s) m[c]++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((m[s[i]]) == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : s) m[c]++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((m[s[i]]) == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"401. Binary Watch","_content":"\n~~~cpp\n~~~","source":"_posts/Algorithm/LeetCode/p401-binary-watch.md","raw":"---\ntitle: 401. Binary Watch\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n~~~","slug":"Algorithm/LeetCode/p401-binary-watch","published":1,"date":"2018-04-28T14:59:29.659Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdy1007fqnn9k6693jva","content":"<pre><code class=\"cpp\">\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"cpp\">\n</code></pre>\n"},{"title":"389. Find the Difference","_content":"\n~~~cpp\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        unordered_map<char, int> m;\n        for (char c : s) ++m[c];\n        for (char c : t) {\n            if(--m[c] < 0) return c;\n        }\n        return 0;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p389-find-the-difference.md","raw":"---\ntitle: 389. Find the Difference\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        unordered_map<char, int> m;\n        for (char c : s) ++m[c];\n        for (char c : t) {\n            if(--m[c] < 0) return c;\n        }\n        return 0;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p389-find-the-difference","published":1,"date":"2018-04-28T14:59:29.656Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdy5007iqnn9x6gs0uwi","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) ++m[c];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--m[c] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findTheDifference</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"built_in\">string</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) ++m[c];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--m[c] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"404. Sum of Left Leaves","_content":"\n~~~cpp\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n   int sumOfLeftLeaves(TreeNode* root) {\n       if(!root) return 0;\n       if(root ->left && !root -> left ->left && !root ->left ->right) {\n           return root -> left -> val + sumOfLeftLeaves(root -> right);\n       }\n       return sumOfLeftLeaves(root -> left) + sumOfLeftLeaves(root -> right);\n   }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p404-sum-of-left-leaves.md","raw":"---\ntitle: 404. Sum of Left Leaves\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n   int sumOfLeftLeaves(TreeNode* root) {\n       if(!root) return 0;\n       if(root ->left && !root -> left ->left && !root ->left ->right) {\n           return root -> left -> val + sumOfLeftLeaves(root -> right);\n       }\n       return sumOfLeftLeaves(root -> left) + sumOfLeftLeaves(root -> right);\n   }\n};\n~~~","slug":"Algorithm/LeetCode/p404-sum-of-left-leaves","published":1,"date":"2018-04-28T14:59:29.663Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdy8007lqnn98esbxdvc","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\">* struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*     int val;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">* &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(root -&gt;left &amp;&amp; !root -&gt; left -&gt;left &amp;&amp; !root -&gt;left -&gt;right) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> root -&gt; left -&gt; val + sumOfLeftLeaves(root -&gt; right);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sumOfLeftLeaves(root -&gt; left) + sumOfLeftLeaves(root -&gt; right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\">* struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\">*     int val;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">* &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(root -&gt;left &amp;&amp; !root -&gt; left -&gt;left &amp;&amp; !root -&gt;left -&gt;right) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> root -&gt; left -&gt; val + sumOfLeftLeaves(root -&gt; right);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sumOfLeftLeaves(root -&gt; left) + sumOfLeftLeaves(root -&gt; right);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"414. Third Maximum Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        set<int> s;\n        for(int num : nums) {\n            s.insert(num);\n            if(s.size() > 3) {\n                s.erase(s.begin());\n            }\n        }\n        return s.size() == 3 ? *s.begin() : *s.rbegin();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p414-third-maximum-number.md","raw":"---\ntitle: 414. Third Maximum Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        set<int> s;\n        for(int num : nums) {\n            s.insert(num);\n            if(s.size() > 3) {\n                s.erase(s.begin());\n            }\n        }\n        return s.size() == 3 ? *s.begin() : *s.rbegin();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p414-third-maximum-number","published":1,"date":"2018-04-28T14:59:29.670Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdya007oqnn9iaynms3u","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">thirdMax</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            s.insert(num);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.size() &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                s.erase(s.begin());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.size() == <span class=\"number\">3</span> ? *s.begin() : *s.rbegin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">thirdMax</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            s.insert(num);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.size() &gt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                s.erase(s.begin());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.size() == <span class=\"number\">3</span> ? *s.begin() : *s.rbegin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"415. Add Strings","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string res = \"\";\n        int m = num1.size(), n = num2.size(), i = m - 1, j = n - 1, carry = 0;\n        while(i >= 0 || j >= 0) {\n            int a = i >= 0 ? num1[i--] - '0' : 0;\n            int b = j >= 0 ? num2[j--] - '0' : 0;\n            int sum = a + b + carry;\n            res.insert(res.begin(), sum % 10 + '0');\n            carry = sum / 10;\n        }\n        return carry ? \"1\" + res : res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p415-add-strings.md","raw":"---\ntitle: 415. Add Strings\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string res = \"\";\n        int m = num1.size(), n = num2.size(), i = m - 1, j = n - 1, carry = 0;\n        while(i >= 0 || j >= 0) {\n            int a = i >= 0 ? num1[i--] - '0' : 0;\n            int b = j >= 0 ? num2[j--] - '0' : 0;\n            int sum = a + b + carry;\n            res.insert(res.begin(), sum % 10 + '0');\n            carry = sum / 10;\n        }\n        return carry ? \"1\" + res : res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p415-add-strings","published":1,"date":"2018-04-28T14:59:29.674Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyd007rqnn9tihgrfs2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addStrings</span><span class=\"params\">(<span class=\"built_in\">string</span> num1, <span class=\"built_in\">string</span> num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = num1.size(), n = num2.size(), i = m - <span class=\"number\">1</span>, j = n - <span class=\"number\">1</span>, carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> || j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = i &gt;= <span class=\"number\">0</span> ? num1[i--] - <span class=\"string\">'0'</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = j &gt;= <span class=\"number\">0</span> ? num2[j--] - <span class=\"string\">'0'</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = a + b + carry;</span><br><span class=\"line\">            res.insert(res.begin(), sum % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> carry ? <span class=\"string\">\"1\"</span> + res : res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addStrings</span><span class=\"params\">(<span class=\"built_in\">string</span> num1, <span class=\"built_in\">string</span> num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = num1.size(), n = num2.size(), i = m - <span class=\"number\">1</span>, j = n - <span class=\"number\">1</span>, carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span> || j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = i &gt;= <span class=\"number\">0</span> ? num1[i--] - <span class=\"string\">'0'</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = j &gt;= <span class=\"number\">0</span> ? num2[j--] - <span class=\"string\">'0'</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = a + b + carry;</span><br><span class=\"line\">            res.insert(res.begin(), sum % <span class=\"number\">10</span> + <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> carry ? <span class=\"string\">\"1\"</span> + res : res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"412. Fizz Buzz","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<string> fizzBuzz(int n) {\n        vector<string> res;\n        for(int i = 1; i <= n; ++i) {\n            string tmp = \"\";\n            if(i % 3 == 0) tmp += \"Fizz\";\n            if(i % 5 == 0) tmp += \"Buzz\";\n\n            if(tmp.empty()) res.push_back(to_string(i));\n            else {\n                res.push_back(tmp);\n            }\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p412-fizz-buzz.md","raw":"---\ntitle: 412. Fizz Buzz\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<string> fizzBuzz(int n) {\n        vector<string> res;\n        for(int i = 1; i <= n; ++i) {\n            string tmp = \"\";\n            if(i % 3 == 0) tmp += \"Fizz\";\n            if(i % 5 == 0) tmp += \"Buzz\";\n\n            if(tmp.empty()) res.push_back(to_string(i));\n            else {\n                res.push_back(tmp);\n            }\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p412-fizz-buzz","published":1,"date":"2018-04-28T14:59:29.666Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdye007uqnn9sjzimgvf","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; fizzBuzz(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> tmp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) tmp += <span class=\"string\">\"Fizz\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % <span class=\"number\">5</span> == <span class=\"number\">0</span>) tmp += <span class=\"string\">\"Buzz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.empty()) res.push_back(to_string(i));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.push_back(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; fizzBuzz(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> tmp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>) tmp += <span class=\"string\">\"Fizz\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i % <span class=\"number\">5</span> == <span class=\"number\">0</span>) tmp += <span class=\"string\">\"Buzz\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp.empty()) res.push_back(to_string(i));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.push_back(tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"434. Number of Segments in a String","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int countSegments(string s) {\n        int res = 0, n = s.size();\n        for(int i = 0; i < n; ++i) {\n            if(s[i] == ' ') continue;\n            res++;\n            while(i < n && s[i] != ' ') i++;\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p434-number-of-segments-in-a-string.md","raw":"---\ntitle: 434. Number of Segments in a String\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int countSegments(string s) {\n        int res = 0, n = s.size();\n        for(int i = 0; i < n; ++i) {\n            if(s[i] == ' ') continue;\n            res++;\n            while(i < n && s[i] != ' ') i++;\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p434-number-of-segments-in-a-string","published":1,"date":"2018-04-28T14:59:29.677Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyg007xqnn9fj4b7zmt","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSegments</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; s[i] != <span class=\"string\">' '</span>) i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countSegments</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, n = s.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">' '</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; s[i] != <span class=\"string\">' '</span>) i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"441. Arranging Coins","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int arrangeCoins(int n) {\n        if(n == 1 || n == 0) return n;\n        int res = 1;\n        while(n > 0) {\n            n -= res;\n            if(n <= 0) break;\n            res++;\n        }\n        if(n == 0) return res;\n        if(n < 0) return --res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p441-arranging-coins.md","raw":"---\ntitle: 441. Arranging Coins\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int arrangeCoins(int n) {\n        if(n == 1 || n == 0) return n;\n        int res = 1;\n        while(n > 0) {\n            n -= res;\n            if(n <= 0) break;\n            res++;\n        }\n        if(n == 0) return res;\n        if(n < 0) return --res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p441-arranging-coins","published":1,"date":"2018-04-28T14:59:29.680Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyj0080qnn9miotpc6c","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrangeCoins</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n -= res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> --res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">arrangeCoins</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span> || n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n -= res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> --res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"461. Hamming Distance","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        return bitset<32>(x ^ y).count();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p461-hamming-distance.md","raw":"---\ntitle: 461. Hamming Distance\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        return bitset<32>(x ^ y).count();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p461-hamming-distance","published":1,"date":"2018-04-28T14:59:29.685Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyo0083qnn98fc9asz5","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">bitset</span>&lt;<span class=\"number\">32</span>&gt;(x ^ y).count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">bitset</span>&lt;<span class=\"number\">32</span>&gt;(x ^ y).count();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"475. Heaters","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        vector<int> res(houses.size(), INT_MAX);\n\n        // For each house, calculate distance to nearest RHS heater\n        for (int i = 0, h = 0; i < houses.size() && h < heaters.size(); ) {\n            if (houses[i] <= heaters[h]) { res[i] = heaters[h] - houses[i]; i++; }\n            else { h++; }\n        }\n\n        // For each house, calculate distance to nearest LHS heater\n        for (int i = houses.size()-1, h = heaters.size()-1; i >= 0 && h >= 0; ) {\n            if (houses[i] >= heaters[h]) { res[i] = min(res[i], houses[i] - heaters[h]); i--; }\n            else { h--; }\n        }\n\n        return *max_element(res.begin(), res.end());\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p475-heaters.md","raw":"---\ntitle: 475. Heaters\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        vector<int> res(houses.size(), INT_MAX);\n\n        // For each house, calculate distance to nearest RHS heater\n        for (int i = 0, h = 0; i < houses.size() && h < heaters.size(); ) {\n            if (houses[i] <= heaters[h]) { res[i] = heaters[h] - houses[i]; i++; }\n            else { h++; }\n        }\n\n        // For each house, calculate distance to nearest LHS heater\n        for (int i = houses.size()-1, h = heaters.size()-1; i >= 0 && h >= 0; ) {\n            if (houses[i] >= heaters[h]) { res[i] = min(res[i], houses[i] - heaters[h]); i--; }\n            else { h--; }\n        }\n\n        return *max_element(res.begin(), res.end());\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p475-heaters","published":1,"date":"2018-04-28T14:59:29.690Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyp0086qnn9tryha59e","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findRadius</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; houses, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class=\"line\">        sort(houses.begin(), houses.end());</span><br><span class=\"line\">        sort(heaters.begin(), heaters.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res(houses.size(), INT_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// For each house, calculate distance to nearest RHS heater</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, h = <span class=\"number\">0</span>; i &lt; houses.size() &amp;&amp; h &lt; heaters.size(); ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (houses[i] &lt;= heaters[h]) &#123; res[i] = heaters[h] - houses[i]; i++; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; h++; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// For each house, calculate distance to nearest LHS heater</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = houses.size()<span class=\"number\">-1</span>, h = heaters.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; h &gt;= <span class=\"number\">0</span>; ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (houses[i] &gt;= heaters[h]) &#123; res[i] = min(res[i], houses[i] - heaters[h]); i--; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; h--; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *max_element(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findRadius</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; houses, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class=\"line\">        sort(houses.begin(), houses.end());</span><br><span class=\"line\">        sort(heaters.begin(), heaters.end());</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res(houses.size(), INT_MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// For each house, calculate distance to nearest RHS heater</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, h = <span class=\"number\">0</span>; i &lt; houses.size() &amp;&amp; h &lt; heaters.size(); ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (houses[i] &lt;= heaters[h]) &#123; res[i] = heaters[h] - houses[i]; i++; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; h++; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// For each house, calculate distance to nearest LHS heater</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = houses.size()<span class=\"number\">-1</span>, h = heaters.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; h &gt;= <span class=\"number\">0</span>; ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (houses[i] &gt;= heaters[h]) &#123; res[i] = min(res[i], houses[i] - heaters[h]); i--; &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; h--; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *max_element(res.begin(), res.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"476. Number Complement","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int findComplement(int num) {\n        unsigned mask = ~0;\n        while(mask & num) mask <<= 1;\n        return ~mask & ~num;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p476-number-complement.md","raw":"---\ntitle: 476. Number Complement\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int findComplement(int num) {\n        unsigned mask = ~0;\n        while(mask & num) mask <<= 1;\n        return ~mask & ~num;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p476-number-complement","published":1,"date":"2018-04-28T14:59:29.693Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyr0089qnn939pn4j1k","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> mask = ~<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(mask &amp; num) mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ~mask &amp; ~num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> mask = ~<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(mask &amp; num) mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ~mask &amp; ~num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"50. Pow(x, n)","_content":"\n~~~cpp\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n == 0) return 1;\n        double t = myPow(x, n / 2);\n        if(n % 2)\n            return n < 0 ? 1 / x * t * t : x * t * t;\n        else\n            return t * t;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p50-pow(x,-n).md","raw":"---\ntitle: '50. Pow(x, n)'\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n == 0) return 1;\n        double t = myPow(x, n / 2);\n        if(n % 2)\n            return n < 0 ? 1 / x * t * t : x * t * t;\n        else\n            return t * t;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p50-pow(x,-n)","published":1,"date":"2018-04-28T14:59:29.173Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyu008cqnn9dgb31dsc","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> t = myPow(x, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n &lt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> / x * t * t : x * t * t;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> t * t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> t = myPow(x, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n % <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n &lt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> / x * t * t : x * t * t;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> t * t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"504. Base 7","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return \"0\";\n        bool flag = 0;\n        if(num < 0) {\n            flag = 1;\n            num = abs(num);\n        }\n        string res = \"\";\n        while(num > 0) {\n            int tmp = num % 7;\n            num /= 7;\n            res = to_string(tmp) + res;\n        }\n        if(flag)\n            return \"-\" + res;\n        else\n            return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p504-base-7.md","raw":"---\ntitle: 504. Base 7\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return \"0\";\n        bool flag = 0;\n        if(num < 0) {\n            flag = 1;\n            num = abs(num);\n        }\n        string res = \"\";\n        while(num > 0) {\n            int tmp = num % 7;\n            num /= 7;\n            res = to_string(tmp) + res;\n        }\n        if(flag)\n            return \"-\" + res;\n        else\n            return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p504-base-7","published":1,"date":"2018-04-28T14:59:29.696Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyw008fqnn93howmxp2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convertToBase7</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            num = <span class=\"built_in\">abs</span>(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = num % <span class=\"number\">7</span>;</span><br><span class=\"line\">            num /= <span class=\"number\">7</span>;</span><br><span class=\"line\">            res = to_string(tmp) + res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"-\"</span> + res;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convertToBase7</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">            num = <span class=\"built_in\">abs</span>(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = num % <span class=\"number\">7</span>;</span><br><span class=\"line\">            num /= <span class=\"number\">7</span>;</span><br><span class=\"line\">            res = to_string(tmp) + res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"-\"</span> + res;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"507. Perfect Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool checkPerfectNumber(int num) {\n        if(num == 1) return false;\n        int sum = 1;\n        for(int i = 2; i * i <= num; ++i) {\n            if(num % i == 0) sum += (i + num / i);\n            if(i * i == num) sum += i;\n            if(sum > num) return false;\n        }\n        return sum == num;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p507-perfect-number.md","raw":"---\ntitle: 507. Perfect Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool checkPerfectNumber(int num) {\n        if(num == 1) return false;\n        int sum = 1;\n        for(int i = 2; i * i <= num; ++i) {\n            if(num % i == 0) sum += (i + num / i);\n            if(i * i == num) sum += i;\n            if(sum > num) return false;\n        }\n        return sum == num;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p507-perfect-number","published":1,"date":"2018-04-28T14:59:29.700Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyx008iqnn9uhqboo6m","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkPerfectNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i * i &lt;= num; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num % i == <span class=\"number\">0</span>) sum += (i + num / i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i * i == num) sum += i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &gt; num) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum == num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkPerfectNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i * i &lt;= num; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num % i == <span class=\"number\">0</span>) sum += (i + num / i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i * i == num) sum += i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &gt; num) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum == num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"53. Maximum Subarray","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int res = INT_MIN, curSum = 0;\n        for(int num : nums) {\n            curSum = max(curSum + num, num);\n            res = max(res, curSum);\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p53-maximum-subarray.md","raw":"---\ntitle: 53. Maximum Subarray\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int res = INT_MIN, curSum = 0;\n        for(int num : nums) {\n            curSum = max(curSum + num, num);\n            res = max(res, curSum);\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p53-maximum-subarray","published":1,"date":"2018-04-28T14:59:29.184Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdyz008lqnn924uucj74","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = INT_MIN, curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            curSum = max(curSum + num, num);</span><br><span class=\"line\">            res = max(res, curSum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = INT_MIN, curSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            curSum = max(curSum + num, num);</span><br><span class=\"line\">            res = max(res, curSum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"541. Reverse String II","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string reverseStr(string s, int k) {\n        for(int left = 0; left < s.size(); left += 2 * k){\n            for(int i = left, j = min(left + k - 1, (int)s.size() - 1); i < j; i++, j--){\n                swap(s[i], s[j]);\n            }\n        }\n        return s;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p541-reverse-string-ii.md","raw":"---\ntitle: 541. Reverse String II\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string reverseStr(string s, int k) {\n        for(int left = 0; left < s.size(); left += 2 * k){\n            for(int i = left, j = min(left + k - 1, (int)s.size() - 1); i < j; i++, j--){\n                swap(s[i], s[j]);\n            }\n        }\n        return s;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p541-reverse-string-ii","published":1,"date":"2018-04-28T14:59:29.711Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdz0008oqnn9vqy4igcx","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseStr</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>; left &lt; s.size(); left += <span class=\"number\">2</span> * k)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = left, j = min(left + k - <span class=\"number\">1</span>, (<span class=\"keyword\">int</span>)s.size() - <span class=\"number\">1</span>); i &lt; j; i++, j--)&#123;</span><br><span class=\"line\">                swap(s[i], s[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reverseStr</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>; left &lt; s.size(); left += <span class=\"number\">2</span> * k)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = left, j = min(left + k - <span class=\"number\">1</span>, (<span class=\"keyword\">int</span>)s.size() - <span class=\"number\">1</span>); i &lt; j; i++, j--)&#123;</span><br><span class=\"line\">                swap(s[i], s[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"540. Single Element in a Sorted Array","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int res = 0;\n        for(int i = 0; i < nums.size(); ++i) {\n            res ^= nums[i];\n        }\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p540-single-element-in-a-sorted-array.md","raw":"---\ntitle: 540. Single Element in a Sorted Array\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int res = 0;\n        for(int i = 0; i < nums.size(); ++i) {\n            res ^= nums[i];\n        }\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p540-single-element-in-a-sorted-array","published":1,"date":"2018-04-28T14:59:29.707Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdz4008rqnn91dsbegz8","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            res ^= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            res ^= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"575. Distribute Candies","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int distributeCandies(vector<int>& candies) {\n        return min(unordered_set<int>(candies.begin(), candies.end()).size(), candies.size()/2);\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p575-distribute-candies.md","raw":"---\ntitle: 575. Distribute Candies\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int distributeCandies(vector<int>& candies) {\n        return min(unordered_set<int>(candies.begin(), candies.end()).size(), candies.size()/2);\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p575-distribute-candies","published":1,"date":"2018-04-28T14:59:29.715Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdz6008uqnn9yciubzi8","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">distributeCandies</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;(candies.begin(), candies.end()).size(), candies.size()/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">distributeCandies</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; candies)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(<span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt;(candies.begin(), candies.end()).size(), candies.size()/<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"535. Encode and Decode TinyURL","_content":"\n~~~cpp\n// funny joke\nclass Solution {\npublic:\n\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        return longUrl;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        return shortUrl;\n    }\n};\n\n// Your Solution object will be instantiated and called as such:\n// Solution solution;\n// solution.decode(solution.encode(url));\n~~~","source":"_posts/Algorithm/LeetCode/p535-encode-and-decode-tinyurl.md","raw":"---\ntitle: 535. Encode and Decode TinyURL\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n// funny joke\nclass Solution {\npublic:\n\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        return longUrl;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        return shortUrl;\n    }\n};\n\n// Your Solution object will be instantiated and called as such:\n// Solution solution;\n// solution.decode(solution.encode(url));\n~~~","slug":"Algorithm/LeetCode/p535-encode-and-decode-tinyurl","published":1,"date":"2018-04-28T14:59:29.704Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzc008xqnn95q4udwgi","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// funny joke</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Encodes a URL to a shortened URL.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">encode</span><span class=\"params\">(<span class=\"built_in\">string</span> longUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes a shortened URL to its original URL.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"built_in\">string</span> shortUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shortUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Your Solution object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\">// Solution solution;</span></span><br><span class=\"line\"><span class=\"comment\">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// funny joke</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Encodes a URL to a shortened URL.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">encode</span><span class=\"params\">(<span class=\"built_in\">string</span> longUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Decodes a shortened URL to its original URL.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"built_in\">string</span> shortUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> shortUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Your Solution object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\">// Solution solution;</span></span><br><span class=\"line\"><span class=\"comment\">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>"},{"title":"617. Merge Two Binary Trees","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if(!t1 || !t2) return t1 ? t1 : t2;\n\n        TreeNode* node = new TreeNode(t1->val + t2->val);\n        node->left = mergeTrees(t1->left, t2->left);\n        node->right = mergeTrees(t1->right, t2->right);\n        return node;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p617-merge-two-binary-trees.md","raw":"---\ntitle: 617. Merge Two Binary Trees\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if(!t1 || !t2) return t1 ? t1 : t2;\n\n        TreeNode* node = new TreeNode(t1->val + t2->val);\n        node->left = mergeTrees(t1->left, t2->left);\n        node->right = mergeTrees(t1->right, t2->right);\n        return node;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p617-merge-two-binary-trees","published":1,"date":"2018-04-28T14:59:29.718Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdze0090qnn9x6jod2iq","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!t1 || !t2) <span class=\"keyword\">return</span> t1 ? t1 : t2;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* node = <span class=\"keyword\">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class=\"line\">        node-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class=\"line\">        node-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!t1 || !t2) <span class=\"keyword\">return</span> t1 ? t1 : t2;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* node = <span class=\"keyword\">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class=\"line\">        node-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class=\"line\">        node-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"58. Length Of Last Word","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        if(s.empty()) return 0;\n        int right = s.size()-1;\n        int res = 0;\n        // 去掉尾部的空格\n        while(right > 0 && s[right] == ' ') right--;\n        while(right >= 0 && s[right] != ' ') {\n            --right;\n            res++;\n        }\n        return res;\n    }\n\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p58-length-of-last-word.md","raw":"---\ntitle: 58. Length Of Last Word\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        if(s.empty()) return 0;\n        int right = s.size()-1;\n        int res = 0;\n        // 去掉尾部的空格\n        while(right > 0 && s[right] == ' ') right--;\n        while(right >= 0 && s[right] != ' ') {\n            --right;\n            res++;\n        }\n        return res;\n    }\n\n};\n\n~~~","slug":"Algorithm/LeetCode/p58-length-of-last-word","published":1,"date":"2018-04-28T14:59:29.196Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzf0093qnn93e3w5ja0","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = s.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 去掉尾部的空格</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &gt; <span class=\"number\">0</span> &amp;&amp; s[right] == <span class=\"string\">' '</span>) right--;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; s[right] != <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = s.size()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 去掉尾部的空格</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &gt; <span class=\"number\">0</span> &amp;&amp; s[right] == <span class=\"string\">' '</span>) right--;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &gt;= <span class=\"number\">0</span> &amp;&amp; s[right] != <span class=\"string\">' '</span>) &#123;</span><br><span class=\"line\">            --right;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"654. Maximum Binary Tree","_content":"\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        vector<TreeNode*> v;\n        for(int num : nums) {\n            TreeNode *cur = new TreeNode(num);\n            while(!v.empty() && v.back()->val <num) {\n                cur->left = v.back();\n                v.pop_back();\n            }\n            if(!v.empty()) {\n                v.back()->right = cur;\n            }\n            v.push_back(cur);\n        }\n        return v.front();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p654-maximum-binary-tree.md","raw":"---\ntitle: 654. Maximum Binary Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        vector<TreeNode*> v;\n        for(int num : nums) {\n            TreeNode *cur = new TreeNode(num);\n            while(!v.empty() && v.back()->val <num) {\n                cur->left = v.back();\n                v.pop_back();\n            }\n            if(!v.empty()) {\n                v.back()->right = cur;\n            }\n            v.push_back(cur);\n        }\n        return v.front();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p654-maximum-binary-tree","published":1,"date":"2018-04-28T14:59:29.722Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzh0096qnn94dehcn80","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; v;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            TreeNode *cur = <span class=\"keyword\">new</span> TreeNode(num);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!v.empty() &amp;&amp; v.back()-&gt;val &lt;num) &#123;</span><br><span class=\"line\">                cur-&gt;left = v.back();</span><br><span class=\"line\">                v.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!v.empty()) &#123;</span><br><span class=\"line\">                v.back()-&gt;right = cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            v.push_back(cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;TreeNode*&gt; v;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            TreeNode *cur = <span class=\"keyword\">new</span> TreeNode(num);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!v.empty() &amp;&amp; v.back()-&gt;val &lt;num) &#123;</span><br><span class=\"line\">                cur-&gt;left = v.back();</span><br><span class=\"line\">                v.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!v.empty()) &#123;</span><br><span class=\"line\">                v.back()-&gt;right = cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            v.push_back(cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.front();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"657. Judge Route Circle","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int h = 0;\n        int v = 0;\n        for(char ch : moves) {\n            switch(ch) {\n                case 'U': v++; break;\n                case 'D': v--; break;\n                case 'L': h--; break;\n                case 'R': h++; break;\n            }\n        }\n        return v == 0 && h == 0;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p657-judge-route-circle.md","raw":"---\ntitle: 657. Judge Route Circle\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int h = 0;\n        int v = 0;\n        for(char ch : moves) {\n            switch(ch) {\n                case 'U': v++; break;\n                case 'D': v--; break;\n                case 'L': h--; break;\n                case 'R': h++; break;\n            }\n        }\n        return v == 0 && h == 0;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p657-judge-route-circle","published":1,"date":"2018-04-28T14:59:29.725Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzk0099qnn9nol0dtvb","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(<span class=\"built_in\">string</span> moves)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch : moves) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(ch) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'U'</span>: v++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>: v--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>: h--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'R'</span>: h++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v == <span class=\"number\">0</span> &amp;&amp; h == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judgeCircle</span><span class=\"params\">(<span class=\"built_in\">string</span> moves)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> ch : moves) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(ch) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'U'</span>: v++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'D'</span>: v--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'L'</span>: h--; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">'R'</span>: h++; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v == <span class=\"number\">0</span> &amp;&amp; h == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"66. Plus One","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for(int i = digits.size()-1; i >= 0; --i) {\n            if(digits[i] == 9) digits[i] = 0;\n            else {\n                digits[i] += 1;\n                return digits;\n            }\n        }\n        if(digits[0] == 0) digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p66-plus-one.md","raw":"---\ntitle: 66. Plus One\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for(int i = digits.size()-1; i >= 0; --i) {\n            if(digits[i] == 9) digits[i] = 0;\n            else {\n                digits[i] += 1;\n                return digits;\n            }\n        }\n        if(digits[0] == 0) digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p66-plus-one","published":1,"date":"2018-04-28T14:59:29.208Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzm009cqnn9kadgzfd2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; plusOne(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = digits.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(digits[i] == <span class=\"number\">9</span>) digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                digits[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) digits.insert(digits.begin(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; plusOne(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = digits.size()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(digits[i] == <span class=\"number\">9</span>) digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                digits[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(digits[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) digits.insert(digits.begin(), <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"669. Trim A Binary Search Tree","_content":"\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n // wrong solution, neet to fix\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if(!root) return root;\n\n        TreeNode* res;\n        if(root->val == L || root->val == R) {\n            res = root->val == L ? new TreeNode(L) : new TreeNode(R);\n            if(root->val == L ?) {\n                root->right = trimBST(root->right, L, R);\n            } else {\n                root->left = trimBST(root->left, L, R);\n            }\n    \n        } else if (root->val < L) {\n            trimBST(root->right, L, R);\n        } else if (root->val > R) {\n            trimBST(root->left, L, R);\n        }\n        return res;\n    }\n};\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n // 从原有的root上减去多余的节点，从而满足条件\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if(!root) return NULL;\n        // 首先寻找到L和R的起点，并让root指向其\n        while(root->val < L || root->val > R) {\n            root = root->val < L ? root->right : root-> left;\n        }\n        TreeNode* cur = root;\n        // 从root开始，减去多余的节点\n        while(cur) {\n            while(cur->left && cur->left->val < L) {\n                cur->left = cur->left->right;\n            }\n            cur = cur->left;\n        }\n\n        cur = root;\n        while(cur) {\n            while(cur->right && cur->right->val > R) {\n                cur->right = cur->right->left;\n            }\n            cur = cur->right;\n        }\n        return root;\n    }\n};\n\n~~~","source":"_posts/Algorithm/LeetCode/p669-trim-a-binary-search-tree.md","raw":"---\ntitle: 669. Trim A Binary Search Tree\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n\n~~~cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n // wrong solution, neet to fix\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if(!root) return root;\n\n        TreeNode* res;\n        if(root->val == L || root->val == R) {\n            res = root->val == L ? new TreeNode(L) : new TreeNode(R);\n            if(root->val == L ?) {\n                root->right = trimBST(root->right, L, R);\n            } else {\n                root->left = trimBST(root->left, L, R);\n            }\n    \n        } else if (root->val < L) {\n            trimBST(root->right, L, R);\n        } else if (root->val > R) {\n            trimBST(root->left, L, R);\n        }\n        return res;\n    }\n};\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n // 从原有的root上减去多余的节点，从而满足条件\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if(!root) return NULL;\n        // 首先寻找到L和R的起点，并让root指向其\n        while(root->val < L || root->val > R) {\n            root = root->val < L ? root->right : root-> left;\n        }\n        TreeNode* cur = root;\n        // 从root开始，减去多余的节点\n        while(cur) {\n            while(cur->left && cur->left->val < L) {\n                cur->left = cur->left->right;\n            }\n            cur = cur->left;\n        }\n\n        cur = root;\n        while(cur) {\n            while(cur->right && cur->right->val > R) {\n                cur->right = cur->right->left;\n            }\n            cur = cur->right;\n        }\n        return root;\n    }\n};\n\n~~~","slug":"Algorithm/LeetCode/p669-trim-a-binary-search-tree","published":1,"date":"2018-04-28T14:59:29.729Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzo009fqnn9o5h0trcv","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// wrong solution, neet to fix</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val == L || root-&gt;val == R) &#123;</span><br><span class=\"line\">            res = root-&gt;val == L ? <span class=\"keyword\">new</span> TreeNode(L) : <span class=\"keyword\">new</span> TreeNode(R);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;val == L ?) &#123;</span><br><span class=\"line\">                root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &lt; L) &#123;</span><br><span class=\"line\">            trimBST(root-&gt;right, L, R);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; R) &#123;</span><br><span class=\"line\">            trimBST(root-&gt;left, L, R);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 从原有的root上减去多余的节点，从而满足条件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 首先寻找到L和R的起点，并让root指向其</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;val &lt; L || root-&gt;val &gt; R) &#123;</span><br><span class=\"line\">            root = root-&gt;val &lt; L ? root-&gt;right : root-&gt; left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode* cur = root;</span><br><span class=\"line\">        <span class=\"comment\">// 从root开始，减去多余的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) &#123;</span><br><span class=\"line\">                cur-&gt;left = cur-&gt;left-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) &#123;</span><br><span class=\"line\">                cur-&gt;right = cur-&gt;right-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// wrong solution, neet to fix</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val == L || root-&gt;val == R) &#123;</span><br><span class=\"line\">            res = root-&gt;val == L ? <span class=\"keyword\">new</span> TreeNode(L) : <span class=\"keyword\">new</span> TreeNode(R);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;val == L ?) &#123;</span><br><span class=\"line\">                root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &lt; L) &#123;</span><br><span class=\"line\">            trimBST(root-&gt;right, L, R);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;val &gt; R) &#123;</span><br><span class=\"line\">            trimBST(root-&gt;left, L, R);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 从原有的root上减去多余的节点，从而满足条件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode* root, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 首先寻找到L和R的起点，并让root指向其</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(root-&gt;val &lt; L || root-&gt;val &gt; R) &#123;</span><br><span class=\"line\">            root = root-&gt;val &lt; L ? root-&gt;right : root-&gt; left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode* cur = root;</span><br><span class=\"line\">        <span class=\"comment\">// 从root开始，减去多余的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) &#123;</span><br><span class=\"line\">                cur-&gt;left = cur-&gt;left-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) &#123;</span><br><span class=\"line\">                cur-&gt;right = cur-&gt;right-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"67. Add Binary","_content":"\n~~~cpp\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int na = a.size();\n        int nb = b.size();\n        int n = max(na, nb);\n        bool carry = false;\n        if(na > nb) {\n            for(int i = 0; i < na - nb; ++i) b.insert(b.begin(), '0');\n        } else if(nb > na) {\n            for(int i = 0; i < nb - na; ++i) a.insert(a.begin(), '0');\n        }\n        for(int i = n - 1; i >= 0; --i) {\n            int tmp = 0;\n            if(carry) tmp = (a[i] - '0') + (b[i] - '0') + 1;\n            else tmp = (a[i] - '0') + (b[i] - '0');\n            if(tmp == 0) {\n                res.insert(res.begin(), '0');\n                carry = false;\n            }\n            if(tmp == 1) {\n                res.insert(res.begin(), '1');\n                carry = false;\n            }\n            if(tmp == 2) {\n                res.insert(res.begin(), '0');\n                carry = true;\n            }\n            if(tmp == 3) {\n                res.insert(res.begin(), '1');\n                carry = true;\n            }\n        }\n        if (carry) res.insert(res.begin(), '1');\n        return res;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p67-add-binary.md","raw":"---\ntitle: 67. Add Binary\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int na = a.size();\n        int nb = b.size();\n        int n = max(na, nb);\n        bool carry = false;\n        if(na > nb) {\n            for(int i = 0; i < na - nb; ++i) b.insert(b.begin(), '0');\n        } else if(nb > na) {\n            for(int i = 0; i < nb - na; ++i) a.insert(a.begin(), '0');\n        }\n        for(int i = n - 1; i >= 0; --i) {\n            int tmp = 0;\n            if(carry) tmp = (a[i] - '0') + (b[i] - '0') + 1;\n            else tmp = (a[i] - '0') + (b[i] - '0');\n            if(tmp == 0) {\n                res.insert(res.begin(), '0');\n                carry = false;\n            }\n            if(tmp == 1) {\n                res.insert(res.begin(), '1');\n                carry = false;\n            }\n            if(tmp == 2) {\n                res.insert(res.begin(), '0');\n                carry = true;\n            }\n            if(tmp == 3) {\n                res.insert(res.begin(), '1');\n                carry = true;\n            }\n        }\n        if (carry) res.insert(res.begin(), '1');\n        return res;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p67-add-binary","published":1,"date":"2018-04-28T14:59:29.223Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzq009iqnn9ozdr4ppt","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> a, <span class=\"built_in\">string</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> na = a.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nb = b.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = max(na, nb);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(na &gt; nb) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; na - nb; ++i) b.insert(b.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nb &gt; na) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nb - na; ++i) a.insert(a.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(carry) tmp = (a[i] - <span class=\"string\">'0'</span>) + (b[i] - <span class=\"string\">'0'</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> tmp = (a[i] - <span class=\"string\">'0'</span>) + (b[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry) res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">addBinary</span><span class=\"params\">(<span class=\"built_in\">string</span> a, <span class=\"built_in\">string</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> na = a.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nb = b.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = max(na, nb);</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(na &gt; nb) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; na - nb; ++i) b.insert(b.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nb &gt; na) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nb - na; ++i) a.insert(a.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(carry) tmp = (a[i] - <span class=\"string\">'0'</span>) + (b[i] - <span class=\"string\">'0'</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> tmp = (a[i] - <span class=\"string\">'0'</span>) + (b[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'0'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">                carry = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry) res.insert(res.begin(), <span class=\"string\">'1'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"69. Sqrt(x)","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long long left = 0, right = (x / 2) + 1;\n        while(left <= right) {\n            long long mid = (left + right) / 2;\n            long long sq = mid * mid;\n            if(sq == x) return mid;\n            else if (sq < x) left = mid + 1;\n            else right = mid - 1;\n        }\n        return right;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p69-sqrt(x).md","raw":"---\ntitle: 69. Sqrt(x)\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long long left = 0, right = (x / 2) + 1;\n        while(left <= right) {\n            long long mid = (left + right) / 2;\n            long long sq = mid * mid;\n            if(sq == x) return mid;\n            else if (sq < x) left = mid + 1;\n            else right = mid - 1;\n        }\n        return right;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p69-sqrt(x)","published":1,"date":"2018-04-28T14:59:29.236Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzs009lqnn90gvo1q6a","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> left = <span class=\"number\">0</span>, right = (x / <span class=\"number\">2</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sq = mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sq == x) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sq &lt; x) left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mySqrt</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> left = <span class=\"number\">0</span>, right = (x / <span class=\"number\">2</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sq = mid * mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sq == x) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sq &lt; x) left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"744. Find Smallest Letter Greater Than Target","_content":"\n~~~cpp\nclass Solution {\npublic:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        auto it = upper_bound(letters.begin(), letters.end(), target);\n        return it == letters.end() ? letters[0] : *it;\n\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p744-find-smallest-letter-greater-than-target.md","raw":"---\ntitle: 744. Find Smallest Letter Greater Than Target\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        auto it = upper_bound(letters.begin(), letters.end(), target);\n        return it == letters.end() ? letters[0] : *it;\n\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p744-find-smallest-letter-greater-than-target","published":1,"date":"2018-04-28T14:59:29.737Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzu009oqnn9plvot9xy","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">nextGreatestLetter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&amp; letters, <span class=\"keyword\">char</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = upper_bound(letters.begin(), letters.end(), target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it == letters.end() ? letters[<span class=\"number\">0</span>] : *it;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">nextGreatestLetter</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt;&amp; letters, <span class=\"keyword\">char</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = upper_bound(letters.begin(), letters.end(), target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it == letters.end() ? letters[<span class=\"number\">0</span>] : *it;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"7. Reverse Integer","_content":"\n\n\n~~~CPP\n// first the x is 32-bit integer\n// change x to char\n// pick the '+' '-' sign\n// use anothoer array to put the number\n// chane the number array to number, remove head zero\n\n/*\nSolution 1:\n首先将x转为正数处理\n根据循环取模，得到尾数\n将尾数以10为基数进行加乘\n得到结果\n*/\nclass Solution {\npublic:\n    int reverse(int x) {\n      long long res = 0;\n      bool isPositive = true;\n      // 将其转为正整数处理\n      if(x < 0) {\n        isPositive = false;\n        x *= -1;\n      }\n      while (x > 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n      }\n      if(res > INT_MAX) return 0;\n      if(isPositive) return res;\n      else return -res;\n    }\n};\n\n/*\nSolution 2：\n\n*/\nclass Solution {\npublic:\n  int reverse(int x) {\n    int res = 0;\n    while (x != 0) {\n      if(abs(res) > INT_MAX / 10) return 0; // 不可以更改为退出循环后判断res是否溢出，因为res为int类型\n      res = res * 10 + x % 10;\n      x /= 10;\n    }\n    return res;\n  }\n};\n\nclass Solution {\npublic:\n  int reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n      res = res * 10 + x % 10;\n      x /= 10;\n    }\n    return (res > INT_MAX || res < -INT_MAX) ? 0 : res;\n  }\n};\n\nclass Solution {\npublic:\n    int reverse(int x) {\n      int res = 0;\n      while (x != 0) {\n        int t = res * 10 + x % 10;\n        if(t / 10 != res) return 0; // 利用t发生溢出情况\n        res = t;\n        x /= 10;\n      }\n      return res;\n    }\n};\n~~~\n\n","source":"_posts/Algorithm/LeetCode/p7-reverse-integer.md","raw":"---\ntitle: 7. Reverse Integer\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n\n\n~~~CPP\n// first the x is 32-bit integer\n// change x to char\n// pick the '+' '-' sign\n// use anothoer array to put the number\n// chane the number array to number, remove head zero\n\n/*\nSolution 1:\n首先将x转为正数处理\n根据循环取模，得到尾数\n将尾数以10为基数进行加乘\n得到结果\n*/\nclass Solution {\npublic:\n    int reverse(int x) {\n      long long res = 0;\n      bool isPositive = true;\n      // 将其转为正整数处理\n      if(x < 0) {\n        isPositive = false;\n        x *= -1;\n      }\n      while (x > 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n      }\n      if(res > INT_MAX) return 0;\n      if(isPositive) return res;\n      else return -res;\n    }\n};\n\n/*\nSolution 2：\n\n*/\nclass Solution {\npublic:\n  int reverse(int x) {\n    int res = 0;\n    while (x != 0) {\n      if(abs(res) > INT_MAX / 10) return 0; // 不可以更改为退出循环后判断res是否溢出，因为res为int类型\n      res = res * 10 + x % 10;\n      x /= 10;\n    }\n    return res;\n  }\n};\n\nclass Solution {\npublic:\n  int reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n      res = res * 10 + x % 10;\n      x /= 10;\n    }\n    return (res > INT_MAX || res < -INT_MAX) ? 0 : res;\n  }\n};\n\nclass Solution {\npublic:\n    int reverse(int x) {\n      int res = 0;\n      while (x != 0) {\n        int t = res * 10 + x % 10;\n        if(t / 10 != res) return 0; // 利用t发生溢出情况\n        res = t;\n        x /= 10;\n      }\n      return res;\n    }\n};\n~~~\n\n","slug":"Algorithm/LeetCode/p7-reverse-integer","published":1,"date":"2018-04-28T14:59:29.747Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzv009rqnn92lum0cab","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// first the x is 32-bit integer</span></span><br><span class=\"line\"><span class=\"comment\">// change x to char</span></span><br><span class=\"line\"><span class=\"comment\">// pick the '+' '-' sign</span></span><br><span class=\"line\"><span class=\"comment\">// use anothoer array to put the number</span></span><br><span class=\"line\"><span class=\"comment\">// chane the number array to number, remove head zero</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Solution 1:</span></span><br><span class=\"line\"><span class=\"comment\">首先将x转为正数处理</span></span><br><span class=\"line\"><span class=\"comment\">根据循环取模，得到尾数</span></span><br><span class=\"line\"><span class=\"comment\">将尾数以10为基数进行加乘</span></span><br><span class=\"line\"><span class=\"comment\">得到结果</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">bool</span> isPositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 将其转为正整数处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        isPositive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(res &gt; INT_MAX) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isPositive) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Solution 2：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(res) &gt; INT_MAX / <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 不可以更改为退出循环后判断res是否溢出，因为res为int类型</span></span><br><span class=\"line\">      res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">      x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">      x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (res &gt; INT_MAX || res &lt; -INT_MAX) ? <span class=\"number\">0</span> : res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t / <span class=\"number\">10</span> != res) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 利用t发生溢出情况</span></span><br><span class=\"line\">        res = t;</span><br><span class=\"line\">        x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// first the x is 32-bit integer</span></span><br><span class=\"line\"><span class=\"comment\">// change x to char</span></span><br><span class=\"line\"><span class=\"comment\">// pick the '+' '-' sign</span></span><br><span class=\"line\"><span class=\"comment\">// use anothoer array to put the number</span></span><br><span class=\"line\"><span class=\"comment\">// chane the number array to number, remove head zero</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Solution 1:</span></span><br><span class=\"line\"><span class=\"comment\">首先将x转为正数处理</span></span><br><span class=\"line\"><span class=\"comment\">根据循环取模，得到尾数</span></span><br><span class=\"line\"><span class=\"comment\">将尾数以10为基数进行加乘</span></span><br><span class=\"line\"><span class=\"comment\">得到结果</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">bool</span> isPositive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 将其转为正整数处理</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        isPositive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        x *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(res &gt; INT_MAX) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isPositive) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Solution 2：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(res) &gt; INT_MAX / <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 不可以更改为退出循环后判断res是否溢出，因为res为int类型</span></span><br><span class=\"line\">      res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">      x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      res = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">      x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (res &gt; INT_MAX || res &lt; -INT_MAX) ? <span class=\"number\">0</span> : res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = res * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t / <span class=\"number\">10</span> != res) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 利用t发生溢出情况</span></span><br><span class=\"line\">        res = t;</span><br><span class=\"line\">        x /= <span class=\"number\">10</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"70. Climbing Stairs","_content":"\n~~~cpp\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n <= 1) return 1;\n        vector<int> dp(n);\n        dp[0] = 1; dp[1] = 2;\n        for(int i = 2; i < n; ++i) dp[i] = dp[i-1] + dp[i-2];\n        return dp.back();\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p70-climbing-stairs.md","raw":"---\ntitle: 70. Climbing Stairs\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n <= 1) return 1;\n        vector<int> dp(n);\n        dp[0] = 1; dp[1] = 2;\n        for(int i = 2; i < n; ++i) dp[i] = dp[i-1] + dp[i-2];\n        return dp.back();\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p70-climbing-stairs","published":1,"date":"2018-04-28T14:59:29.250Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3gdzy009uqnn9nuzd4uap","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(n);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; dp[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; ++i) dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp.back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; dp(n);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; dp[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; ++i) dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp.back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"771. Jewels and Stones","_content":"\n~~~cpp\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n    int res = 0;\n    set<char> setJ(J.begin(), J.end());\n    for(char s : S)\n      if(setJ.count(s))\n        res++;\n    return res;\n  }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p771-jewels-and-stones.md","raw":"---\ntitle: 771. Jewels and Stones\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n    int res = 0;\n    set<char> setJ(J.begin(), J.end());\n    for(char s : S)\n      if(setJ.count(s))\n        res++;\n    return res;\n  }\n};\n~~~","slug":"Algorithm/LeetCode/p771-jewels-and-stones","published":1,"date":"2018-04-28T14:59:29.740Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge01009xqnn9ex7q4h1g","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(<span class=\"built_in\">string</span> J, <span class=\"built_in\">string</span> S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">char</span>&gt; setJ(J.begin(), J.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> s : S)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(setJ.count(s))</span><br><span class=\"line\">        res++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numJewelsInStones</span><span class=\"params\">(<span class=\"built_in\">string</span> J, <span class=\"built_in\">string</span> S)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">char</span>&gt; setJ(J.begin(), J.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> s : S)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(setJ.count(s))</span><br><span class=\"line\">        res++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"728. Self Dividing Numbers","_content":"\n~~~cpp\nclass Solution {\npublic:\n    vector<int> selfDividingNumbers(int left, int right) {\n        vector<int> res;\n        for(int i = left; i <= right; ++i){\n            if(isSDN(i)){\n                res.push_back(i);\n            }\n        }\n        return res;\n    }\n\n    bool isSDN(int n){\n        if(n < 10) return true;\n        int p = n;\n        while(p > 0) {\n            int tmp = p % 10;\n            if(tmp == 0) return false;\n            if(n % tmp != 0) return false;\n            p /= 10;\n        }\n        return true;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p728-self-dividing-numbers.md","raw":"---\ntitle: 728. Self Dividing Numbers\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    vector<int> selfDividingNumbers(int left, int right) {\n        vector<int> res;\n        for(int i = left; i <= right; ++i){\n            if(isSDN(i)){\n                res.push_back(i);\n            }\n        }\n        return res;\n    }\n\n    bool isSDN(int n){\n        if(n < 10) return true;\n        int p = n;\n        while(p > 0) {\n            int tmp = p % 10;\n            if(tmp == 0) return false;\n            if(n % tmp != 0) return false;\n            p /= 10;\n        }\n        return true;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p728-self-dividing-numbers","published":1,"date":"2018-04-28T14:59:29.733Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge0400a0qnn9u3um90h2","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; selfDividingNumbers(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isSDN(i))&#123;</span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSDN</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = p % <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n % tmp != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            p /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; selfDividingNumbers(<span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isSDN(i))&#123;</span><br><span class=\"line\">                res.push_back(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isSDN</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = p % <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n % tmp != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            p /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"83. Remove Duplicates from Sorted List","_content":"\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head->next) return head;\n        ListNode *start = head;\n        while(start && start ->next) {\n            if(start -> val == start -> next -> val) {\n                ListNode *tmp = start -> next;\n                start -> next = start -> next -> next;\n                delete tmp;\n            } else start = start -> next;\n        }\n        return head;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p83-remove-duplicates-from-sorted-list.md","raw":"---\ntitle: 83. Remove Duplicates from Sorted List\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head->next) return head;\n        ListNode *start = head;\n        while(start && start ->next) {\n            if(start -> val == start -> next -> val) {\n                ListNode *tmp = start -> next;\n                start -> next = start -> next -> next;\n                delete tmp;\n            } else start = start -> next;\n        }\n        return head;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p83-remove-duplicates-from-sorted-list","published":1,"date":"2018-04-28T14:59:29.262Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge0600a3qnn9j6nh3d1j","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *start = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &amp;&amp; start -&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start -&gt; val == start -&gt; next -&gt; val) &#123;</span><br><span class=\"line\">                ListNode *tmp = start -&gt; next;</span><br><span class=\"line\">                start -&gt; next = start -&gt; next -&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> start = start -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode *start = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &amp;&amp; start -&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start -&gt; val == start -&gt; next -&gt; val) &#123;</span><br><span class=\"line\">                ListNode *tmp = start -&gt; next;</span><br><span class=\"line\">                start -&gt; next = start -&gt; next -&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> start = start -&gt; next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"88. Merge Sorted Array","_content":"\n~~~cpp\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        if(m <= 0 && n <= 0) return ;\n        int res[m + n];\n        int p = 0, q = 0;\n        for(int i = 0; i < m + n; ++i) {\n            if(p < m && q < n) {\n                if(nums1[p] < nums2[q]) {\n                    res[i] = nums1[p];\n                    p++;\n                } else {\n                    res[i] = nums2[q];\n                    q++;\n                }\n            } else if (p < m && q >= n) {\n                res[i] = nums1[p];\n                p++;\n            } else if(p >=m && q < n) {\n                res[i] = nums2[q];\n                q++;\n            } else return;\n        }\n        for (int i = 0; i < m + n; ++i) nums1[i] = res[i];\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p88-merge-sorted-array.md","raw":"---\ntitle: 88. Merge Sorted Array\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        if(m <= 0 && n <= 0) return ;\n        int res[m + n];\n        int p = 0, q = 0;\n        for(int i = 0; i < m + n; ++i) {\n            if(p < m && q < n) {\n                if(nums1[p] < nums2[q]) {\n                    res[i] = nums1[p];\n                    p++;\n                } else {\n                    res[i] = nums2[q];\n                    q++;\n                }\n            } else if (p < m && q >= n) {\n                res[i] = nums1[p];\n                p++;\n            } else if(p >=m && q < n) {\n                res[i] = nums2[q];\n                q++;\n            } else return;\n        }\n        for (int i = 0; i < m + n; ++i) nums1[i] = res[i];\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p88-merge-sorted-array","published":1,"date":"2018-04-28T14:59:29.274Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge0800a6qnn9lg8rdndx","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m &lt;= <span class=\"number\">0</span> &amp;&amp; n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res[m + n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p &lt; m &amp;&amp; q &lt; n) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums1[p] &lt; nums2[q]) &#123;</span><br><span class=\"line\">                    res[i] = nums1[p];</span><br><span class=\"line\">                    p++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res[i] = nums2[q];</span><br><span class=\"line\">                    q++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p &lt; m &amp;&amp; q &gt;= n) &#123;</span><br><span class=\"line\">                res[i] = nums1[p];</span><br><span class=\"line\">                p++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p &gt;=m &amp;&amp; q &lt; n) &#123;</span><br><span class=\"line\">                res[i] = nums2[q];</span><br><span class=\"line\">                q++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i) nums1[i] = res[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m &lt;= <span class=\"number\">0</span> &amp;&amp; n &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res[m + n];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p &lt; m &amp;&amp; q &lt; n) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums1[p] &lt; nums2[q]) &#123;</span><br><span class=\"line\">                    res[i] = nums1[p];</span><br><span class=\"line\">                    p++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res[i] = nums2[q];</span><br><span class=\"line\">                    q++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p &lt; m &amp;&amp; q &gt;= n) &#123;</span><br><span class=\"line\">                res[i] = nums1[p];</span><br><span class=\"line\">                p++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p &gt;=m &amp;&amp; q &lt; n) &#123;</span><br><span class=\"line\">                res[i] = nums2[q];</span><br><span class=\"line\">                q++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i) nums1[i] = res[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"9. Palindrome Number","_content":"\n~~~cpp\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n      if(x < 0) return false;\n      int div = 1;\n      while(x / div >= 10) div *= 10;\n      while(x > 0) {\n        int left = x / div;\n        int right = x % 10;\n        if(left != right) return false;\n        x = (x % div) / 10;\n        div /= 100;\n      }\n      return true;\n    }\n};\n~~~","source":"_posts/Algorithm/LeetCode/p9-palindrome-number.md","raw":"---\ntitle: 9. Palindrome Number\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n---\n\n~~~cpp\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n      if(x < 0) return false;\n      int div = 1;\n      while(x / div >= 10) div *= 10;\n      while(x > 0) {\n        int left = x / div;\n        int right = x % 10;\n        if(left != right) return false;\n        x = (x % div) / 10;\n        div /= 100;\n      }\n      return true;\n    }\n};\n~~~","slug":"Algorithm/LeetCode/p9-palindrome-number","published":1,"date":"2018-04-28T14:59:29.751Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge0a00a9qnn9ujsvo7hk","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> div = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(x / div &gt;= <span class=\"number\">10</span>) div *= <span class=\"number\">10</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = x / div;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != right) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        x = (x % div) / <span class=\"number\">10</span>;</span><br><span class=\"line\">        div /= <span class=\"number\">100</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> div = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(x / div &gt;= <span class=\"number\">10</span>) div *= <span class=\"number\">10</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = x / div;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = x % <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != right) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        x = (x % div) / <span class=\"number\">10</span>;</span><br><span class=\"line\">        div /= <span class=\"number\">100</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"《深入理解JVM》函数调用","_content":"\n<!-- toc -->\n\n## **C语言函数调用实现**\n\n\n### 通过一个简单的C语言程序分析\n\n~~~c\n#include <stdio.h>\n\nint add();\n\nint main(int argc, char const *argv[])\n{\n    int c = add();\n    printf(\"%d\", c);\n    return 0;\n}\n\nint add() {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序：\n\n~~~asm\n\t.file\t\".\\\\sampleAdd.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"%d\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB13:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE13:\n\t.size\tmain, .-main\n\t.globl\tadd\n\t.type\tadd, @function\nadd:\n.LFB14:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE14:\n\t.size\tadd, .-add\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n~~~\n\n去除宏定义，保留主要指令如下：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n汇编程序有两个标号`main`, `add`。这不是巧合，而是编译器处理的结果，**编译器会把函数名处理成汇编程序中的标号**。 有了标号，汇编程序就能执行函数调用，即call指令，有一条`call and`指令，就是汇编中执行函数调用的指令。\n\n接下来逐段分析：\n\n~~~asm\n\t# 保存调用者栈基地址，并为main()函数分配新栈空间\n\tpushq\t%rbp\t\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\t# 分配新栈，一共32字节\n~~~\n\n在`mian`，`add`代码段的开始都包含这3条指令，add代码段第3行是`movl\t$3, -4(%rbp)`该指令与`mian`代码段的`subq\t$32, %rsp`作用是相同的——分配栈空间。\n\n这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。\n\n`main()` 函数的方法栈内存布局如下图所示：\n\n// 这里需要插入一张图片\n\n\n\n### 带入参的C程序\n\n~~~c\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(int argc, char const *argv[])\n{\n    int a = 5, b = 3;\n    int c = add(a, b);\n    return 0;\n}\n\nint add(int a, int b) {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序(**去除宏定义，保留主要指令**)：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$5, -12(%rbp)\n\tmovl\t$3, -8(%rbp)\n\tmovl\t-8(%rbp), %edx\n\tmovl\t-12(%rbp), %eax\n\tmovl\t%edx, %esi\n\tmovl\t%eax, %edi\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t%edi, -20(%rbp)\n\tmovl\t%esi, -24(%rbp)\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n## C语言函数的调用机制\n\n1. 压栈\nmain函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。\n2. 参数传递顺序\nLinux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈\n3. 读取入参\n读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)......\n\n\n## 真实物理机器上执行函数调用的步骤：\n\n1. 保存调用者栈基地址，当前IP寄存器入栈\n2. 调用函数时，在x86平台参数从右到左依次入栈\n3. 一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小\n4. 被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数\n5. 被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值\n\n\n\n## 补充（关于寄存器）\n\n- %rax 作为函数返回值使用。\n- %rsp 栈指针寄存器，指向栈顶\n- %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。\n- %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改\n- %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n\n\n## Reference\n\n- [X86-64寄存器和栈帧](http://ju.outofmemory.cn/entry/769)\n\n- 揭秘Java虚拟机 \n","source":"_posts/Java/JVM/implement-function-call-in-c.md","raw":"---\ntitle: 《深入理解JVM》函数调用\ncategories:\n  - Java\n  - JVM\ntags:\n  - jvm\n---\n\n<!-- toc -->\n\n## **C语言函数调用实现**\n\n\n### 通过一个简单的C语言程序分析\n\n~~~c\n#include <stdio.h>\n\nint add();\n\nint main(int argc, char const *argv[])\n{\n    int c = add();\n    printf(\"%d\", c);\n    return 0;\n}\n\nint add() {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序：\n\n~~~asm\n\t.file\t\".\\\\sampleAdd.c\"\n\t.section\t.rodata\n.LC0:\n\t.string\t\"%d\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB13:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE13:\n\t.size\tmain, .-main\n\t.globl\tadd\n\t.type\tadd, @function\nadd:\n.LFB14:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE14:\n\t.size\tadd, .-add\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n\n~~~\n\n去除宏定义，保留主要指令如下：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$0, %eax\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tmovl\t%eax, %esi\n\tmovl\t$.LC0, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n汇编程序有两个标号`main`, `add`。这不是巧合，而是编译器处理的结果，**编译器会把函数名处理成汇编程序中的标号**。 有了标号，汇编程序就能执行函数调用，即call指令，有一条`call and`指令，就是汇编中执行函数调用的指令。\n\n接下来逐段分析：\n\n~~~asm\n\t# 保存调用者栈基地址，并为main()函数分配新栈空间\n\tpushq\t%rbp\t\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\t# 分配新栈，一共32字节\n~~~\n\n在`mian`，`add`代码段的开始都包含这3条指令，add代码段第3行是`movl\t$3, -4(%rbp)`该指令与`mian`代码段的`subq\t$32, %rsp`作用是相同的——分配栈空间。\n\n这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。\n\n`main()` 函数的方法栈内存布局如下图所示：\n\n// 这里需要插入一张图片\n\n\n\n### 带入参的C程序\n\n~~~c\n#include <stdio.h>\n\nint add(int a, int b);\n\nint main(int argc, char const *argv[])\n{\n    int a = 5, b = 3;\n    int c = add(a, b);\n    return 0;\n}\n\nint add(int a, int b) {\n    int z = 1 + 2;\n    return z;\n}\n\n~~~\n\n将这段C程序编译成汇编程序(**去除宏定义，保留主要指令**)：\n\n~~~asm\nmain:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tsubq\t$32, %rsp\n\tmovl\t%edi, -20(%rbp)\n\tmovq\t%rsi, -32(%rbp)\n\tmovl\t$5, -12(%rbp)\n\tmovl\t$3, -8(%rbp)\n\tmovl\t-8(%rbp), %edx\n\tmovl\t-12(%rbp), %eax\n\tmovl\t%edx, %esi\n\tmovl\t%eax, %edi\n\tcall\tadd\n\tmovl\t%eax, -4(%rbp)\n\tmovl\t$0, %eax\n\tleave\n\tret\nadd:\n\tpushq\t%rbp\n\tmovq\t%rsp, %rbp\n\tmovl\t%edi, -20(%rbp)\n\tmovl\t%esi, -24(%rbp)\n\tmovl\t$3, -4(%rbp)\n\tmovl\t-4(%rbp), %eax\n\tpopq\t%rbp\n\tret\n~~~\n\n## C语言函数的调用机制\n\n1. 压栈\nmain函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。\n2. 参数传递顺序\nLinux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈\n3. 读取入参\n读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)......\n\n\n## 真实物理机器上执行函数调用的步骤：\n\n1. 保存调用者栈基地址，当前IP寄存器入栈\n2. 调用函数时，在x86平台参数从右到左依次入栈\n3. 一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小\n4. 被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数\n5. 被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值\n\n\n\n## 补充（关于寄存器）\n\n- %rax 作为函数返回值使用。\n- %rsp 栈指针寄存器，指向栈顶\n- %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。\n- %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改\n- %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值\n\n\n\n## Reference\n\n- [X86-64寄存器和栈帧](http://ju.outofmemory.cn/entry/769)\n\n- 揭秘Java虚拟机 \n","slug":"Java/JVM/implement-function-call-in-c","published":1,"date":"2019-01-16T07:56:22.338Z","updated":"2019-03-23T03:37:28.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge0c00acqnn9nmzaaty3","content":"<!-- toc -->\n<h2 id=\"C语言函数调用实现\"><a href=\"#C语言函数调用实现\" class=\"headerlink\" title=\"C语言函数调用实现\"></a><strong>C语言函数调用实现</strong></h2><h3 id=\"通过一个简单的C语言程序分析\"><a href=\"#通过一个简单的C语言程序分析\" class=\"headerlink\" title=\"通过一个简单的C语言程序分析\"></a>通过一个简单的C语言程序分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.file\t&quot;.\\\\sampleAdd.c&quot;</span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string\t&quot;%d&quot;</span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB13:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE13:</span><br><span class=\"line\">\t.size\tmain, .-main</span><br><span class=\"line\">\t.globl\tadd</span><br><span class=\"line\">\t.type\tadd, @function</span><br><span class=\"line\">add:</span><br><span class=\"line\">.LFB14:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE14:</span><br><span class=\"line\">\t.size\tadd, .-add</span><br><span class=\"line\">\t.ident\t&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609&quot;</span><br><span class=\"line\">\t.section\t.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>去除宏定义，保留主要指令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>汇编程序有两个标号<code>main</code>, <code>add</code>。这不是巧合，而是编译器处理的结果，<strong>编译器会把函数名处理成汇编程序中的标号</strong>。 有了标号，汇编程序就能执行函数调用，即call指令，有一条<code>call and</code>指令，就是汇编中执行函数调用的指令。</p>\n<p>接下来逐段分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 保存调用者栈基地址，并为main()函数分配新栈空间</span><br><span class=\"line\">pushq\t%rbp\t</span><br><span class=\"line\">movq\t%rsp, %rbp</span><br><span class=\"line\">subq\t$32, %rsp\t# 分配新栈，一共32字节</span><br></pre></td></tr></table></figure>\n<p>在<code>mian</code>，<code>add</code>代码段的开始都包含这3条指令，add代码段第3行是<code>movl    $3, -4(%rbp)</code>该指令与<code>mian</code>代码段的<code>subq    $32, %rsp</code>作用是相同的——分配栈空间。</p>\n<p>这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。</p>\n<p><code>main()</code> 函数的方法栈内存布局如下图所示：</p>\n<p>// 这里需要插入一张图片</p>\n<h3 id=\"带入参的C程序\"><a href=\"#带入参的C程序\" class=\"headerlink\" title=\"带入参的C程序\"></a>带入参的C程序</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序(<strong>去除宏定义，保留主要指令</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$5, -12(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -8(%rbp)</span><br><span class=\"line\">\tmovl\t-8(%rbp), %edx</span><br><span class=\"line\">\tmovl\t-12(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%edx, %esi</span><br><span class=\"line\">\tmovl\t%eax, %edi</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovl\t%esi, -24(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<h2 id=\"C语言函数的调用机制\"><a href=\"#C语言函数的调用机制\" class=\"headerlink\" title=\"C语言函数的调用机制\"></a>C语言函数的调用机制</h2><ol>\n<li>压栈<br>main函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。</li>\n<li>参数传递顺序<br>Linux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈</li>\n<li>读取入参<br>读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)……</li>\n</ol>\n<h2 id=\"真实物理机器上执行函数调用的步骤：\"><a href=\"#真实物理机器上执行函数调用的步骤：\" class=\"headerlink\" title=\"真实物理机器上执行函数调用的步骤：\"></a>真实物理机器上执行函数调用的步骤：</h2><ol>\n<li>保存调用者栈基地址，当前IP寄存器入栈</li>\n<li>调用函数时，在x86平台参数从右到左依次入栈</li>\n<li>一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小</li>\n<li>被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数</li>\n<li>被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值</li>\n</ol>\n<h2 id=\"补充（关于寄存器）\"><a href=\"#补充（关于寄存器）\" class=\"headerlink\" title=\"补充（关于寄存器）\"></a>补充（关于寄存器）</h2><ul>\n<li>%rax 作为函数返回值使用。</li>\n<li>%rsp 栈指针寄存器，指向栈顶</li>\n<li>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</li>\n<li>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>\n<li>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><p><a href=\"http://ju.outofmemory.cn/entry/769\" target=\"_blank\" rel=\"noopener\">X86-64寄存器和栈帧</a></p>\n</li>\n<li><p>揭秘Java虚拟机 </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<!-- toc -->\n<h2 id=\"C语言函数调用实现\"><a href=\"#C语言函数调用实现\" class=\"headerlink\" title=\"C语言函数调用实现\"></a><strong>C语言函数调用实现</strong></h2><h3 id=\"通过一个简单的C语言程序分析\"><a href=\"#通过一个简单的C语言程序分析\" class=\"headerlink\" title=\"通过一个简单的C语言程序分析\"></a>通过一个简单的C语言程序分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.file\t&quot;.\\\\sampleAdd.c&quot;</span><br><span class=\"line\">\t.section\t.rodata</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string\t&quot;%d&quot;</span><br><span class=\"line\">\t.text</span><br><span class=\"line\">\t.globl\tmain</span><br><span class=\"line\">\t.type\tmain, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB13:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE13:</span><br><span class=\"line\">\t.size\tmain, .-main</span><br><span class=\"line\">\t.globl\tadd</span><br><span class=\"line\">\t.type\tadd, @function</span><br><span class=\"line\">add:</span><br><span class=\"line\">.LFB14:</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset 6, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register 6</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa 7, 8</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">.LFE14:</span><br><span class=\"line\">\t.size\tadd, .-add</span><br><span class=\"line\">\t.ident\t&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609&quot;</span><br><span class=\"line\">\t.section\t.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>去除宏定义，保留主要指令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%eax, %esi</span><br><span class=\"line\">\tmovl\t$.LC0, %edi</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tcall\tprintf</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>汇编程序有两个标号<code>main</code>, <code>add</code>。这不是巧合，而是编译器处理的结果，<strong>编译器会把函数名处理成汇编程序中的标号</strong>。 有了标号，汇编程序就能执行函数调用，即call指令，有一条<code>call and</code>指令，就是汇编中执行函数调用的指令。</p>\n<p>接下来逐段分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 保存调用者栈基地址，并为main()函数分配新栈空间</span><br><span class=\"line\">pushq\t%rbp\t</span><br><span class=\"line\">movq\t%rsp, %rbp</span><br><span class=\"line\">subq\t$32, %rsp\t# 分配新栈，一共32字节</span><br></pre></td></tr></table></figure>\n<p>在<code>mian</code>，<code>add</code>代码段的开始都包含这3条指令，add代码段第3行是<code>movl    $3, -4(%rbp)</code>该指令与<code>mian</code>代码段的<code>subq    $32, %rsp</code>作用是相同的——分配栈空间。</p>\n<p>这3条指令的作用为：保存段调用者基址，为新方法分配方法栈。这几乎是汇编程序执行方法调用的标准定式。</p>\n<p><code>main()</code> 函数的方法栈内存布局如下图所示：</p>\n<p>// 这里需要插入一张图片</p>\n<h3 id=\"带入参的C程序\"><a href=\"#带入参的C程序\" class=\"headerlink\" title=\"带入参的C程序\"></a>带入参的C程序</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>, b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = add(a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将这段C程序编译成汇编程序(<strong>去除宏定义，保留主要指令</strong>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tsubq\t$32, %rsp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovq\t%rsi, -32(%rbp)</span><br><span class=\"line\">\tmovl\t$5, -12(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -8(%rbp)</span><br><span class=\"line\">\tmovl\t-8(%rbp), %edx</span><br><span class=\"line\">\tmovl\t-12(%rbp), %eax</span><br><span class=\"line\">\tmovl\t%edx, %esi</span><br><span class=\"line\">\tmovl\t%eax, %edi</span><br><span class=\"line\">\tcall\tadd</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t$0, %eax</span><br><span class=\"line\">\tleave</span><br><span class=\"line\">\tret</span><br><span class=\"line\">add:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\tmovl\t%edi, -20(%rbp)</span><br><span class=\"line\">\tmovl\t%esi, -24(%rbp)</span><br><span class=\"line\">\tmovl\t$3, -4(%rbp)</span><br><span class=\"line\">\tmovl\t-4(%rbp), %eax</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<h2 id=\"C语言函数的调用机制\"><a href=\"#C语言函数的调用机制\" class=\"headerlink\" title=\"C语言函数的调用机制\"></a>C语言函数的调用机制</h2><ol>\n<li>压栈<br>main函数调用add()函数之前，会将两个入参压栈（压入调用者的栈），压栈之后add()就可以获取这两个入参。</li>\n<li>参数传递顺序<br>Linux平台，调用者函数向被调用者函数传递参数，采用逆向顺序压栈，即最后一个参数第一个压栈，第一个参数最后压栈</li>\n<li>读取入参<br>读取入参的方式是：通过add()函数的栈基地址rbp的相对地址，从main()函数中读取，最后一位入参在8(%rbp)，依次12(%rbp)……</li>\n</ol>\n<h2 id=\"真实物理机器上执行函数调用的步骤：\"><a href=\"#真实物理机器上执行函数调用的步骤：\" class=\"headerlink\" title=\"真实物理机器上执行函数调用的步骤：\"></a>真实物理机器上执行函数调用的步骤：</h2><ol>\n<li>保存调用者栈基地址，当前IP寄存器入栈</li>\n<li>调用函数时，在x86平台参数从右到左依次入栈</li>\n<li>一个方法所分配的栈空间大小，取决于方法内部局部变量空间、为被调用者所传递的入参大小</li>\n<li>被调用者在接收入参时，从8(%rbp)处开始，往上逐个获取参数</li>\n<li>被调用者将返回结果保存在eax寄存器中，调用者从该寄存器取值</li>\n</ol>\n<h2 id=\"补充（关于寄存器）\"><a href=\"#补充（关于寄存器）\" class=\"headerlink\" title=\"补充（关于寄存器）\"></a>补充（关于寄存器）</h2><ul>\n<li>%rax 作为函数返回值使用。</li>\n<li>%rsp 栈指针寄存器，指向栈顶</li>\n<li>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。</li>\n<li>%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>\n<li>%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><p><a href=\"http://ju.outofmemory.cn/entry/769\" target=\"_blank\" rel=\"noopener\">X86-64寄存器和栈帧</a></p>\n</li>\n<li><p>揭秘Java虚拟机 </p>\n</li>\n</ul>\n"},{"title":"平衡二叉树（AVLTree）封装+模板实现","_content":"\n## 简介\n\n[平衡树（AVLTree）](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n\n> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**AVL树**是最先发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)都是![O(\\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。增加和删除可能需要通过一次或多次[树旋转](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC)来重新平衡这个树。AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA)和[E. M. Landis](https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1)，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n>\n> 节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”**二叉搜索树**，平衡条件确保整棵树的深度为O(log n)。\n\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。**查找、插入和删除在平均和最坏情况下都是 O(log n)**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。\n\nAVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。\n\n\n\n## AVL旋转\n\nAVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。\n\n在理解AVL旋转之前，首先得知道以下几个概念： \n\n1. AVL 树节点的插入总是在叶子节点。 \n2. AVL 树在插入节点之前总是满足平衡条件的。 \n1. 插入新节点后有可能满足平衡条件也有可能不满足。 \n4. 当不满足平衡条件后，我们就需要对新的树进行旋转。\n\n\n旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：\n\n> 假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。\n\n基于这个X节点，考虑一件事情： \n这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：\n\n> X的左孩子节点的左子树上**(left-left)** \n> X的右孩子节点的右子树上**(right-right)** \n> X的左孩子节点的右子树上**(left-right)** \n> X的右孩子节点的左子树上**(right-left)**\n\n根据上述情况就延生出了4种旋转： \n**1.left-left Rotation** \n**2.right-right Rotation** \n**3.left-right Rotation** \n**4.right-left Rotation**\n\n前两种属于单旋转，后两种属于双旋转，**双旋转的操作可以由两次单旋转组成。**\n\nPS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。\n\n[![avl旋转四种情况](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)\n\n图片来自 [C小加的博客](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n1. 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。\n2. 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。\n3. 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。\n4. 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。\n\n从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。\n\n那么为什么需要双旋转呢？\n\n这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。\n\n而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。\n\n// 这里的描述太那啥了，得搞点图说明下\n\n\n\n## AVL-Tree实现\n\nAVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。\n\n节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： \n\n1. 每次都计算一次（递归求深度）。 \n2. 将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。\n\n本文采取的是第一种方式，关于两种方式利弊的比较：\n\n// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor\n\n另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。\n\n```cpp\n// AVLNode.h\n\n#ifndef __AVLNODE_H__\n#define __AVLNODE_H__\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename KeyType>\nclass AVLNode{\npublic:\n    KeyType key;\n    AVLNode * left;\n    AVLNode * right;\n    AVLNode() : key(0), left(NULL), right(NULL) {}\n    AVLNode(KeyType k) :key(k), left(NULL), right(NULL) {}\n};\n#endif\n```\n\n~~~cpp\n// AVLTree.h\n\n#ifndef AVLTREE_AVLTREE_H\n#define AVLTREE_AVLTREE_H\n\n#include \"AVLNode.h\"\n\n//AVL树的模板实现\ntemplate <typename KeyType>\nclass AVLTree\n{\n    //类型定义\n    typedef AVLNode<KeyType> AVLNode;\n    typedef AVLTree<KeyType> AVLTree;\n\nprivate:\n    AVLNode * avlroot;\n    //求树的高度\n    int __height(const AVLNode *root);\n    //高度差（平衡因子）\n    int __diff(const AVLNode*root);\n\n    //AVL4种旋转：左左，左右，右右，右左\n    //X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点\n    //X通过递归返回的方式找到\n    //左左：插入点位于X的左孩子节点的左子树\n    //左右：插入点位于X的左孩子节点的右子树\n    //右右：插入点位于X的右孩子节点的右子树\n    //右左：插入点位于X的右孩子节点的左子树\n\n    //单旋转\n    AVLNode * __ll_Rotation(AVLNode *root);//left-left rotation\n    AVLNode * __rr_Rotation(AVLNode *root);//right-right rotation\n    //双旋转\n    AVLNode * __lr_Rotation(AVLNode *root);//left-right rotation\n    AVLNode * __rl_Rotation(AVLNode *root);//right-left rotation\n\n\n\t//平衡操作\n    AVLNode * __Balance(AVLNode *root);\n    //插入的内部实现\n    AVLNode * __Insert(AVLNode *root, const KeyType &k);\n    //中序遍历的两种重载\n    // 1. 直接输出中序遍历节点\n    void __InorderTraversal(const AVLNode* root);\n    // 2. 结果保存到vector中\n    void __InorderTraversal(const AVLNode*root, std::vector<KeyType>&vec);\n\t//判断是否是叶子节点\n    bool __isLeaf(AVLNode* const &node) {return (node->left == nullptr && node->right == nullptr) ? true : false};\n    //判断是否有两个孩子\n    bool __isNodeWithTwoChild(AVLNode * const &node);\n\t//查找的内部实现\n    AVLNode* __search(AVLNode *const root, const KeyType &k);\n\t//删除树的所有节点\n    void __deleteTree(AVLNode * root);\n\t//删除节点\n    AVLNode* __Delete(AVLNode * root, const KeyType& k);\n\t//求当前根节点最小（一路向左）\n    AVLNode* __treeMin(AVLNode *root);\n    //求当前根节点的最大（一路向右）\n    AVLNode* __treeMax(AVLNode *root);\n\n\npublic:\n    AVLTree(){ avlroot = nullptr; }//默认构造函数\n    ~AVLTree();//析构函数删除树中所有节点\n    AVLTree(const std::vector<KeyType>&);//构造函数，容器构造\n    AVLTree(const KeyType * arr, size_t len);//构造函数，数组构造\n    void InorderTraversal();//中序遍历外部接口\n    void InorderTraversal(std::vector<KeyType>&);//中序遍历外部接口重载2\n    bool Delete(const KeyType &k);//删除节点的外部接口\n    void Insert(const KeyType & k);//插入节点的外部接口\n    bool IsEmpty(){ return avlroot == nullptr; } //树空？\n    bool search(const KeyType &k);//查询外部接口\n};\n#endif //AVLTREE_AVLTREE_H\n\n~~~\n\n### 旋转操作\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__ll_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rr_Rotation(AVLNode *root)\n{\n    AVLNode* tmp;\n    tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__lr_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = __rr_Rotation(tmp);\n    return __ll_Rotation(root);\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rl_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->right;\n    root->right = __ll_Rotation(tmp);\n    return __rr_Rotation(root);\n}\n~~~\n\n### AVLTree 插入\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Insert(AVLNode * root, const KeyType& k)\n{\n    if (nullptr == root)\n    {\n        root = new AVLNode(k);\n        return root;\n    }//递归返回条件\n    else if (k < root->key)\n    {\n        root->left = __Insert(root->left, k);//递归左子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    else if (k>root->key)\n    {\n        root->right = __Insert(root->right, k);//递归右子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    return root;\n}\n~~~\n\n\n\n### AVLTree 删除\n\n~~~cpp\n//删除节点的私有成员实现\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Delete(AVLNode *root, const KeyType& k)\n{\n    if (nullptr == root)\n        return root;\n    if (!search(k))//查找删除元素是否存在\n    {\n        std::cerr << \"Delete error , key not find\" << std::endl;\n        return root;\n    }\n\n    if (k == root->key)//根节点\n    {\n        if (__isNodeWithTwoChild(root))//左右子树都非空\n        {\n            if (__diff(root) > 0)//左子树更高，在左边删除\n            {\n                root->key = __treeMax(root->left)->key;//以左子树的最大值替换当前值\n                root->left = __Delete(root->left, root->key);//删除左子树中已经替换上去的节点\n            }\n            else//右子树更高，在右边删除\n            {\n                root->key = __treeMin(root->right)->key;\n                root->right = __Delete(root->right, root->key);\n            }\n        }\n        else//有一个孩子、叶子节点的情况合并\n        {\n            //if (!__isLeaf(root))\n            AVLNode * tmp = root;\n            root = (root->left) ? (root->left) :( root->right);\n            delete tmp;\n            tmp = nullptr;\n        }\n    }//end-if\n    else if (k < root->key)//往左边删除\n    {\n        root->left = __Delete(root->left, k);//左子树中递归删除\n        //判断平衡的条件与在插入时情况类似\n        if (__diff(root) < -1)//不满足平衡条件，删除左边的后，右子树变高\n        {\n            if (__diff(root->right) > 0)\n            {\n                root = __rl_Rotation(root);\n            }\n            else\n            {\n                root = __rr_Rotation(root);\n            }\n        }\n    }//end else if\n    else\n    {\n        root->right = __Delete(root->right, k);\n        if (__diff(root) > 1)//不满足平衡条件\n        {\n            if (__diff(root->left) < 0)\n            {\n                root = __lr_Rotation(root);\n            }\n            else\n            {\n                root = __ll_Rotation(root);\n            }\n        }\n    }\n    return root;\n}\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree)\n\n## 参考\n\n[STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）](https://blog.csdn.net/zhangxiao93/article/details/51459743)\n\n[平衡二叉树,AVL树之图解篇](http://www.cnblogs.com/suimeng/p/4560056.html)\n\n[一步一步写平衡二叉树（AVL树）](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n[平衡二叉树(avl)分析与实现](http://luodw.cc/2015/11/14/avl/)","source":"_posts/Algorithm/Data-Structure/avlree-template-implement.md","raw":"---\ntitle: 平衡二叉树（AVLTree）封装+模板实现\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - algorithm\n  - tree\n---\n\n## 简介\n\n[平衡树（AVLTree）](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)\n\n> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**AVL树**是最先发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)都是![O(\\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。增加和删除可能需要通过一次或多次[树旋转](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC)来重新平衡这个树。AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA)和[E. M. Landis](https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1)，他们在1962年的论文《An algorithm for the organization of information》中发表了它。\n>\n> 节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”**二叉搜索树**，平衡条件确保整棵树的深度为O(log n)。\n\nAVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。**查找、插入和删除在平均和最坏情况下都是 O(log n)**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。\n\nAVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。\n\n\n\n## AVL旋转\n\nAVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。\n\n在理解AVL旋转之前，首先得知道以下几个概念： \n\n1. AVL 树节点的插入总是在叶子节点。 \n2. AVL 树在插入节点之前总是满足平衡条件的。 \n1. 插入新节点后有可能满足平衡条件也有可能不满足。 \n4. 当不满足平衡条件后，我们就需要对新的树进行旋转。\n\n\n旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：\n\n> 假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。\n\n基于这个X节点，考虑一件事情： \n这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：\n\n> X的左孩子节点的左子树上**(left-left)** \n> X的右孩子节点的右子树上**(right-right)** \n> X的左孩子节点的右子树上**(left-right)** \n> X的右孩子节点的左子树上**(right-left)**\n\n根据上述情况就延生出了4种旋转： \n**1.left-left Rotation** \n**2.right-right Rotation** \n**3.left-right Rotation** \n**4.right-left Rotation**\n\n前两种属于单旋转，后两种属于双旋转，**双旋转的操作可以由两次单旋转组成。**\n\nPS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。\n\n[![avl旋转四种情况](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png)\n\n图片来自 [C小加的博客](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n1. 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。\n2. 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。\n3. 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。\n4. 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。\n\n从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。\n\n那么为什么需要双旋转呢？\n\n这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。\n\n而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。\n\n// 这里的描述太那啥了，得搞点图说明下\n\n\n\n## AVL-Tree实现\n\nAVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。\n\n节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： \n\n1. 每次都计算一次（递归求深度）。 \n2. 将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。\n\n本文采取的是第一种方式，关于两种方式利弊的比较：\n\n// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor\n\n另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。\n\n```cpp\n// AVLNode.h\n\n#ifndef __AVLNODE_H__\n#define __AVLNODE_H__\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename KeyType>\nclass AVLNode{\npublic:\n    KeyType key;\n    AVLNode * left;\n    AVLNode * right;\n    AVLNode() : key(0), left(NULL), right(NULL) {}\n    AVLNode(KeyType k) :key(k), left(NULL), right(NULL) {}\n};\n#endif\n```\n\n~~~cpp\n// AVLTree.h\n\n#ifndef AVLTREE_AVLTREE_H\n#define AVLTREE_AVLTREE_H\n\n#include \"AVLNode.h\"\n\n//AVL树的模板实现\ntemplate <typename KeyType>\nclass AVLTree\n{\n    //类型定义\n    typedef AVLNode<KeyType> AVLNode;\n    typedef AVLTree<KeyType> AVLTree;\n\nprivate:\n    AVLNode * avlroot;\n    //求树的高度\n    int __height(const AVLNode *root);\n    //高度差（平衡因子）\n    int __diff(const AVLNode*root);\n\n    //AVL4种旋转：左左，左右，右右，右左\n    //X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点\n    //X通过递归返回的方式找到\n    //左左：插入点位于X的左孩子节点的左子树\n    //左右：插入点位于X的左孩子节点的右子树\n    //右右：插入点位于X的右孩子节点的右子树\n    //右左：插入点位于X的右孩子节点的左子树\n\n    //单旋转\n    AVLNode * __ll_Rotation(AVLNode *root);//left-left rotation\n    AVLNode * __rr_Rotation(AVLNode *root);//right-right rotation\n    //双旋转\n    AVLNode * __lr_Rotation(AVLNode *root);//left-right rotation\n    AVLNode * __rl_Rotation(AVLNode *root);//right-left rotation\n\n\n\t//平衡操作\n    AVLNode * __Balance(AVLNode *root);\n    //插入的内部实现\n    AVLNode * __Insert(AVLNode *root, const KeyType &k);\n    //中序遍历的两种重载\n    // 1. 直接输出中序遍历节点\n    void __InorderTraversal(const AVLNode* root);\n    // 2. 结果保存到vector中\n    void __InorderTraversal(const AVLNode*root, std::vector<KeyType>&vec);\n\t//判断是否是叶子节点\n    bool __isLeaf(AVLNode* const &node) {return (node->left == nullptr && node->right == nullptr) ? true : false};\n    //判断是否有两个孩子\n    bool __isNodeWithTwoChild(AVLNode * const &node);\n\t//查找的内部实现\n    AVLNode* __search(AVLNode *const root, const KeyType &k);\n\t//删除树的所有节点\n    void __deleteTree(AVLNode * root);\n\t//删除节点\n    AVLNode* __Delete(AVLNode * root, const KeyType& k);\n\t//求当前根节点最小（一路向左）\n    AVLNode* __treeMin(AVLNode *root);\n    //求当前根节点的最大（一路向右）\n    AVLNode* __treeMax(AVLNode *root);\n\n\npublic:\n    AVLTree(){ avlroot = nullptr; }//默认构造函数\n    ~AVLTree();//析构函数删除树中所有节点\n    AVLTree(const std::vector<KeyType>&);//构造函数，容器构造\n    AVLTree(const KeyType * arr, size_t len);//构造函数，数组构造\n    void InorderTraversal();//中序遍历外部接口\n    void InorderTraversal(std::vector<KeyType>&);//中序遍历外部接口重载2\n    bool Delete(const KeyType &k);//删除节点的外部接口\n    void Insert(const KeyType & k);//插入节点的外部接口\n    bool IsEmpty(){ return avlroot == nullptr; } //树空？\n    bool search(const KeyType &k);//查询外部接口\n};\n#endif //AVLTREE_AVLTREE_H\n\n~~~\n\n### 旋转操作\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__ll_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rr_Rotation(AVLNode *root)\n{\n    AVLNode* tmp;\n    tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__lr_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->left;\n    root->left = __rr_Rotation(tmp);\n    return __ll_Rotation(root);\n}\n\ntemplate <typename KeyType>\nAVLNode * AVLTree::__rl_Rotation(AVLNode *root)\n{\n    AVLNode * tmp;\n    tmp = root->right;\n    root->right = __ll_Rotation(tmp);\n    return __rr_Rotation(root);\n}\n~~~\n\n### AVLTree 插入\n\n~~~cpp\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Insert(AVLNode * root, const KeyType& k)\n{\n    if (nullptr == root)\n    {\n        root = new AVLNode(k);\n        return root;\n    }//递归返回条件\n    else if (k < root->key)\n    {\n        root->left = __Insert(root->left, k);//递归左子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    else if (k>root->key)\n    {\n        root->right = __Insert(root->right, k);//递归右子树\n        //balance operation\n        root = __Balance(root);//平衡操作包含了四种旋转\n    }\n    return root;\n}\n~~~\n\n\n\n### AVLTree 删除\n\n~~~cpp\n//删除节点的私有成员实现\ntemplate <typename KeyType>\nAVLNode * AVLTree::__Delete(AVLNode *root, const KeyType& k)\n{\n    if (nullptr == root)\n        return root;\n    if (!search(k))//查找删除元素是否存在\n    {\n        std::cerr << \"Delete error , key not find\" << std::endl;\n        return root;\n    }\n\n    if (k == root->key)//根节点\n    {\n        if (__isNodeWithTwoChild(root))//左右子树都非空\n        {\n            if (__diff(root) > 0)//左子树更高，在左边删除\n            {\n                root->key = __treeMax(root->left)->key;//以左子树的最大值替换当前值\n                root->left = __Delete(root->left, root->key);//删除左子树中已经替换上去的节点\n            }\n            else//右子树更高，在右边删除\n            {\n                root->key = __treeMin(root->right)->key;\n                root->right = __Delete(root->right, root->key);\n            }\n        }\n        else//有一个孩子、叶子节点的情况合并\n        {\n            //if (!__isLeaf(root))\n            AVLNode * tmp = root;\n            root = (root->left) ? (root->left) :( root->right);\n            delete tmp;\n            tmp = nullptr;\n        }\n    }//end-if\n    else if (k < root->key)//往左边删除\n    {\n        root->left = __Delete(root->left, k);//左子树中递归删除\n        //判断平衡的条件与在插入时情况类似\n        if (__diff(root) < -1)//不满足平衡条件，删除左边的后，右子树变高\n        {\n            if (__diff(root->right) > 0)\n            {\n                root = __rl_Rotation(root);\n            }\n            else\n            {\n                root = __rr_Rotation(root);\n            }\n        }\n    }//end else if\n    else\n    {\n        root->right = __Delete(root->right, k);\n        if (__diff(root) > 1)//不满足平衡条件\n        {\n            if (__diff(root->left) < 0)\n            {\n                root = __lr_Rotation(root);\n            }\n            else\n            {\n                root = __ll_Rotation(root);\n            }\n        }\n    }\n    return root;\n}\n~~~\n\n\n\n附：[完整代码](https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree)\n\n## 参考\n\n[STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）](https://blog.csdn.net/zhangxiao93/article/details/51459743)\n\n[平衡二叉树,AVL树之图解篇](http://www.cnblogs.com/suimeng/p/4560056.html)\n\n[一步一步写平衡二叉树（AVL树）](http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html)\n\n[平衡二叉树(avl)分析与实现](http://luodw.cc/2015/11/14/avl/)","slug":"Algorithm/Data-Structure/avlree-template-implement","published":1,"date":"2018-05-01T03:09:27.905Z","updated":"2019-03-23T03:38:05.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1900e9qnn9xf4uzf1i","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/AVL%E6%A0%91\" target=\"_blank\" rel=\"noopener\">平衡树（AVLTree）</a></p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">计算机科学</a>中，<strong>AVL树</strong>是最先发明的<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\" target=\"_blank\" rel=\"noopener\">自平衡二叉查找树</a>。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">时间复杂度</a>都是<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99\" alt=\"O(\\log{n})\">。增加和删除可能需要通过一次或多次<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC\" target=\"_blank\" rel=\"noopener\">树旋转</a>来重新平衡这个树。AVL树得名于它的发明者<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA\" target=\"_blank\" rel=\"noopener\">G. M. Adelson-Velsky</a>和<a href=\"https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">E. M. Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>\n<p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>\n</blockquote>\n<p>二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”<strong>二叉搜索树</strong>，平衡条件确保整棵树的深度为O(log n)。</p>\n<p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。<strong>查找、插入和删除在平均和最坏情况下都是 O(log n)</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>\n<p>AVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。</p>\n<h2 id=\"AVL旋转\"><a href=\"#AVL旋转\" class=\"headerlink\" title=\"AVL旋转\"></a>AVL旋转</h2><p>AVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。</p>\n<p>在理解AVL旋转之前，首先得知道以下几个概念： </p>\n<ol>\n<li>AVL 树节点的插入总是在叶子节点。 </li>\n<li>AVL 树在插入节点之前总是满足平衡条件的。 </li>\n<li>插入新节点后有可能满足平衡条件也有可能不满足。 </li>\n<li>当不满足平衡条件后，我们就需要对新的树进行旋转。</li>\n</ol>\n<p>旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：</p>\n<blockquote>\n<p>假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。</p>\n</blockquote>\n<p>基于这个X节点，考虑一件事情：<br>这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：</p>\n<blockquote>\n<p>X的左孩子节点的左子树上<strong>(left-left)</strong><br>X的右孩子节点的右子树上<strong>(right-right)</strong><br>X的左孩子节点的右子树上<strong>(left-right)</strong><br>X的右孩子节点的左子树上<strong>(right-left)</strong></p>\n</blockquote>\n<p>根据上述情况就延生出了4种旋转：<br><strong>1.left-left Rotation</strong><br><strong>2.right-right Rotation</strong><br><strong>3.left-right Rotation</strong><br><strong>4.right-left Rotation</strong></p>\n<p>前两种属于单旋转，后两种属于双旋转，<strong>双旋转的操作可以由两次单旋转组成。</strong></p>\n<p>PS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。</p>\n<p><a href=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" alt=\"avl旋转四种情况\"></a></p>\n<p>图片来自 <a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">C小加的博客</a></p>\n<ol>\n<li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。</li>\n<li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。</li>\n<li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。</li>\n<li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。</li>\n</ol>\n<p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p>\n<p>那么为什么需要双旋转呢？</p>\n<p>这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。</p>\n<p>而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。</p>\n<p>// 这里的描述太那啥了，得搞点图说明下</p>\n<h2 id=\"AVL-Tree实现\"><a href=\"#AVL-Tree实现\" class=\"headerlink\" title=\"AVL-Tree实现\"></a>AVL-Tree实现</h2><p>AVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。</p>\n<p>节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： </p>\n<ol>\n<li>每次都计算一次（递归求深度）。 </li>\n<li>将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。</li>\n</ol>\n<p>本文采取的是第一种方式，关于两种方式利弊的比较：</p>\n<p>// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor</p>\n<p>另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLNode.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __AVLNODE_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __AVLNODE_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    KeyType key;</span><br><span class=\"line\">    AVLNode * left;</span><br><span class=\"line\">    AVLNode * right;</span><br><span class=\"line\">    AVLNode() : key(<span class=\"number\">0</span>), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">    AVLNode(KeyType k) :key(k), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLTree.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"AVLNode.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//AVL树的模板实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型定义</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLNode&lt;KeyType&gt; AVLNode;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLTree&lt;KeyType&gt; AVLTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    AVLNode * avlroot;</span><br><span class=\"line\">    <span class=\"comment\">//求树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __height(<span class=\"keyword\">const</span> AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//高度差（平衡因子）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __diff(<span class=\"keyword\">const</span> AVLNode*root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//AVL4种旋转：左左，左右，右右，右左</span></span><br><span class=\"line\">    <span class=\"comment\">//X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点</span></span><br><span class=\"line\">    <span class=\"comment\">//X通过递归返回的方式找到</span></span><br><span class=\"line\">    <span class=\"comment\">//左左：插入点位于X的左孩子节点的左子树</span></span><br><span class=\"line\">    <span class=\"comment\">//左右：插入点位于X的左孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右右：插入点位于X的右孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右左：插入点位于X的右孩子节点的左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//单旋转</span></span><br><span class=\"line\">    AVLNode * __ll_Rotation(AVLNode *root);<span class=\"comment\">//left-left rotation</span></span><br><span class=\"line\">    AVLNode * __rr_Rotation(AVLNode *root);<span class=\"comment\">//right-right rotation</span></span><br><span class=\"line\">    <span class=\"comment\">//双旋转</span></span><br><span class=\"line\">    AVLNode * __lr_Rotation(AVLNode *root);<span class=\"comment\">//left-right rotation</span></span><br><span class=\"line\">    AVLNode * __rl_Rotation(AVLNode *root);<span class=\"comment\">//right-left rotation</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//平衡操作</span></span><br><span class=\"line\">    AVLNode * __Balance(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//插入的内部实现</span></span><br><span class=\"line\">    AVLNode * __Insert(AVLNode *root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">    <span class=\"comment\">//中序遍历的两种重载</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 直接输出中序遍历节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode* root);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 结果保存到vector中</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode*root, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;vec);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否是叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isLeaf(AVLNode* <span class=\"keyword\">const</span> &amp;node) &#123;<span class=\"keyword\">return</span> (node-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right == <span class=\"literal\">nullptr</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有两个孩子</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isNodeWithTwoChild(AVLNode * <span class=\"keyword\">const</span> &amp;node);</span><br><span class=\"line\">\t<span class=\"comment\">//查找的内部实现</span></span><br><span class=\"line\">    AVLNode* __search(AVLNode *<span class=\"keyword\">const</span> root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">\t<span class=\"comment\">//删除树的所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __deleteTree(AVLNode * root);</span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    AVLNode* __Delete(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k);</span><br><span class=\"line\">\t<span class=\"comment\">//求当前根节点最小（一路向左）</span></span><br><span class=\"line\">    AVLNode* __treeMin(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//求当前根节点的最大（一路向右）</span></span><br><span class=\"line\">    AVLNode* __treeMax(AVLNode *root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AVLTree()&#123; avlroot = <span class=\"literal\">nullptr</span>; &#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    ~AVLTree();<span class=\"comment\">//析构函数删除树中所有节点</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;);<span class=\"comment\">//构造函数，容器构造</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> KeyType * arr, <span class=\"keyword\">size_t</span> len);<span class=\"comment\">//构造函数，数组构造</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">()</span></span>;<span class=\"comment\">//中序遍历外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;)</span></span>;<span class=\"comment\">//中序遍历外部接口重载2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//删除节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp; k)</span></span>;<span class=\"comment\">//插入节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> avlroot == <span class=\"literal\">nullptr</span>; &#125; <span class=\"comment\">//树空？</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//查询外部接口</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//AVLTREE_AVLTREE_H</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"旋转操作\"><a href=\"#旋转操作\" class=\"headerlink\" title=\"旋转操作\"></a>旋转操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__ll_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = tmp-&gt;right;</span><br><span class=\"line\">    tmp-&gt;right = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode* tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp-&gt;left;</span><br><span class=\"line\">    tmp-&gt;left = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__lr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = __rr_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __ll_Rotation(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rl_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = __ll_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __rr_Rotation(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-插入\"><a href=\"#AVLTree-插入\" class=\"headerlink\" title=\"AVLTree 插入\"></a>AVLTree 插入</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Insert(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> AVLNode(k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//递归返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Insert(root-&gt;left, k);<span class=\"comment\">//递归左子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k&gt;root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Insert(root-&gt;right, k);<span class=\"comment\">//递归右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-删除\"><a href=\"#AVLTree-删除\" class=\"headerlink\" title=\"AVLTree 删除\"></a>AVLTree 删除</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除节点的私有成员实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Delete(AVLNode *root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!search(k))<span class=\"comment\">//查找删除元素是否存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Delete error , key not find\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == root-&gt;key)<span class=\"comment\">//根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__isNodeWithTwoChild(root))<span class=\"comment\">//左右子树都非空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">0</span>)<span class=\"comment\">//左子树更高，在左边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMax(root-&gt;left)-&gt;key;<span class=\"comment\">//以左子树的最大值替换当前值</span></span><br><span class=\"line\">                root-&gt;left = __Delete(root-&gt;left, root-&gt;key);<span class=\"comment\">//删除左子树中已经替换上去的节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//右子树更高，在右边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMin(root-&gt;right)-&gt;key;</span><br><span class=\"line\">                root-&gt;right = __Delete(root-&gt;right, root-&gt;key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//有一个孩子、叶子节点的情况合并</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//if (!__isLeaf(root))</span></span><br><span class=\"line\">            AVLNode * tmp = root;</span><br><span class=\"line\">            root = (root-&gt;left) ? (root-&gt;left) :( root-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end-if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)<span class=\"comment\">//往左边删除</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Delete(root-&gt;left, k);<span class=\"comment\">//左子树中递归删除</span></span><br><span class=\"line\">        <span class=\"comment\">//判断平衡的条件与在插入时情况类似</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &lt; <span class=\"number\">-1</span>)<span class=\"comment\">//不满足平衡条件，删除左边的后，右子树变高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;right) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rl_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end else if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Delete(root-&gt;right, k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">1</span>)<span class=\"comment\">//不满足平衡条件</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;left) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __lr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __ll_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/zhangxiao93/article/details/51459743\" target=\"_blank\" rel=\"noopener\">STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）</a></p>\n<p><a href=\"http://www.cnblogs.com/suimeng/p/4560056.html\" target=\"_blank\" rel=\"noopener\">平衡二叉树,AVL树之图解篇</a></p>\n<p><a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">一步一步写平衡二叉树（AVL树）</a></p>\n<p><a href=\"http://luodw.cc/2015/11/14/avl/\" target=\"_blank\" rel=\"noopener\">平衡二叉树(avl)分析与实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/AVL%E6%A0%91\" target=\"_blank\" rel=\"noopener\">平衡树（AVLTree）</a></p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">计算机科学</a>中，<strong>AVL树</strong>是最先发明的<a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\" target=\"_blank\" rel=\"noopener\">自平衡二叉查找树</a>。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href=\"https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" target=\"_blank\" rel=\"noopener\">时间复杂度</a>都是<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99\" alt=\"O(\\log{n})\">。增加和删除可能需要通过一次或多次<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC\" target=\"_blank\" rel=\"noopener\">树旋转</a>来重新平衡这个树。AVL树得名于它的发明者<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA\" target=\"_blank\" rel=\"noopener\">G. M. Adelson-Velsky</a>和<a href=\"https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">E. M. Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>\n<p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>\n</blockquote>\n<p>二叉查找树给我们带来了很多方便，但是由于其在有序序列插入时就会退化成单链表（时间复杂度退化成 O(n)，AVL-tree就克服了上述困难。AVL-tree是一个“加上了平衡条件的”<strong>二叉搜索树</strong>，平衡条件确保整棵树的深度为O(log n)。</p>\n<p>AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。<strong>查找、插入和删除在平均和最坏情况下都是 O(log n)</strong>。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>\n<p>AVL树的所有操作都与二叉查找树相同，不同的是，这里AVL树需要做“AVL旋转”。</p>\n<h2 id=\"AVL旋转\"><a href=\"#AVL旋转\" class=\"headerlink\" title=\"AVL旋转\"></a>AVL旋转</h2><p>AVL树最重要的核心部分就是AVL旋转了，这部分我的感触是，单做旋转还是挺好理解的，只不过写起代码来有点复杂，书中以插入节点为例，删除节点的部分折腾了好久。</p>\n<p>在理解AVL旋转之前，首先得知道以下几个概念： </p>\n<ol>\n<li>AVL 树节点的插入总是在叶子节点。 </li>\n<li>AVL 树在插入节点之前总是满足平衡条件的。 </li>\n<li>插入新节点后有可能满足平衡条件也有可能不满足。 </li>\n<li>当不满足平衡条件后，我们就需要对新的树进行旋转。</li>\n</ol>\n<p>旋转之前，我们首先要找到一个X节点，这个X节点做如下定义：</p>\n<blockquote>\n<p>假如我们在某一个叶子节点处插入一个新的节点后，此时这棵树的某些节点的平衡性会发生变化，那么我们从叶子节点向上到根节点的路径上第一个平衡性发生变化的节点。</p>\n</blockquote>\n<p>基于这个X节点，考虑一件事情：<br>这个X节点分为左右子树，左右子树又有左右子树，1分2，2分4，所以以这个X节点为根节点的话，新插入的节点可能出现的位置有：</p>\n<blockquote>\n<p>X的左孩子节点的左子树上<strong>(left-left)</strong><br>X的右孩子节点的右子树上<strong>(right-right)</strong><br>X的左孩子节点的右子树上<strong>(left-right)</strong><br>X的右孩子节点的左子树上<strong>(right-left)</strong></p>\n</blockquote>\n<p>根据上述情况就延生出了4种旋转：<br><strong>1.left-left Rotation</strong><br><strong>2.right-right Rotation</strong><br><strong>3.left-right Rotation</strong><br><strong>4.right-left Rotation</strong></p>\n<p>前两种属于单旋转，后两种属于双旋转，<strong>双旋转的操作可以由两次单旋转组成。</strong></p>\n<p>PS:AVL树的旋转还是得画图来理解，这里直接贴出书中的图了。</p>\n<p><a href=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png\" alt=\"avl旋转四种情况\"></a></p>\n<p>图片来自 <a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">C小加的博客</a></p>\n<ol>\n<li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左（LL）。</li>\n<li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右（LR）。</li>\n<li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左（RL）。</li>\n<li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右（RR）。</li>\n</ol>\n<p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p>\n<p>那么为什么需要双旋转呢？</p>\n<p>这里我做出我个人的解释，在 LL 情况中，要达到平衡，是需要将失衡节点划分到右边，失衡节点的左孩子补上失衡节点的位置。这样左子树的高度 -1， 右边的高度 +1，这样左右两边的个数就平衡了。当然根据BST的性质，如果失衡节点存在右孩子的话应该划也要分到右边。RR 情况与 LL 情况对称。</p>\n<p>而在 LR 情况中，我们是需要把失衡节点划到右边，失衡节点的左孩子的右孩子替补失衡节点原来的位置。但我们的节点存储结构有不能获得前驱节点的限制，我们只有后继关系，即我们只能通过失衡节点访问其他节点，所以不能直接把LR孩子放上来，而是分成两步调整。</p>\n<p>// 这里的描述太那啥了，得搞点图说明下</p>\n<h2 id=\"AVL-Tree实现\"><a href=\"#AVL-Tree实现\" class=\"headerlink\" title=\"AVL-Tree实现\"></a>AVL-Tree实现</h2><p>AVL-Tree是一个二叉排序树，其基本操作也跟它类似，唯一需要注意的就是在插入，删除节点后，需要对树进行调整，让树的每个节点保持平衡。</p>\n<p>节点的平衡因子是通过计算其左子树和右子树的差得来的，这里有两种考虑方式： </p>\n<ol>\n<li>每次都计算一次（递归求深度）。 </li>\n<li>将平衡因子作为一个成员变量保存在节点中，平衡性发生变化的时候更新。</li>\n</ol>\n<p>本文采取的是第一种方式，关于两种方式利弊的比较：</p>\n<p>// 不想写？自己百度吧，反正就是第一种方法从上到下递归存在重复调用增加时间开销，第二种平衡性变化时候需要update 失衡位置 balanceFactor</p>\n<p>另外，这里我用了C++类封装，为了学习还顺便使用了模板，所以类的声明和实现都放在了一个文件中，感觉内容太多，还是分开来比较好。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLNode.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __AVLNODE_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __AVLNODE_H__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    KeyType key;</span><br><span class=\"line\">    AVLNode * left;</span><br><span class=\"line\">    AVLNode * right;</span><br><span class=\"line\">    AVLNode() : key(<span class=\"number\">0</span>), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">    AVLNode(KeyType k) :key(k), left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AVLTree.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AVLTREE_AVLTREE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"AVLNode.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//AVL树的模板实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLTree</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//类型定义</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLNode&lt;KeyType&gt; AVLNode;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> AVLTree&lt;KeyType&gt; AVLTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    AVLNode * avlroot;</span><br><span class=\"line\">    <span class=\"comment\">//求树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __height(<span class=\"keyword\">const</span> AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//高度差（平衡因子）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __diff(<span class=\"keyword\">const</span> AVLNode*root);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//AVL4种旋转：左左，左右，右右，右左</span></span><br><span class=\"line\">    <span class=\"comment\">//X定义为插入位置节点到根节点的路径上平衡条件被改变的节点中最深的那个节点</span></span><br><span class=\"line\">    <span class=\"comment\">//X通过递归返回的方式找到</span></span><br><span class=\"line\">    <span class=\"comment\">//左左：插入点位于X的左孩子节点的左子树</span></span><br><span class=\"line\">    <span class=\"comment\">//左右：插入点位于X的左孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右右：插入点位于X的右孩子节点的右子树</span></span><br><span class=\"line\">    <span class=\"comment\">//右左：插入点位于X的右孩子节点的左子树</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//单旋转</span></span><br><span class=\"line\">    AVLNode * __ll_Rotation(AVLNode *root);<span class=\"comment\">//left-left rotation</span></span><br><span class=\"line\">    AVLNode * __rr_Rotation(AVLNode *root);<span class=\"comment\">//right-right rotation</span></span><br><span class=\"line\">    <span class=\"comment\">//双旋转</span></span><br><span class=\"line\">    AVLNode * __lr_Rotation(AVLNode *root);<span class=\"comment\">//left-right rotation</span></span><br><span class=\"line\">    AVLNode * __rl_Rotation(AVLNode *root);<span class=\"comment\">//right-left rotation</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//平衡操作</span></span><br><span class=\"line\">    AVLNode * __Balance(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//插入的内部实现</span></span><br><span class=\"line\">    AVLNode * __Insert(AVLNode *root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">    <span class=\"comment\">//中序遍历的两种重载</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 直接输出中序遍历节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode* root);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 结果保存到vector中</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __InorderTraversal(<span class=\"keyword\">const</span> AVLNode*root, <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;vec);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否是叶子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isLeaf(AVLNode* <span class=\"keyword\">const</span> &amp;node) &#123;<span class=\"keyword\">return</span> (node-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right == <span class=\"literal\">nullptr</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有两个孩子</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isNodeWithTwoChild(AVLNode * <span class=\"keyword\">const</span> &amp;node);</span><br><span class=\"line\">\t<span class=\"comment\">//查找的内部实现</span></span><br><span class=\"line\">    AVLNode* __search(AVLNode *<span class=\"keyword\">const</span> root, <span class=\"keyword\">const</span> KeyType &amp;k);</span><br><span class=\"line\">\t<span class=\"comment\">//删除树的所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __deleteTree(AVLNode * root);</span><br><span class=\"line\">\t<span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    AVLNode* __Delete(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k);</span><br><span class=\"line\">\t<span class=\"comment\">//求当前根节点最小（一路向左）</span></span><br><span class=\"line\">    AVLNode* __treeMin(AVLNode *root);</span><br><span class=\"line\">    <span class=\"comment\">//求当前根节点的最大（一路向右）</span></span><br><span class=\"line\">    AVLNode* __treeMax(AVLNode *root);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AVLTree()&#123; avlroot = <span class=\"literal\">nullptr</span>; &#125;<span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">    ~AVLTree();<span class=\"comment\">//析构函数删除树中所有节点</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;);<span class=\"comment\">//构造函数，容器构造</span></span><br><span class=\"line\">    AVLTree(<span class=\"keyword\">const</span> KeyType * arr, <span class=\"keyword\">size_t</span> len);<span class=\"comment\">//构造函数，数组构造</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">()</span></span>;<span class=\"comment\">//中序遍历外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InorderTraversal</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;KeyType&gt;&amp;)</span></span>;<span class=\"comment\">//中序遍历外部接口重载2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Delete</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//删除节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp; k)</span></span>;<span class=\"comment\">//插入节点的外部接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> avlroot == <span class=\"literal\">nullptr</span>; &#125; <span class=\"comment\">//树空？</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">const</span> KeyType &amp;k)</span></span>;<span class=\"comment\">//查询外部接口</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//AVLTREE_AVLTREE_H</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"旋转操作\"><a href=\"#旋转操作\" class=\"headerlink\" title=\"旋转操作\"></a>旋转操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__ll_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = tmp-&gt;right;</span><br><span class=\"line\">    tmp-&gt;right = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode* tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = tmp-&gt;left;</span><br><span class=\"line\">    tmp-&gt;left = root;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__lr_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;left;</span><br><span class=\"line\">    root-&gt;left = __rr_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __ll_Rotation(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__rl_Rotation(AVLNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AVLNode * tmp;</span><br><span class=\"line\">    tmp = root-&gt;right;</span><br><span class=\"line\">    root-&gt;right = __ll_Rotation(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> __rr_Rotation(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-插入\"><a href=\"#AVLTree-插入\" class=\"headerlink\" title=\"AVLTree 插入\"></a>AVLTree 插入</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Insert(AVLNode * root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> AVLNode(k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//递归返回条件</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Insert(root-&gt;left, k);<span class=\"comment\">//递归左子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k&gt;root-&gt;key)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Insert(root-&gt;right, k);<span class=\"comment\">//递归右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//balance operation</span></span><br><span class=\"line\">        root = __Balance(root);<span class=\"comment\">//平衡操作包含了四种旋转</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"AVLTree-删除\"><a href=\"#AVLTree-删除\" class=\"headerlink\" title=\"AVLTree 删除\"></a>AVLTree 删除</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除节点的私有成员实现</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> KeyType&gt;</span><br><span class=\"line\">AVLNode * AVLTree::__Delete(AVLNode *root, <span class=\"keyword\">const</span> KeyType&amp; k)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">nullptr</span> == root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!search(k))<span class=\"comment\">//查找删除元素是否存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cerr</span> &lt;&lt; <span class=\"string\">\"Delete error , key not find\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == root-&gt;key)<span class=\"comment\">//根节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__isNodeWithTwoChild(root))<span class=\"comment\">//左右子树都非空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">0</span>)<span class=\"comment\">//左子树更高，在左边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMax(root-&gt;left)-&gt;key;<span class=\"comment\">//以左子树的最大值替换当前值</span></span><br><span class=\"line\">                root-&gt;left = __Delete(root-&gt;left, root-&gt;key);<span class=\"comment\">//删除左子树中已经替换上去的节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span><span class=\"comment\">//右子树更高，在右边删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root-&gt;key = __treeMin(root-&gt;right)-&gt;key;</span><br><span class=\"line\">                root-&gt;right = __Delete(root-&gt;right, root-&gt;key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//有一个孩子、叶子节点的情况合并</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//if (!__isLeaf(root))</span></span><br><span class=\"line\">            AVLNode * tmp = root;</span><br><span class=\"line\">            root = (root-&gt;left) ? (root-&gt;left) :( root-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            tmp = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end-if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt; root-&gt;key)<span class=\"comment\">//往左边删除</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;left = __Delete(root-&gt;left, k);<span class=\"comment\">//左子树中递归删除</span></span><br><span class=\"line\">        <span class=\"comment\">//判断平衡的条件与在插入时情况类似</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &lt; <span class=\"number\">-1</span>)<span class=\"comment\">//不满足平衡条件，删除左边的后，右子树变高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;right) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rl_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __rr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"comment\">//end else if</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root-&gt;right = __Delete(root-&gt;right, k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__diff(root) &gt; <span class=\"number\">1</span>)<span class=\"comment\">//不满足平衡条件</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__diff(root-&gt;left) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __lr_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                root = __ll_Rotation(root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附：<a href=\"https://github.com/yuechuanx/Data-Structure/tree/master/Tree/AVLTree\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/zhangxiao93/article/details/51459743\" target=\"_blank\" rel=\"noopener\">STL源码笔记（18）—平衡二叉树AVL（C++封装+模板）</a></p>\n<p><a href=\"http://www.cnblogs.com/suimeng/p/4560056.html\" target=\"_blank\" rel=\"noopener\">平衡二叉树,AVL树之图解篇</a></p>\n<p><a href=\"http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html\" target=\"_blank\" rel=\"noopener\">一步一步写平衡二叉树（AVL树）</a></p>\n<p><a href=\"http://luodw.cc/2015/11/14/avl/\" target=\"_blank\" rel=\"noopener\">平衡二叉树(avl)分析与实现</a></p>\n"},{"title":"求图的拓扑排序","_content":"\n## 简介\n\n[**拓扑排序** （Topological Sorting）](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)\n\n> 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。\n> 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。\n>\n> 1. 每个顶点出现且只出现一次；\n> 2. 若A在序列中排在B的前面，则在图中不存在从B到A的边。\n>\n> 也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n## 问题描述\n\n一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 <i, j> 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（*Activity on Vertex*），记作 **AOV网络**。\n\n在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。\n\n一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫**拓扑排序**。\n\n例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。\n![img](https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg)\n\n## 算法思路\n\n1. 在AOV网络中选一个没有直接前驱的顶点v，并输出\n2. 从图中删除该顶点，同时删去所有从顶点v发出的弧\n3. 重复步骤1,2. 直到没有直接前驱的顶点全部输出\n\n## 算法步骤\n\n用二维list链表存储图的领接表\n\n1. 建立入度为0的顶点栈\n2. 当入度为0的顶点栈为空时，转到步骤6，否则步骤3\n3. 从入度为0的顶点栈顶元素v出栈，并输出顶点v\n4. 从AOV网络删去顶点v和所有顶点v发出的弧 <v, j>， 并将顶点 j 的入度 -1\n5. 如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2\n6. 如果输出顶点个数 < AOV网络顶点数，则图中存在有向环\n\n\n\n## 复杂度分析\n\nTopological Sorting via Depth First Search(DFS)\n在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。\n\n在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。\n\n因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。\n\n\n\n## 代码实现\n\n### C++ \n\n```cpp\n#include<iostream>\n#include <list>\n#include <stack>\nusing namespace std;\n\n// Class to represent a graph\nclass Graph\n{\n    int V;    // No. of vertices'\n\n    // Pointer to an array containing adjacency listsList\n    list<int> *adj;\n\n    // A function used by topologicalSort\n    void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\npublic:\n    Graph(int V);   // Constructor\n\n     // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // prints a Topological Sort of the complete graph\n    void topologicalSort();\n};\n\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v’s list.\n}\n\n// A recursive function used by topologicalSort\nvoid Graph::topologicalSortUtil(int v, bool visited[], \n                                stack<int> &Stack)\n{\n    // Mark the current node as visited.\n    visited[v] = true;\n\n    // Recur for all the vertices adjacent to this vertex\n    list<int>::iterator i;\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\n        if (!visited[*i])\n            topologicalSortUtil(*i, visited, Stack);\n\n    // Push current vertex to stack which stores result\n    Stack.push(v);\n}\n\n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil()\nvoid Graph::topologicalSort()\n{\n    stack<int> Stack;\n\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    // Call the recursive helper function to store Topological\n    // Sort starting from all vertices one by one\n    for (int i = 0; i < V; i++)\n      if (visited[i] == false)\n        topologicalSortUtil(i, visited, Stack);\n\n    // Print contents of stack\n    while (Stack.empty() == false)\n    {\n        cout << Stack.top() << \" \";\n        Stack.pop();\n    }\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"Following is a Topological Sort of the given graph n\";\n    g.topologicalSort();\n\n    return 0;\n}\n```\n\n### Java \n\n```java\nimport java.io.*;\nimport java.util.*;\n\n// This class represents a directed graph using adjacency\n// list representation\nclass Graph\n{\n    private int V;   // No. of vertices\n    private LinkedList<Integer> adj[]; // Adjacency List\n\n    //Constructor\n    Graph(int v)\n    {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i=0; i<v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    // Function to add an edge into the graph\n    void addEdge(int v,int w) { adj[v].add(w); }\n\n    // A recursive function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[],\n                             Stack stack)\n    {\n        // Mark the current node as visited.\n        visited[v] = true;\n        Integer i;\n\n        // Recur for all the vertices adjacent to this\n        // vertex\n        Iterator<Integer> it = adj[v].iterator();\n        while (it.hasNext())\n        {\n            i = it.next();\n            if (!visited[i])\n                topologicalSortUtil(i, visited, stack);\n        }\n\n        // Push current vertex to stack which stores result\n        stack.push(new Integer(v));\n    }\n\n    // The function to do Topological Sort. It uses\n    // recursive topologicalSortUtil()\n    void topologicalSort()\n    {\n        Stack stack = new Stack();\n\n        // Mark all the vertices as not visited\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        // Call the recursive helper function to store\n        // Topological Sort starting from all vertices\n        // one by one\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                topologicalSortUtil(i, visited, stack);\n\n        // Print contents of stack\n        while (stack.empty()==false)\n            System.out.print(stack.pop() + \" \");\n    }\n\n    public static void main(String args[])\n    {\n        // Create a graph given in the above diagram\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n\n        System.out.println(\"Following is a Topological \" +\n                           \"sort of the given graph\");\n        g.topologicalSort();\n    }\n}\n```","source":"_posts/Algorithm/Data-Structure/topological-sort.md","raw":"---\ntitle: 求图的拓扑排序\ncategories:\n  - Algorithm\n  - Data-Structure\ntags:\n  - graph\n  - topological-sort\n---\n\n## 简介\n\n[**拓扑排序** （Topological Sorting）](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)\n\n> 在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。\n> 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。\n>\n> 1. 每个顶点出现且只出现一次；\n> 2. 若A在序列中排在B的前面，则在图中不存在从B到A的边。\n>\n> 也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。\n\n## 问题描述\n\n一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 <i, j> 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（*Activity on Vertex*），记作 **AOV网络**。\n\n在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。\n\n一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫**拓扑排序**。\n\n例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。\n![img](https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg)\n\n## 算法思路\n\n1. 在AOV网络中选一个没有直接前驱的顶点v，并输出\n2. 从图中删除该顶点，同时删去所有从顶点v发出的弧\n3. 重复步骤1,2. 直到没有直接前驱的顶点全部输出\n\n## 算法步骤\n\n用二维list链表存储图的领接表\n\n1. 建立入度为0的顶点栈\n2. 当入度为0的顶点栈为空时，转到步骤6，否则步骤3\n3. 从入度为0的顶点栈顶元素v出栈，并输出顶点v\n4. 从AOV网络删去顶点v和所有顶点v发出的弧 <v, j>， 并将顶点 j 的入度 -1\n5. 如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2\n6. 如果输出顶点个数 < AOV网络顶点数，则图中存在有向环\n\n\n\n## 复杂度分析\n\nTopological Sorting via Depth First Search(DFS)\n在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。\n\n在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。\n\n因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。\n\n\n\n## 代码实现\n\n### C++ \n\n```cpp\n#include<iostream>\n#include <list>\n#include <stack>\nusing namespace std;\n\n// Class to represent a graph\nclass Graph\n{\n    int V;    // No. of vertices'\n\n    // Pointer to an array containing adjacency listsList\n    list<int> *adj;\n\n    // A function used by topologicalSort\n    void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);\npublic:\n    Graph(int V);   // Constructor\n\n     // function to add an edge to graph\n    void addEdge(int v, int w);\n\n    // prints a Topological Sort of the complete graph\n    void topologicalSort();\n};\n\nGraph::Graph(int V)\n{\n    this->V = V;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n    adj[v].push_back(w); // Add w to v’s list.\n}\n\n// A recursive function used by topologicalSort\nvoid Graph::topologicalSortUtil(int v, bool visited[], \n                                stack<int> &Stack)\n{\n    // Mark the current node as visited.\n    visited[v] = true;\n\n    // Recur for all the vertices adjacent to this vertex\n    list<int>::iterator i;\n    for (i = adj[v].begin(); i != adj[v].end(); ++i)\n        if (!visited[*i])\n            topologicalSortUtil(*i, visited, Stack);\n\n    // Push current vertex to stack which stores result\n    Stack.push(v);\n}\n\n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil()\nvoid Graph::topologicalSort()\n{\n    stack<int> Stack;\n\n    // Mark all the vertices as not visited\n    bool *visited = new bool[V];\n    for (int i = 0; i < V; i++)\n        visited[i] = false;\n\n    // Call the recursive helper function to store Topological\n    // Sort starting from all vertices one by one\n    for (int i = 0; i < V; i++)\n      if (visited[i] == false)\n        topologicalSortUtil(i, visited, Stack);\n\n    // Print contents of stack\n    while (Stack.empty() == false)\n    {\n        cout << Stack.top() << \" \";\n        Stack.pop();\n    }\n}\n\nint main()\n{\n    // Create a graph given in the above diagram\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n\n    cout << \"Following is a Topological Sort of the given graph n\";\n    g.topologicalSort();\n\n    return 0;\n}\n```\n\n### Java \n\n```java\nimport java.io.*;\nimport java.util.*;\n\n// This class represents a directed graph using adjacency\n// list representation\nclass Graph\n{\n    private int V;   // No. of vertices\n    private LinkedList<Integer> adj[]; // Adjacency List\n\n    //Constructor\n    Graph(int v)\n    {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i=0; i<v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    // Function to add an edge into the graph\n    void addEdge(int v,int w) { adj[v].add(w); }\n\n    // A recursive function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[],\n                             Stack stack)\n    {\n        // Mark the current node as visited.\n        visited[v] = true;\n        Integer i;\n\n        // Recur for all the vertices adjacent to this\n        // vertex\n        Iterator<Integer> it = adj[v].iterator();\n        while (it.hasNext())\n        {\n            i = it.next();\n            if (!visited[i])\n                topologicalSortUtil(i, visited, stack);\n        }\n\n        // Push current vertex to stack which stores result\n        stack.push(new Integer(v));\n    }\n\n    // The function to do Topological Sort. It uses\n    // recursive topologicalSortUtil()\n    void topologicalSort()\n    {\n        Stack stack = new Stack();\n\n        // Mark all the vertices as not visited\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        // Call the recursive helper function to store\n        // Topological Sort starting from all vertices\n        // one by one\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                topologicalSortUtil(i, visited, stack);\n\n        // Print contents of stack\n        while (stack.empty()==false)\n            System.out.print(stack.pop() + \" \");\n    }\n\n    public static void main(String args[])\n    {\n        // Create a graph given in the above diagram\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n\n        System.out.println(\"Following is a Topological \" +\n                           \"sort of the given graph\");\n        g.topologicalSort();\n    }\n}\n```","slug":"Algorithm/Data-Structure/topological-sort","published":1,"date":"2018-04-30T18:27:32.833Z","updated":"2019-03-23T03:38:05.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1a00eaqnn9lh5zb61p","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\"><strong>拓扑排序</strong> （Topological Sorting）</a></p>\n<blockquote>\n<p>在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。<br>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。</p>\n<ol>\n<li>每个顶点出现且只出现一次；</li>\n<li>若A在序列中排在B的前面，则在图中不存在从B到A的边。</li>\n</ol>\n<p>也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 &lt;i, j&gt; 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（<em>Activity on Vertex</em>），记作 <strong>AOV网络</strong>。</p>\n<p>在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。</p>\n<p>一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫<strong>拓扑排序</strong>。</p>\n<p>例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。<br><img src=\"https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg\" alt=\"img\"></p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>在AOV网络中选一个没有直接前驱的顶点v，并输出</li>\n<li>从图中删除该顶点，同时删去所有从顶点v发出的弧</li>\n<li>重复步骤1,2. 直到没有直接前驱的顶点全部输出</li>\n</ol>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><p>用二维list链表存储图的领接表</p>\n<ol>\n<li>建立入度为0的顶点栈</li>\n<li>当入度为0的顶点栈为空时，转到步骤6，否则步骤3</li>\n<li>从入度为0的顶点栈顶元素v出栈，并输出顶点v</li>\n<li>从AOV网络删去顶点v和所有顶点v发出的弧 &lt;v, j&gt;， 并将顶点 j 的入度 -1</li>\n<li>如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2</li>\n<li>如果输出顶点个数 &lt; AOV网络顶点数，则图中存在有向环</li>\n</ol>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><p>Topological Sorting via Depth First Search(DFS)<br>在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。</p>\n<p>在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。</p>\n<p>因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class to represent a graph</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency listsList</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prints a Topological Sort of the complete graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v’s list.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSortUtil(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], </span><br><span class=\"line\">                                <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">    visited[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recur for all the vertices adjacent to this vertex</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = adj[v].begin(); i != adj[v].end(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[*i])</span><br><span class=\"line\">            topologicalSortUtil(*i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">    Stack.push(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The function to do Topological Sort. It uses recursive </span></span><br><span class=\"line\"><span class=\"comment\">// topologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; Stack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the recursive helper function to store Topological</span></span><br><span class=\"line\">    <span class=\"comment\">// Sort starting from all vertices one by one</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        topologicalSortUtil(i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Stack.empty() == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Stack.top() &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        Stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Following is a Topological Sort of the given graph n\"</span>;</span><br><span class=\"line\">    g.topologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This class represents a directed graph using adjacency</span></span><br><span class=\"line\"><span class=\"comment\">// list representation</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> V;   <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Integer&gt; adj[]; <span class=\"comment\">// Adjacency List</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Constructor</span></span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        V = v;</span><br><span class=\"line\">        adj = <span class=\"keyword\">new</span> LinkedList[v];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;v; ++i)</span><br><span class=\"line\">            adj[i] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Function to add an edge into the graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> w)</span> </span>&#123; adj[v].add(w); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">boolean</span> visited[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             Stack stack)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">        visited[v] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        Integer i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Recur for all the vertices adjacent to this</span></span><br><span class=\"line\">        <span class=\"comment\">// vertex</span></span><br><span class=\"line\">        Iterator&lt;Integer&gt; it = adj[v].iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i = it.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[i])</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">        stack.push(<span class=\"keyword\">new</span> Integer(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The function to do Topological Sort. It uses</span></span><br><span class=\"line\">    <span class=\"comment\">// recursive topologicalSortUtil()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Stack stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> visited[] = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[V];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            visited[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Call the recursive helper function to store</span></span><br><span class=\"line\">        <span class=\"comment\">// Topological Sort starting from all vertices</span></span><br><span class=\"line\">        <span class=\"comment\">// one by one</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i] == <span class=\"keyword\">false</span>)</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stack.empty()==<span class=\"keyword\">false</span>)</span><br><span class=\"line\">            System.out.print(stack.pop() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">        Graph g = <span class=\"keyword\">new</span> Graph(<span class=\"number\">6</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Following is a Topological \"</span> +</span><br><span class=\"line\">                           <span class=\"string\">\"sort of the given graph\"</span>);</span><br><span class=\"line\">        g.topologicalSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p><a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\"><strong>拓扑排序</strong> （Topological Sorting）</a></p>\n<blockquote>\n<p>在计算机科学领域，有向图的拓扑排序或拓扑排序是其顶点的线性排序，使得对于从顶点u到顶点v的每个有向边uv，u在排序中都在v之前。例如，图形的顶点可以表示要执行的任务，并且边缘可以表示一个任务必须在另一个任务之前执行的约束；在这个应用中，拓扑排序只是一个有效的任务顺序。如果当图形没有定向循环，即如果它是有向无环图（Directed Acyclic Graph，即DAG），则拓扑排序是可能的。任何DAG具有至少一个拓扑排序，并且已知有些算法用于在线性时间内构建任何DAG的拓扑排序。<br>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。</p>\n<ol>\n<li>每个顶点出现且只出现一次；</li>\n<li>若A在序列中排在B的前面，则在图中不存在从B到A的边。</li>\n</ol>\n<p>也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</p>\n</blockquote>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般可以用有向图表示一个工程。在这种有向图中，用顶点表示活动，用弧 &lt;i, j&gt; 表示活动 i 必须在活动 j 开始之前完成。这种有向图叫做用顶点表示活动的网络（<em>Activity on Vertex</em>），记作 <strong>AOV网络</strong>。</p>\n<p>在AOV网络中不能存在有向回路，即有向环。因为如果出现了有向环，意味着某项活动要以自己的完成作为先决条件。显然这是不可能的。所以对给定的AOV网络，必须先判断它是否存在有向环。</p>\n<p>一种方法是对AOV网络构造它的拓扑有序序列。即将所有的顶点能够成一个线性有序的序列，使得AOV网络所有的前驱和后继关系得到满足，这种构造AOV网络全部顶点的拓扑有序序列的运算就叫<strong>拓扑排序</strong>。</p>\n<p>例如，下面有一个有向无环图，“5 4 2 3 1 0”是它的一个拓扑排序。一个有向无环图可以有多个拓扑排序，如下图的另一个拓扑排序为“4 5 2 3 1 0”，拓扑排序中的第一个顶点总是入度为0的顶点（即没有任何一条有向边以它为终点）。<br><img src=\"https://i2.wp.com/oq3r70t68.bkt.clouddn.com/20170706-Topological-Sorting.jpg\" alt=\"img\"></p>\n<h2 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h2><ol>\n<li>在AOV网络中选一个没有直接前驱的顶点v，并输出</li>\n<li>从图中删除该顶点，同时删去所有从顶点v发出的弧</li>\n<li>重复步骤1,2. 直到没有直接前驱的顶点全部输出</li>\n</ol>\n<h2 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h2><p>用二维list链表存储图的领接表</p>\n<ol>\n<li>建立入度为0的顶点栈</li>\n<li>当入度为0的顶点栈为空时，转到步骤6，否则步骤3</li>\n<li>从入度为0的顶点栈顶元素v出栈，并输出顶点v</li>\n<li>从AOV网络删去顶点v和所有顶点v发出的弧 &lt;v, j&gt;， 并将顶点 j 的入度 -1</li>\n<li>如果顶点 j 的入度 = 0，则将该顶点置入入度为0的顶点栈，转到步骤2</li>\n<li>如果输出顶点个数 &lt; AOV网络顶点数，则图中存在有向环</li>\n</ol>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><p>Topological Sorting via Depth First Search(DFS)<br>在DFS中，我们先打印一个顶点，然后递归的对它的邻接点调用DFS。但是在拓扑排序中，任何一个顶点总要先于它的所有邻接顶点打印，如上面的图，顶点5和4必须先于顶点0打印。所以拓扑排序和DFS是不同的，例如“5 2 3 1 0 4”是上图的一个DFS序列，但是这个序列并不是拓扑排序。</p>\n<p>在DFS中，我们从任意一个顶点出发，打印它然后对它的所有邻接顶点递归调用DFS。而在拓扑排序中，我们同样调用DFS过程，但是在递归调用DFS的过程中，我们不直接打印顶点，而是把顶点 push 到栈里，等到递归完成后，所有顶点就全都在栈里了。注意，在这个过程中当且仅当一个顶点的所有邻接顶点入栈后，才到当前顶点入栈，这就保证它们能满足拓扑排序的次序要求。所以最后栈里的内容，从栈顶到栈底，就是一个拓扑排序序列，我们不断出栈并打印它们即可。</p>\n<p>因为这个算法只是简单的调用了下DFS，并借助栈做为辅助，所以其复杂度和DFS一样是O(V+E)。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class to represent a graph</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> V;    <span class=\"comment\">// No. of vertices'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Pointer to an array containing adjacency listsList</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; *adj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> V);   <span class=\"comment\">// Constructor</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// function to add an edge to graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// prints a Topological Sort of the complete graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Graph::Graph(<span class=\"keyword\">int</span> V)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;V = V;</span><br><span class=\"line\">    adj = <span class=\"keyword\">new</span> <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;[V];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::addEdge(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> w)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    adj[v].push_back(w); <span class=\"comment\">// Add w to v’s list.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSortUtil(<span class=\"keyword\">int</span> v, <span class=\"keyword\">bool</span> visited[], </span><br><span class=\"line\">                                <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Stack)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">    visited[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recur for all the vertices adjacent to this vertex</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = adj[v].begin(); i != adj[v].end(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!visited[*i])</span><br><span class=\"line\">            topologicalSortUtil(*i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">    Stack.push(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The function to do Topological Sort. It uses recursive </span></span><br><span class=\"line\"><span class=\"comment\">// topologicalSortUtil()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Graph::topologicalSort()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; Stack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> *visited = <span class=\"keyword\">new</span> <span class=\"keyword\">bool</span>[V];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">        visited[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the recursive helper function to store Topological</span></span><br><span class=\"line\">    <span class=\"comment\">// Sort starting from all vertices one by one</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (visited[i] == <span class=\"literal\">false</span>)</span><br><span class=\"line\">        topologicalSortUtil(i, visited, Stack);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Stack.empty() == <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; Stack.top() &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        Stack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">    <span class=\"function\">Graph <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Following is a Topological Sort of the given graph n\"</span>;</span><br><span class=\"line\">    g.topologicalSort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This class represents a directed graph using adjacency</span></span><br><span class=\"line\"><span class=\"comment\">// list representation</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> V;   <span class=\"comment\">// No. of vertices</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LinkedList&lt;Integer&gt; adj[]; <span class=\"comment\">// Adjacency List</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Constructor</span></span><br><span class=\"line\">    Graph(<span class=\"keyword\">int</span> v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        V = v;</span><br><span class=\"line\">        adj = <span class=\"keyword\">new</span> LinkedList[v];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;v; ++i)</span><br><span class=\"line\">            adj[i] = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Function to add an edge into the graph</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEdge</span><span class=\"params\">(<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> w)</span> </span>&#123; adj[v].add(w); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A recursive function used by topologicalSort</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSortUtil</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">boolean</span> visited[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             Stack stack)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Mark the current node as visited.</span></span><br><span class=\"line\">        visited[v] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        Integer i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Recur for all the vertices adjacent to this</span></span><br><span class=\"line\">        <span class=\"comment\">// vertex</span></span><br><span class=\"line\">        Iterator&lt;Integer&gt; it = adj[v].iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            i = it.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[i])</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Push current vertex to stack which stores result</span></span><br><span class=\"line\">        stack.push(<span class=\"keyword\">new</span> Integer(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The function to do Topological Sort. It uses</span></span><br><span class=\"line\">    <span class=\"comment\">// recursive topologicalSortUtil()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topologicalSort</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Stack stack = <span class=\"keyword\">new</span> Stack();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Mark all the vertices as not visited</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> visited[] = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[V];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            visited[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Call the recursive helper function to store</span></span><br><span class=\"line\">        <span class=\"comment\">// Topological Sort starting from all vertices</span></span><br><span class=\"line\">        <span class=\"comment\">// one by one</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; V; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i] == <span class=\"keyword\">false</span>)</span><br><span class=\"line\">                topologicalSortUtil(i, visited, stack);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Print contents of stack</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (stack.empty()==<span class=\"keyword\">false</span>)</span><br><span class=\"line\">            System.out.print(stack.pop() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Create a graph given in the above diagram</span></span><br><span class=\"line\">        Graph g = <span class=\"keyword\">new</span> Graph(<span class=\"number\">6</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">5</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        g.addEdge(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Following is a Topological \"</span> +</span><br><span class=\"line\">                           <span class=\"string\">\"sort of the given graph\"</span>);</span><br><span class=\"line\">        g.topologicalSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"LeetCode 线性表相关题目与解决","_content":"\n# 线性表\n\n\n\n## 数组\n\n### **LeetCode-p1 Two Sum**\n\n**Description:**\n\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\n\n**Analysis:**\n\n- Brute-force \n- HashMap\n\n**Implements:**\n\n- Cpp\n\n~~~cpp\n// Brute-force Solution\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        for(int i = 0; i < nums.size(); ++i) {\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[j] == target - nums[i]) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n~~~\n\n- Java\n\n~~~java\n// Brute-force Solution\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                if(nums[j] == target - nums[i])\n                    return new int[]{i,j};\n            }\n        }\n        throw new IllegalArgumentException(\"No solution\");\n    }\n}\n\n// HashMap Solution\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (map.containsKey(target - nums[i])) {\n                res[0] = i;\n                res[1] = map.getKey(target - nums[i]);\n            }\n            map.put(nums[i], i);\n        }\n        \n        return res;\n    }\n}\n~~~\n\n\n\n### **LeetCode-P4 Median of Two Sorted Arrays**\n\n**Description:**\n\nThere are two sorted arrays **nums1** and **nums2** of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nYou may assume **nums1** and **nums2** cannot be both empty.\n\n**Analysis:**\n\n- Merge Sort Solution\n- find K-th position \n\n**Implements:**\n\n~~~java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] sorted = mergeSort(nums1, nums2);\n        \n        if (sorted.length % 2 == 1) {\n            return sorted[sorted.length/2] / 1.0;\n        } else {\n            return (sorted[(sorted.length-1)/2] + sorted[sorted.length/2]) / 2.0;    \n        }   \n    }\n    \n    public int[] mergeSort(int[] nums1, int[] nums2) {\n        int m = nums1.length, n = nums2.length;\n        int total = m + n;\n        \n        int[] res = new int[total];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < m && j < n) {\n            res[k++] = (nums1[i] < nums2[j]) ? nums1[i++] : nums2[j++];\n        }\n        \n        for (; i < m; ++i) {\n            res[k++] = nums1[i];\n        }\n        \n        for (; j < n; ++j) {\n            res[k++] = nums2[j];\n        }\n        \n        return res;\n    }\n}\n~~~\n\n\n\n### **LeetCode-P11 Container With Most Water**\n\n**Description:**\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note:** You may not slant the container and *n* is at least 2.\n\n**Analysis:**\n\n- Two Pointers\n\n**Implements:**\n\n~~~java\nclass Solution {\n    public int maxArea(int[] height) {\n        int n = height.length;\n        int left = 0, right = n - 1, maxArea = 0;\n        \n        while (left < right) {\n            int w = right - left;\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, w * h);\n            // 高度较小的一侧决定maxArea\n            if (height[left] >= height[right]) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n        \n        return maxArea;\n    }\n}\n\nclass Solution {\n\tpublic int maxArea(int[] height) {\n\t\t int maxArea = 0;\n        \n\t\t for(int left = 0, right = height.length - 1; left < right; ){\n\t\t\t int h = (height[left] < height[right]) ? height[left++] : height[right--];\n\t\t\t maxArea = Math.max(maxArea, (right-left+1) * h);\n\t\t }\n\t\t \n        return maxArea;\n\t }\n}\n~~~\n\n\n\n### LeetCode-P15  3Sum\n\n**Description:**\n\nGiven an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**\n\nThe solution set must not contain duplicate triplets.\n\n**Analysis:**\n\n- Two Pointer\n\n**Implements:**\n\n~~~java\n    public List<List<Integer>> threeSum(int[] num) {\n        Arrays.sort(num);\n        List<List<Integer>> res = new LinkedList<>(); \n        for (int i = 0; i < num.length-2; i++) {\n            if (i == 0 || (i > 0 && num[i] != num[i-1])) {\n                int lo = i+1, hi = num.length-1, sum = 0 - num[i];\n                while (lo < hi) {\n                    if (num[lo] + num[hi] == sum) {\n                        res.add(Arrays.asList(num[i], num[lo], num[hi]));\n                        do lo++; while (lo < hi && num[lo] == num[lo-1]);\n                        do hi--; while (lo < hi && num[hi] == num[hi+1]);\n                    } else if (num[lo] + num[hi] < sum) lo++;\n                    else hi--;\n               }\n            }\n        }\n        return res;\n    }\n~~~\n\n**Related Problem:**\n\n- LeetCode-P16 3Sum Closest\n\n\n\n### **LeetCode-P16 3Sum Closest**\n\n**Description:**\n\nGiven an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n**Analyse:**\n\n- Brute-Force\n- Two Pointers\n\n**Implements:**\n\n```java\n// Brute-Force\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        int min = Integer.MAX_VALUE, n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n - 2; ++i) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = nums[i] + nums[j] + nums[k];\n                    if (Math.abs(target - sum) < min) {\n                        min = Math.abs(target - sum);\n                        res = sum;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n// Two-Pointers\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int res = nums[0] + nums[1] + nums[nums.length - 1];\n        for (int i = 0; i < nums.length - 2; ++i) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\n                int lo = i + 1, hi = nums.length - 1;\n                while (lo < hi) {\n                    int sum = nums[i] + nums[lo] + nums[hi];\n                    if (sum < target) \n                        do lo++; while (lo < hi && nums[lo] == nums[lo-1]);\n                    else if (sum > target) \n                        do hi--; while (lo < hi && nums[hi] == nums[hi+1]);\n                    else \n                        return sum;\n                    res = (Math.abs(target-sum) < Math.abs(target-res)) ? sum : res;\n                } \n            }\n        }   \n        return res;\n    }\n}\n```\n\n**Related Problem:**\n\n- LeetCode-P15 3Sum\n\n\n\n### **LeetCode-P26 Remove Duplicates from Sorted Array**\n\n**Description:**\n\nGiven a sorted array, remove the duplicates in place such that each element appear only once\nand return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example, Given input array A = [1,1,2],\nYour function should return length = 2, and A is now [1,2].\n\n**Analysis:**\n\nNone\n\n**Implements:**\n\n~~~cpp\n// Time complexity: O(n) , Space complexity: O(1)\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        int index = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[index] != nums[i])\n            nums[++index] = nums[i];\n        }\n        return index + 1;\n    }\n};\n~~~\n\n**Related Problems**\n\n- \n\n\n\n\n\n## 单链表\n\n","source":"_posts/Algorithm/LeetCode/leetcode-linear-list.md","raw":"---\ntitle: LeetCode 线性表相关题目与解决\ncategories:\n  - Algorithm\n  - LeetCode\ntags:\n  - algorithm\n  - linear-list\n  - array\n---\n\n# 线性表\n\n\n\n## 数组\n\n### **LeetCode-p1 Two Sum**\n\n**Description:**\n\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\n\n**Analysis:**\n\n- Brute-force \n- HashMap\n\n**Implements:**\n\n- Cpp\n\n~~~cpp\n// Brute-force Solution\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> res;\n        for(int i = 0; i < nums.size(); ++i) {\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[j] == target - nums[i]) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n~~~\n\n- Java\n\n~~~java\n// Brute-force Solution\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                if(nums[j] == target - nums[i])\n                    return new int[]{i,j};\n            }\n        }\n        throw new IllegalArgumentException(\"No solution\");\n    }\n}\n\n// HashMap Solution\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (map.containsKey(target - nums[i])) {\n                res[0] = i;\n                res[1] = map.getKey(target - nums[i]);\n            }\n            map.put(nums[i], i);\n        }\n        \n        return res;\n    }\n}\n~~~\n\n\n\n### **LeetCode-P4 Median of Two Sorted Arrays**\n\n**Description:**\n\nThere are two sorted arrays **nums1** and **nums2** of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nYou may assume **nums1** and **nums2** cannot be both empty.\n\n**Analysis:**\n\n- Merge Sort Solution\n- find K-th position \n\n**Implements:**\n\n~~~java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] sorted = mergeSort(nums1, nums2);\n        \n        if (sorted.length % 2 == 1) {\n            return sorted[sorted.length/2] / 1.0;\n        } else {\n            return (sorted[(sorted.length-1)/2] + sorted[sorted.length/2]) / 2.0;    \n        }   \n    }\n    \n    public int[] mergeSort(int[] nums1, int[] nums2) {\n        int m = nums1.length, n = nums2.length;\n        int total = m + n;\n        \n        int[] res = new int[total];\n        int i = 0, j = 0, k = 0;\n        \n        while (i < m && j < n) {\n            res[k++] = (nums1[i] < nums2[j]) ? nums1[i++] : nums2[j++];\n        }\n        \n        for (; i < m; ++i) {\n            res[k++] = nums1[i];\n        }\n        \n        for (; j < n; ++j) {\n            res[k++] = nums2[j];\n        }\n        \n        return res;\n    }\n}\n~~~\n\n\n\n### **LeetCode-P11 Container With Most Water**\n\n**Description:**\n\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\n**Note:** You may not slant the container and *n* is at least 2.\n\n**Analysis:**\n\n- Two Pointers\n\n**Implements:**\n\n~~~java\nclass Solution {\n    public int maxArea(int[] height) {\n        int n = height.length;\n        int left = 0, right = n - 1, maxArea = 0;\n        \n        while (left < right) {\n            int w = right - left;\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, w * h);\n            // 高度较小的一侧决定maxArea\n            if (height[left] >= height[right]) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n        \n        return maxArea;\n    }\n}\n\nclass Solution {\n\tpublic int maxArea(int[] height) {\n\t\t int maxArea = 0;\n        \n\t\t for(int left = 0, right = height.length - 1; left < right; ){\n\t\t\t int h = (height[left] < height[right]) ? height[left++] : height[right--];\n\t\t\t maxArea = Math.max(maxArea, (right-left+1) * h);\n\t\t }\n\t\t \n        return maxArea;\n\t }\n}\n~~~\n\n\n\n### LeetCode-P15  3Sum\n\n**Description:**\n\nGiven an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.\n\n**Note:**\n\nThe solution set must not contain duplicate triplets.\n\n**Analysis:**\n\n- Two Pointer\n\n**Implements:**\n\n~~~java\n    public List<List<Integer>> threeSum(int[] num) {\n        Arrays.sort(num);\n        List<List<Integer>> res = new LinkedList<>(); \n        for (int i = 0; i < num.length-2; i++) {\n            if (i == 0 || (i > 0 && num[i] != num[i-1])) {\n                int lo = i+1, hi = num.length-1, sum = 0 - num[i];\n                while (lo < hi) {\n                    if (num[lo] + num[hi] == sum) {\n                        res.add(Arrays.asList(num[i], num[lo], num[hi]));\n                        do lo++; while (lo < hi && num[lo] == num[lo-1]);\n                        do hi--; while (lo < hi && num[hi] == num[hi+1]);\n                    } else if (num[lo] + num[hi] < sum) lo++;\n                    else hi--;\n               }\n            }\n        }\n        return res;\n    }\n~~~\n\n**Related Problem:**\n\n- LeetCode-P16 3Sum Closest\n\n\n\n### **LeetCode-P16 3Sum Closest**\n\n**Description:**\n\nGiven an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n**Analyse:**\n\n- Brute-Force\n- Two Pointers\n\n**Implements:**\n\n```java\n// Brute-Force\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        int min = Integer.MAX_VALUE, n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n - 2; ++i) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = nums[i] + nums[j] + nums[k];\n                    if (Math.abs(target - sum) < min) {\n                        min = Math.abs(target - sum);\n                        res = sum;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n}\n\n// Two-Pointers\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int res = nums[0] + nums[1] + nums[nums.length - 1];\n        for (int i = 0; i < nums.length - 2; ++i) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i-1])) {\n                int lo = i + 1, hi = nums.length - 1;\n                while (lo < hi) {\n                    int sum = nums[i] + nums[lo] + nums[hi];\n                    if (sum < target) \n                        do lo++; while (lo < hi && nums[lo] == nums[lo-1]);\n                    else if (sum > target) \n                        do hi--; while (lo < hi && nums[hi] == nums[hi+1]);\n                    else \n                        return sum;\n                    res = (Math.abs(target-sum) < Math.abs(target-res)) ? sum : res;\n                } \n            }\n        }   \n        return res;\n    }\n}\n```\n\n**Related Problem:**\n\n- LeetCode-P15 3Sum\n\n\n\n### **LeetCode-P26 Remove Duplicates from Sorted Array**\n\n**Description:**\n\nGiven a sorted array, remove the duplicates in place such that each element appear only once\nand return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example, Given input array A = [1,1,2],\nYour function should return length = 2, and A is now [1,2].\n\n**Analysis:**\n\nNone\n\n**Implements:**\n\n~~~cpp\n// Time complexity: O(n) , Space complexity: O(1)\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        int index = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[index] != nums[i])\n            nums[++index] = nums[i];\n        }\n        return index + 1;\n    }\n};\n~~~\n\n**Related Problems**\n\n- \n\n\n\n\n\n## 单链表\n\n","slug":"Algorithm/LeetCode/leetcode-linear-list","published":1,"date":"2019-01-16T07:56:22.336Z","updated":"2019-03-23T03:36:10.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1d00ecqnn9xj41epul","content":"<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"LeetCode-p1-Two-Sum\"><a href=\"#LeetCode-p1-Two-Sum\" class=\"headerlink\" title=\"LeetCode-p1 Two Sum\"></a><strong>LeetCode-p1 Two Sum</strong></h3><p><strong>Description:</strong></p>\n<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Brute-force </li>\n<li>HashMap</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<ul>\n<li>Cpp</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-force Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == target - nums[i]) &#123;</span><br><span class=\"line\">                    res.push_back(i);</span><br><span class=\"line\">                    res.push_back(j);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-force Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == target - nums[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i,j&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No solution\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HashMap Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = map.getKey(target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P4-Median-of-Two-Sorted-Arrays\"><a href=\"#LeetCode-P4-Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"LeetCode-P4 Median of Two Sorted Arrays\"></a><strong>LeetCode-P4 Median of Two Sorted Arrays</strong></h3><p><strong>Description:</strong></p>\n<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Merge Sort Solution</li>\n<li>find K-th position </li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] sorted = mergeSort(nums1, nums2);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sorted.length % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sorted[sorted.length/<span class=\"number\">2</span>] / <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (sorted[(sorted.length-<span class=\"number\">1</span>)/<span class=\"number\">2</span>] + sorted[sorted.length/<span class=\"number\">2</span>]) / <span class=\"number\">2.0</span>;    </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] mergeSort(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = nums1.length, n = nums2.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = m + n;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[total];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            res[k++] = (nums1[i] &lt; nums2[j]) ? nums1[i++] : nums2[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            res[k++] = nums1[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            res[k++] = nums2[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P11-Container-With-Most-Water\"><a href=\"#LeetCode-P11-Container-With-Most-Water\" class=\"headerlink\" title=\"LeetCode-P11 Container With Most Water\"></a><strong>LeetCode-P11 Container With Most Water</strong></h3><p><strong>Description:</strong></p>\n<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Two Pointers</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>, maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> w = right - left;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = Math.min(height[left], height[right]);</span><br><span class=\"line\">            maxArea = Math.max(maxArea, w * h);</span><br><span class=\"line\">            <span class=\"comment\">// 高度较小的一侧决定maxArea</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &gt;= height[right]) &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = height.length - <span class=\"number\">1</span>; left &lt; right; )&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> h = (height[left] &lt; height[right]) ? height[left++] : height[right--];</span><br><span class=\"line\">\t\t\t maxArea = Math.max(maxArea, (right-left+<span class=\"number\">1</span>) * h);</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P15-3Sum\"><a href=\"#LeetCode-P15-3Sum\" class=\"headerlink\" title=\"LeetCode-P15  3Sum\"></a>LeetCode-P15  3Sum</h3><p><strong>Description:</strong></p>\n<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate triplets.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Two Pointer</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] num) &#123;</span><br><span class=\"line\">    Arrays.sort(num);</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> LinkedList&lt;&gt;(); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num.length-<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; num[i] != num[i-<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> lo = i+<span class=\"number\">1</span>, hi = num.length-<span class=\"number\">1</span>, sum = <span class=\"number\">0</span> - num[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num[lo] + num[hi] == sum) &#123;</span><br><span class=\"line\">                    res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> lo++; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; num[lo] == num[lo-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> hi--; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; num[hi] == num[hi+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> hi--;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problem:</strong></p>\n<ul>\n<li>LeetCode-P16 3Sum Closest</li>\n</ul>\n<h3 id=\"LeetCode-P16-3Sum-Closest\"><a href=\"#LeetCode-P16-3Sum-Closest\" class=\"headerlink\" title=\"LeetCode-P16 3Sum Closest\"></a><strong>LeetCode-P16 3Sum Closest</strong></h3><p><strong>Description:</strong></p>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n<p><strong>Analyse:</strong></p>\n<ul>\n<li>Brute-Force</li>\n<li>Two Pointers</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-Force</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE, n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n - <span class=\"number\">1</span>; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j + <span class=\"number\">1</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (Math.abs(target - sum) &lt; min) &#123;</span><br><span class=\"line\">                        min = Math.abs(target - sum);</span><br><span class=\"line\">                        res = sum;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two-Pointers</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[nums.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] != nums[i-<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> lo = i + <span class=\"number\">1</span>, hi = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (sum &lt; target) </span><br><span class=\"line\">                        <span class=\"keyword\">do</span> lo++; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) </span><br><span class=\"line\">                        <span class=\"keyword\">do</span> hi--; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> </span><br><span class=\"line\">                        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">                    res = (Math.abs(target-sum) &lt; Math.abs(target-res)) ? sum : res;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problem:</strong></p>\n<ul>\n<li>LeetCode-P15 3Sum</li>\n</ul>\n<h3 id=\"LeetCode-P26-Remove-Duplicates-from-Sorted-Array\"><a href=\"#LeetCode-P26-Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"LeetCode-P26 Remove Duplicates from Sorted Array\"></a><strong>LeetCode-P26 Remove Duplicates from Sorted Array</strong></h3><p><strong>Description:</strong></p>\n<p>Given a sorted array, remove the duplicates in place such that each element appear only once<br>and return the new length.<br>Do not allocate extra space for another array, you must do this in place with constant memory.<br>For example, Given input array A = [1,1,2],<br>Your function should return length = 2, and A is now [1,2].</p>\n<p><strong>Analysis:</strong></p>\n<p>None</p>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Time complexity: O(n) , Space complexity: O(1)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[index] != nums[i])</span><br><span class=\"line\">            nums[++index] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problems</strong></p>\n<ul>\n<li></li>\n</ul>\n<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"LeetCode-p1-Two-Sum\"><a href=\"#LeetCode-p1-Two-Sum\" class=\"headerlink\" title=\"LeetCode-p1 Two Sum\"></a><strong>LeetCode-p1 Two Sum</strong></h3><p><strong>Description:</strong></p>\n<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Brute-force </li>\n<li>HashMap</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<ul>\n<li>Cpp</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-force Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == target - nums[i]) &#123;</span><br><span class=\"line\">                    res.push_back(i);</span><br><span class=\"line\">                    res.push_back(j);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-force Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[j] == target - nums[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i,j&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No solution\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HashMap Solution</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = map.getKey(target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P4-Median-of-Two-Sorted-Arrays\"><a href=\"#LeetCode-P4-Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"LeetCode-P4 Median of Two Sorted Arrays\"></a><strong>LeetCode-P4 Median of Two Sorted Arrays</strong></h3><p><strong>Description:</strong></p>\n<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Merge Sort Solution</li>\n<li>find K-th position </li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] sorted = mergeSort(nums1, nums2);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sorted.length % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sorted[sorted.length/<span class=\"number\">2</span>] / <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (sorted[(sorted.length-<span class=\"number\">1</span>)/<span class=\"number\">2</span>] + sorted[sorted.length/<span class=\"number\">2</span>]) / <span class=\"number\">2.0</span>;    </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] mergeSort(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = nums1.length, n = nums2.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = m + n;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[total];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            res[k++] = (nums1[i] &lt; nums2[j]) ? nums1[i++] : nums2[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            res[k++] = nums1[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            res[k++] = nums2[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P11-Container-With-Most-Water\"><a href=\"#LeetCode-P11-Container-With-Most-Water\" class=\"headerlink\" title=\"LeetCode-P11 Container With Most Water\"></a><strong>LeetCode-P11 Container With Most Water</strong></h3><p><strong>Description:</strong></p>\n<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Two Pointers</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = height.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>, maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> w = right - left;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = Math.min(height[left], height[right]);</span><br><span class=\"line\">            maxArea = Math.max(maxArea, w * h);</span><br><span class=\"line\">            <span class=\"comment\">// 高度较小的一侧决定maxArea</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[left] &gt;= height[right]) &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> maxArea = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = height.length - <span class=\"number\">1</span>; left &lt; right; )&#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">int</span> h = (height[left] &lt; height[right]) ? height[left++] : height[right--];</span><br><span class=\"line\">\t\t\t maxArea = Math.max(maxArea, (right-left+<span class=\"number\">1</span>) * h);</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxArea;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LeetCode-P15-3Sum\"><a href=\"#LeetCode-P15-3Sum\" class=\"headerlink\" title=\"LeetCode-P15  3Sum\"></a>LeetCode-P15  3Sum</h3><p><strong>Description:</strong></p>\n<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate triplets.</p>\n<p><strong>Analysis:</strong></p>\n<ul>\n<li>Two Pointer</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class=\"keyword\">int</span>[] num) &#123;</span><br><span class=\"line\">    Arrays.sort(num);</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> LinkedList&lt;&gt;(); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num.length-<span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; num[i] != num[i-<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> lo = i+<span class=\"number\">1</span>, hi = num.length-<span class=\"number\">1</span>, sum = <span class=\"number\">0</span> - num[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num[lo] + num[hi] == sum) &#123;</span><br><span class=\"line\">                    res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> lo++; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; num[lo] == num[lo-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> hi--; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; num[hi] == num[hi+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> hi--;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problem:</strong></p>\n<ul>\n<li>LeetCode-P16 3Sum Closest</li>\n</ul>\n<h3 id=\"LeetCode-P16-3Sum-Closest\"><a href=\"#LeetCode-P16-3Sum-Closest\" class=\"headerlink\" title=\"LeetCode-P16 3Sum Closest\"></a><strong>LeetCode-P16 3Sum Closest</strong></h3><p><strong>Description:</strong></p>\n<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n<p><strong>Analyse:</strong></p>\n<ul>\n<li>Brute-Force</li>\n<li>Two Pointers</li>\n</ul>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Brute-Force</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = Integer.MAX_VALUE, n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n - <span class=\"number\">1</span>; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = j + <span class=\"number\">1</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (Math.abs(target - sum) &lt; min) &#123;</span><br><span class=\"line\">                        min = Math.abs(target - sum);</span><br><span class=\"line\">                        res = sum;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two-Pointers</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">threeSumClosest</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] + nums[nums.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] != nums[i-<span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> lo = i + <span class=\"number\">1</span>, hi = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> sum = nums[i] + nums[lo] + nums[hi];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (sum &lt; target) </span><br><span class=\"line\">                        <span class=\"keyword\">do</span> lo++; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo-<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) </span><br><span class=\"line\">                        <span class=\"keyword\">do</span> hi--; <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi+<span class=\"number\">1</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> </span><br><span class=\"line\">                        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">                    res = (Math.abs(target-sum) &lt; Math.abs(target-res)) ? sum : res;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problem:</strong></p>\n<ul>\n<li>LeetCode-P15 3Sum</li>\n</ul>\n<h3 id=\"LeetCode-P26-Remove-Duplicates-from-Sorted-Array\"><a href=\"#LeetCode-P26-Remove-Duplicates-from-Sorted-Array\" class=\"headerlink\" title=\"LeetCode-P26 Remove Duplicates from Sorted Array\"></a><strong>LeetCode-P26 Remove Duplicates from Sorted Array</strong></h3><p><strong>Description:</strong></p>\n<p>Given a sorted array, remove the duplicates in place such that each element appear only once<br>and return the new length.<br>Do not allocate extra space for another array, you must do this in place with constant memory.<br>For example, Given input array A = [1,1,2],<br>Your function should return length = 2, and A is now [1,2].</p>\n<p><strong>Analysis:</strong></p>\n<p>None</p>\n<p><strong>Implements:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Time complexity: O(n) , Space complexity: O(1)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.empty()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[index] != nums[i])</span><br><span class=\"line\">            nums[++index] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> index + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>Related Problems</strong></p>\n<ul>\n<li></li>\n</ul>\n<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2>"},{"title":"Java常见问题汇总-1","_content":"## 一 为什么 Java 中只有值传递？\n\n\n首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\n\n**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**\n\n**下面通过 3 个例子来给大家说明**\n\n### example 1 \n\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果：**\n\n```\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析：**\n\n![example 1 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\n\n### example 2\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(arr[0]);\n\t\tchange(arr);\n\t\tSystem.out.println(arr[0]);\n\t}\n\n\tpublic static void change(int[] array) {\n\t\t// 将数组的第一个元素变为0\n\t\tarray[0] = 0;\n\t}\n```\n\n**结果：**\n\n```\n1\n0\n```\n\n**解析：**\n\n![example 2](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\n**很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。**\n\n\n### example 3\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student(\"小张\");\n\t\tStudent s2 = new Student(\"小李\");\n\t\tTest.swap(s1, s2);\n\t\tSystem.out.println(\"s1:\" + s1.getName());\n\t\tSystem.out.println(\"s2:\" + s2.getName());\n\t}\n\n\tpublic static void swap(Student x, Student y) {\n\t\tStudent temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t\tSystem.out.println(\"x:\" + x.getName());\n\t\tSystem.out.println(\"y:\" + y.getName());\n\t}\n}\n```\n\n**结果：**\n\n```\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析：**\n\n交换之前：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg)\n\n交换之后：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg)\n\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n### 总结\n\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。\n\n下面再总结一下Java中方法参数的使用情况：\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n\n### 参考：\n\n《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节\n\n## 二  ==与equals(重要)\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n-  情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。\n- 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。\n\n\n**举个例子：**\n\n```java\npublic class test1 {\n    public static void main(String[] args) {\n        String a = new String(\"ab\"); // a 为一个引用\n        String b = new String(\"ab\"); // b为另一个引用,对象的内容一样\n        String aa = \"ab\"; // 放在常量池中\n        String bb = \"ab\"; // 从常量池中查找\n        if (aa == bb) // true\n            System.out.println(\"aa==bb\");\n        if (a == b) // false，非同一对象\n            System.out.println(\"a==b\");\n        if (a.equals(b)) // true\n            System.out.println(\"aEQb\");\n        if (42 == 42.0) { // true\n            System.out.println(\"true\");\n        }\n    }\n}\n```\n\n**说明：**\n\n- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。\n- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。\n\n\n\n## 三  hashCode与equals（重要）\n\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\n\n### hashCode（）介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。\n\n```java\n    /**\n     * Returns a hash code value for the object. This method is\n     * supported for the benefit of hash tables such as those provided by\n     * {@link java.util.HashMap}.\n     * <p>\n     * As much as is reasonably practical, the hashCode method defined by\n     * class {@code Object} does return distinct integers for distinct\n     * objects. (This is typically implemented by converting the internal\n     * address of the object into an integer, but this implementation\n     * technique is not required by the\n     * Java&trade; programming language.)\n     *\n     * @return  a hash code value for this object.\n     * @see     java.lang.Object#equals(java.lang.Object)\n     * @see     java.lang.System#identityHashCode\n     */\n    public native int hashCode();\n```\n\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n### 为什么要有hashCode\n\n\n**我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：**\n\n当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。\n\n\n\n### hashCode（）与equals（）的相关规定\n\n1. 如果两个对象相等，则hashcode一定也是相同的\n2. 两个对象相等,对两个对象分别调用equals方法都返回true\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\n4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**\n5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n### 为什么两个对象有相同的hashcode值，它们也不一定是相等的？\n\n在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。\n\n因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 \n\n我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。\n\n参考：\n\n[https://blog.csdn.net/zhzhao999/article/details/53449504](https://blog.csdn.net/zhzhao999/article/details/53449504)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/Eason-S/p/5524837.html](https://www.cnblogs.com/Eason-S/p/5524837.html)\n\n","source":"_posts/Java/Summary/common-questions.md","raw":"---\ntitle: Java常见问题汇总-1\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n## 一 为什么 Java 中只有值传递？\n\n\n首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。**按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\n\n**Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**\n\n**下面通过 3 个例子来给大家说明**\n\n### example 1 \n\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果：**\n\n```\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析：**\n\n![example 1 ](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\n\n### example 2\n\n```java\n\tpublic static void main(String[] args) {\n\t\tint[] arr = { 1, 2, 3, 4, 5 };\n\t\tSystem.out.println(arr[0]);\n\t\tchange(arr);\n\t\tSystem.out.println(arr[0]);\n\t}\n\n\tpublic static void change(int[] array) {\n\t\t// 将数组的第一个元素变为0\n\t\tarray[0] = 0;\n\t}\n```\n\n**结果：**\n\n```\n1\n0\n```\n\n**解析：**\n\n![example 2](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\n**很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。**\n\n\n### example 3\n\n```java\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tStudent s1 = new Student(\"小张\");\n\t\tStudent s2 = new Student(\"小李\");\n\t\tTest.swap(s1, s2);\n\t\tSystem.out.println(\"s1:\" + s1.getName());\n\t\tSystem.out.println(\"s2:\" + s2.getName());\n\t}\n\n\tpublic static void swap(Student x, Student y) {\n\t\tStudent temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t\tSystem.out.println(\"x:\" + x.getName());\n\t\tSystem.out.println(\"y:\" + y.getName());\n\t}\n}\n```\n\n**结果：**\n\n```\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析：**\n\n交换之前：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg)\n\n交换之后：\n\n![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg)\n\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n### 总结\n\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按\n值传递的。\n\n下面再总结一下Java中方法参数的使用情况：\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n\n### 参考：\n\n《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节\n\n## 二  ==与equals(重要)\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n-  情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。\n- 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。\n\n\n**举个例子：**\n\n```java\npublic class test1 {\n    public static void main(String[] args) {\n        String a = new String(\"ab\"); // a 为一个引用\n        String b = new String(\"ab\"); // b为另一个引用,对象的内容一样\n        String aa = \"ab\"; // 放在常量池中\n        String bb = \"ab\"; // 从常量池中查找\n        if (aa == bb) // true\n            System.out.println(\"aa==bb\");\n        if (a == b) // false，非同一对象\n            System.out.println(\"a==b\");\n        if (a.equals(b)) // true\n            System.out.println(\"aEQb\");\n        if (42 == 42.0) { // true\n            System.out.println(\"true\");\n        }\n    }\n}\n```\n\n**说明：**\n\n- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。\n- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。\n\n\n\n## 三  hashCode与equals（重要）\n\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\n\n### hashCode（）介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。\n\n```java\n    /**\n     * Returns a hash code value for the object. This method is\n     * supported for the benefit of hash tables such as those provided by\n     * {@link java.util.HashMap}.\n     * <p>\n     * As much as is reasonably practical, the hashCode method defined by\n     * class {@code Object} does return distinct integers for distinct\n     * objects. (This is typically implemented by converting the internal\n     * address of the object into an integer, but this implementation\n     * technique is not required by the\n     * Java&trade; programming language.)\n     *\n     * @return  a hash code value for this object.\n     * @see     java.lang.Object#equals(java.lang.Object)\n     * @see     java.lang.System#identityHashCode\n     */\n    public native int hashCode();\n```\n\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n### 为什么要有hashCode\n\n\n**我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：**\n\n当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。\n\n\n\n### hashCode（）与equals（）的相关规定\n\n1. 如果两个对象相等，则hashcode一定也是相同的\n2. 两个对象相等,对两个对象分别调用equals方法都返回true\n3. 两个对象有相同的hashcode值，它们也不一定是相等的\n4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**\n5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n### 为什么两个对象有相同的hashcode值，它们也不一定是相等的？\n\n在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。\n\n因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 \n\n我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。\n\n参考：\n\n[https://blog.csdn.net/zhzhao999/article/details/53449504](https://blog.csdn.net/zhzhao999/article/details/53449504)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/skywang12345/p/3324958.html](https://www.cnblogs.com/skywang12345/p/3324958.html)\n\n[https://www.cnblogs.com/Eason-S/p/5524837.html](https://www.cnblogs.com/Eason-S/p/5524837.html)\n\n","slug":"Java/Summary/common-questions","published":1,"date":"2019-03-22T10:16:45.422Z","updated":"2019-03-24T06:08:42.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1h00eeqnn9iaopocwj","content":"<h2 id=\"一-为什么-Java-中只有值传递？\"><a href=\"#一-为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"一 为什么 Java 中只有值传递？\"></a>一 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>\n<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>\n<p><strong>下面通过 3 个例子来给大家说明</strong></p>\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example 1\"></a>example 1</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num1 = \"</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num2 = \"</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"a = \"</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"b = \"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 10</span><br><span class=\"line\">num1 = 10</span><br><span class=\"line\">num2 = 20</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg\" alt=\"example 1 \"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example 2\"></a>example 2</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tchange(arr);</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">\tarray[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg\" alt=\"example 2\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example 3\"></a>example 3</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tStudent s1 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小张\"</span>);</span><br><span class=\"line\">\t\tStudent s2 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">\t\tTest.swap(s1, s2);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s1:\"</span> + s1.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s2:\"</span> + s2.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Student x, Student y)</span> </span>&#123;</span><br><span class=\"line\">\t\tStudent temp = x;</span><br><span class=\"line\">\t\tx = y;</span><br><span class=\"line\">\t\ty = temp;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"x:\"</span> + x.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"y:\"</span> + y.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p>交换之前：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg\" alt></p>\n<p>交换之后：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg\" alt></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>\n<p>下面再总结一下Java中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>\n<h2 id=\"二-与equals-重要\"><a href=\"#二-与equals-重要\" class=\"headerlink\" title=\"二  ==与equals(重要)\"></a>二  ==与equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<ul>\n<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>\n<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// a 为一个引用</span></span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// b为另一个引用,对象的内容一样</span></span><br><span class=\"line\">        String aa = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 放在常量池中</span></span><br><span class=\"line\">        String bb = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 从常量池中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aa == bb) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aa==bb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a == b) <span class=\"comment\">// false，非同一对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"a==b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.equals(b)) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aEQb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">42</span> == <span class=\"number\">42.0</span>) &#123; <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong></p>\n<ul>\n<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>\n<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>\n</ul>\n<h2 id=\"三-hashCode与equals（重要）\"><a href=\"#三-hashCode与equals（重要）\" class=\"headerlink\" title=\"三  hashCode与equals（重要）\"></a>三  hashCode与equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>\n<h3 id=\"hashCode（）介绍\"><a href=\"#hashCode（）介绍\" class=\"headerlink\" title=\"hashCode（）介绍\"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code value for the object. This method is</span></span><br><span class=\"line\"><span class=\"comment\"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> java.util.HashMap&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class=\"line\"><span class=\"comment\"> * class &#123;<span class=\"doctag\">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class=\"line\"><span class=\"comment\"> * objects. (This is typically implemented by converting the internal</span></span><br><span class=\"line\"><span class=\"comment\"> * address of the object into an integer, but this implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * technique is not required by the</span></span><br><span class=\"line\"><span class=\"comment\"> * Java&amp;trade; programming language.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.System#identityHashCode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<h3 id=\"为什么要有hashCode\"><a href=\"#为什么要有hashCode\" class=\"headerlink\" title=\"为什么要有hashCode\"></a>为什么要有hashCode</h3><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>\n<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>\n<h3 id=\"hashCode（）与equals（）的相关规定\"><a href=\"#hashCode（）与equals（）的相关规定\" class=\"headerlink\" title=\"hashCode（）与equals（）的相关规定\"></a>hashCode（）与equals（）的相关规定</h3><ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>\n</ol>\n<h3 id=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"><a href=\"#为什么两个对象有相同的hashcode值，它们也不一定是相等的？\" class=\"headerlink\" title=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>\n<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>\n<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/zhzhao999/article/details/53449504\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/Eason-S/p/5524837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-为什么-Java-中只有值传递？\"><a href=\"#一-为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"一 为什么 Java 中只有值传递？\"></a>一 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>  它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>\n<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>\n<p><strong>下面通过 3 个例子来给大家说明</strong></p>\n<h3 id=\"example-1\"><a href=\"#example-1\" class=\"headerlink\" title=\"example 1\"></a>example 1</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num2 = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num1 = \"</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"num2 = \"</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"a = \"</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"b = \"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 20</span><br><span class=\"line\">b = 10</span><br><span class=\"line\">num1 = 10</span><br><span class=\"line\">num2 = 20</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg\" alt=\"example 1 \"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<h3 id=\"example-2\"><a href=\"#example-2\" class=\"headerlink\" title=\"example 2\"></a>example 2</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tchange(arr);</span><br><span class=\"line\">\tSystem.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">\tarray[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg\" alt=\"example 2\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>\n<h3 id=\"example-3\"><a href=\"#example-3\" class=\"headerlink\" title=\"example 3\"></a>example 3</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tStudent s1 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小张\"</span>);</span><br><span class=\"line\">\t\tStudent s2 = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">\t\tTest.swap(s1, s2);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s1:\"</span> + s1.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"s2:\"</span> + s2.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Student x, Student y)</span> </span>&#123;</span><br><span class=\"line\">\t\tStudent temp = x;</span><br><span class=\"line\">\t\tx = y;</span><br><span class=\"line\">\t\ty = temp;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"x:\"</span> + x.getName());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"y:\"</span> + y.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n<p><strong>解析：</strong></p>\n<p>交换之前：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg\" alt></p>\n<p>交换之后：</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg\" alt></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p>\n<p>下面再总结一下Java中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>\n<h2 id=\"二-与equals-重要\"><a href=\"#二-与equals-重要\" class=\"headerlink\" title=\"二  ==与equals(重要)\"></a>二  ==与equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<ul>\n<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>\n<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// a 为一个引用</span></span><br><span class=\"line\">        String b = <span class=\"keyword\">new</span> String(<span class=\"string\">\"ab\"</span>); <span class=\"comment\">// b为另一个引用,对象的内容一样</span></span><br><span class=\"line\">        String aa = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 放在常量池中</span></span><br><span class=\"line\">        String bb = <span class=\"string\">\"ab\"</span>; <span class=\"comment\">// 从常量池中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aa == bb) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aa==bb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a == b) <span class=\"comment\">// false，非同一对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"a==b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.equals(b)) <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"aEQb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">42</span> == <span class=\"number\">42.0</span>) &#123; <span class=\"comment\">// true</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong></p>\n<ul>\n<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>\n<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>\n</ul>\n<h2 id=\"三-hashCode与equals（重要）\"><a href=\"#三-hashCode与equals（重要）\" class=\"headerlink\" title=\"三  hashCode与equals（重要）\"></a>三  hashCode与equals（重要）</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>\n<h3 id=\"hashCode（）介绍\"><a href=\"#hashCode（）介绍\" class=\"headerlink\" title=\"hashCode（）介绍\"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code value for the object. This method is</span></span><br><span class=\"line\"><span class=\"comment\"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> java.util.HashMap&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * As much as is reasonably practical, the hashCode method defined by</span></span><br><span class=\"line\"><span class=\"comment\"> * class &#123;<span class=\"doctag\">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class=\"line\"><span class=\"comment\"> * objects. (This is typically implemented by converting the internal</span></span><br><span class=\"line\"><span class=\"comment\"> * address of the object into an integer, but this implementation</span></span><br><span class=\"line\"><span class=\"comment\"> * technique is not required by the</span></span><br><span class=\"line\"><span class=\"comment\"> * Java&amp;trade; programming language.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>     java.lang.System#identityHashCode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n<h3 id=\"为什么要有hashCode\"><a href=\"#为什么要有hashCode\" class=\"headerlink\" title=\"为什么要有hashCode\"></a>为什么要有hashCode</h3><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>\n<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>\n<h3 id=\"hashCode（）与equals（）的相关规定\"><a href=\"#hashCode（）与equals（）的相关规定\" class=\"headerlink\" title=\"hashCode（）与equals（）的相关规定\"></a>hashCode（）与equals（）的相关规定</h3><ol>\n<li>如果两个对象相等，则hashcode一定也是相同的</li>\n<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>\n<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>\n<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>\n<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>\n</ol>\n<h3 id=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"><a href=\"#为什么两个对象有相同的hashcode值，它们也不一定是相等的？\" class=\"headerlink\" title=\"为什么两个对象有相同的hashcode值，它们也不一定是相等的？\"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>\n<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>\n<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>\n<p>参考：</p>\n<p><a href=\"https://blog.csdn.net/zhzhao999/article/details/53449504\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhzhao999/article/details/53449504</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>\n<p><a href=\"https://www.cnblogs.com/Eason-S/p/5524837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Eason-S/p/5524837.html</a></p>\n"},{"title":"问题梳理-Java多线程","_content":"\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","source":"_posts/Java/Concurrency/questiones-multithread-in-java.md","raw":"---\ntitle: 问题梳理-Java多线程\ncategories:\n  - Java\n  - Concurrency\ntags:\n  - multithread\n  - interview\n\n---\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","slug":"Java/Concurrency/questiones-multithread-in-java","published":1,"date":"2019-03-22T10:16:45.422Z","updated":"2019-03-23T03:39:45.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1k00eiqnn9i76t9m93","content":"<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n"},{"title":"Java容器——ArrayList扩容源码分析","_content":"\n## 一 先从 ArrayList 的构造函数说起\n\n**ArrayList有三种方式来初始化，构造方法源码如下：**\n\n```java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    \n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。 \n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n```\n\n细心的同学一定会发现 ：**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\n\n## 二 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n### 1. 先来看 `add` 方法\n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n### 2. 再来看看 `ensureCapacityInternal()` 方法\n\n可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n**当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。**\n\n### 3. `ensureExplicitCapacity()` 方法 \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为10。此时，`minCapacity - elementData.length > 0 `成立，所以会进入 `grow(minCapacity)` 方法。\n- 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0 ` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。\n\n直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\n\n### 4. `grow()` 方法 \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）**  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码\n\n>   \">>\"（移位运算符）：>>1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　\n\n**我们再来通过例子探究一下`grow()` 方法 ：**\n\n- 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 `hugeCapacity` 方法。数组容量为10，add方法中 return true,size增为1。\n- 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- java 中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 5. `hugeCapacity()` 方法。\n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 \n\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n\n\n## 三 `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n\n### 3.1 `System.arraycopy()` 方法\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = new int[10];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\ta[3] = 3;\n\t\tSystem.arraycopy(a, 2, a, 3, 3);\n\t\ta[2]=99;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\n}\n```\n\n结果：\n\n```\n0 1 99 2 3 0 0 0 0 0 \n```\n\n### 3.2 `Arrays.copyOf()`方法\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[3];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\tint[] b = Arrays.copyOf(a, 10);\n\t\tSystem.out.println(\"b.length\"+b.length);\n\t}\n}\n```\n\n结果：\n\n```\n10\n```\n\n\n### 3.3 两者联系和区别\n\n**联系：** \n\n看两者源代码可以发现 copyOf() 内部实际调用了 `System.arraycopy()` 方法 \n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n\n\n## 四 `ensureCapacity`方法\n\nArrayList 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n\t\tlist = new ArrayList<Object>();\n\t\tlong startTime1 = System.currentTimeMillis();\n\t\tlist.ensureCapacity(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime1 = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n\t}\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法前：4637\n使用ensureCapacity方法后：241\n\n```\n\n通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数\n","source":"_posts/Java/Collection-Framework/ArrayList-Grow.md","raw":"---\ntitle: Java容器——ArrayList扩容源码分析\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n  - array-list\n---\n\n## 一 先从 ArrayList 的构造函数说起\n\n**ArrayList有三种方式来初始化，构造方法源码如下：**\n\n```java\n   /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n    \n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。 \n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n```\n\n细心的同学一定会发现 ：**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。** 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\n\n## 二 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n### 1. 先来看 `add` 方法\n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n   //添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n### 2. 再来看看 `ensureCapacityInternal()` 方法\n\n可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n**当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。**\n\n### 3. `ensureExplicitCapacity()` 方法 \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为10。此时，`minCapacity - elementData.length > 0 `成立，所以会进入 `grow(minCapacity)` 方法。\n- 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0 ` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。\n\n直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\n\n### 4. `grow()` 方法 \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）**  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码\n\n>   \">>\"（移位运算符）：>>1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　\n\n**我们再来通过例子探究一下`grow()` 方法 ：**\n\n- 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 `hugeCapacity` 方法。数组容量为10，add方法中 return true,size增为1。\n- 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。\n- 以此类推······\n\n**这里补充一点比较重要，但是容易被忽视掉的知识点：**\n\n- java 中的 `length `属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.\n- java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 5. `hugeCapacity()` 方法。\n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 \n\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n\n\n## 三 `System.arraycopy()` 和 `Arrays.copyOf()`方法\n\n\n阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法！\n\n\n### 3.1 `System.arraycopy()` 方法\n\n```java\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n我们写一个简单的方法测试以下：\n\n```java\npublic class ArraycopyTest {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] a = new int[10];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\ta[3] = 3;\n\t\tSystem.arraycopy(a, 2, a, 3, 3);\n\t\ta[2]=99;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tSystem.out.println(a[i]);\n\t\t}\n\t}\n\n}\n```\n\n结果：\n\n```\n0 1 99 2 3 0 0 0 0 0 \n```\n\n### 3.2 `Arrays.copyOf()`方法\n\n```java\n   /**\n     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 \n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n\n个人觉得使用 `Arrays.copyOf()`方法主要是为了给原有数组扩容，测试代码如下：\n\n```java\npublic class ArrayscopyOfTest {\n\n\tpublic static void main(String[] args) {\n\t\tint[] a = new int[3];\n\t\ta[0] = 0;\n\t\ta[1] = 1;\n\t\ta[2] = 2;\n\t\tint[] b = Arrays.copyOf(a, 10);\n\t\tSystem.out.println(\"b.length\"+b.length);\n\t}\n}\n```\n\n结果：\n\n```\n10\n```\n\n\n### 3.3 两者联系和区别\n\n**联系：** \n\n看两者源代码可以发现 copyOf() 内部实际调用了 `System.arraycopy()` 方法 \n\n**区别：**\n\n`arraycopy()` 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 `copyOf()` 是系统自动在内部新建一个数组，并返回该数组。\n\n\n\n## 四 `ensureCapacity`方法\n\nArrayList 源码中有一个 `ensureCapacity` 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\n\n```java\n    /**\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。\n     *\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n\n```\n\n**最好在 add 大量元素之前用 `ensureCapacity` 方法，以减少增量重新分配的次数**\n\n我们通过下面的代码实际测试以下这个方法的效果：\n\n```java\npublic class EnsureCapacityTest {\n\tpublic static void main(String[] args) {\n\t\tArrayList<Object> list = new ArrayList<Object>();\n\t\tfinal int N = 10000000;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法前：\"+(endTime - startTime));\n\n\t\tlist = new ArrayList<Object>();\n\t\tlong startTime1 = System.currentTimeMillis();\n\t\tlist.ensureCapacity(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlist.add(i);\n\t\t}\n\t\tlong endTime1 = System.currentTimeMillis();\n\t\tSystem.out.println(\"使用ensureCapacity方法后：\"+(endTime1 - startTime1));\n\t}\n}\n```\n\n运行结果：\n\n```\n使用ensureCapacity方法前：4637\n使用ensureCapacity方法后：241\n\n```\n\n通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用`ensureCapacity` 方法，以减少增量重新分配的次数\n","slug":"Java/Collection-Framework/ArrayList-Grow","published":1,"date":"2019-03-22T10:16:45.424Z","updated":"2019-03-23T03:50:04.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1n00elqnn94x7nuu66","content":"<h2 id=\"一-先从-ArrayList-的构造函数说起\"><a href=\"#一-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"一 先从 ArrayList 的构造函数说起\"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<h2 id=\"二-一步一步分析-ArrayList-扩容机制\"><a href=\"#二-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"二 一步一步分析 ArrayList 扩容机制\"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h3 id=\"1-先来看-add-方法\"><a href=\"#1-先来看-add-方法\" class=\"headerlink\" title=\"1. 先来看 add 方法\"></a>1. 先来看 <code>add</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-再来看看-ensureCapacityInternal-方法\"><a href=\"#2-再来看看-ensureCapacityInternal-方法\" class=\"headerlink\" title=\"2. 再来看看 ensureCapacityInternal() 方法\"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p>\n<h3 id=\"3-ensureExplicitCapacity-方法\"><a href=\"#3-ensureExplicitCapacity-方法\" class=\"headerlink\" title=\"3. ensureExplicitCapacity() 方法\"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li>\n</ul>\n<p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p>\n<h3 id=\"4-grow-方法\"><a href=\"#4-grow-方法\" class=\"headerlink\" title=\"4. grow() 方法\"></a>4. <code>grow()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）</strong>  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码</p>\n<blockquote>\n<p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"5-hugeCapacity-方法。\"><a href=\"#5-hugeCapacity-方法。\" class=\"headerlink\" title=\"5. hugeCapacity() 方法。\"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#三-System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"三 System.arraycopy() 和 Arrays.copyOf()方法\"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h3 id=\"3-1-System-arraycopy-方法\"><a href=\"#3-1-System-arraycopy-方法\" class=\"headerlink\" title=\"3.1 System.arraycopy() 方法\"></a>3.1 <code>System.arraycopy()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArraycopyTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tSystem.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Arrays-copyOf-方法\"><a href=\"#3-2-Arrays-copyOf-方法\" class=\"headerlink\" title=\"3.2 Arrays.copyOf()方法\"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayscopyOfTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"b.length\"</span>+b.length);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-两者联系和区别\"><a href=\"#3-3-两者联系和区别\" class=\"headerlink\" title=\"3.3 两者联系和区别\"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法 </p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h2 id=\"四-ensureCapacity方法\"><a href=\"#四-ensureCapacity方法\" class=\"headerlink\" title=\"四 ensureCapacity方法\"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnsureCapacityTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">10000000</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法前：\"</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tlist.ensureCapacity(N);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法后：\"</span>+(endTime1 - startTime1));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：4637</span><br><span class=\"line\">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure>\n<p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一-先从-ArrayList-的构造函数说起\"><a href=\"#一-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"一 先从 ArrayList 的构造函数说起\"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p>\n<h2 id=\"二-一步一步分析-ArrayList-扩容机制\"><a href=\"#二-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"二 一步一步分析 ArrayList 扩容机制\"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h3 id=\"1-先来看-add-方法\"><a href=\"#1-先来看-add-方法\" class=\"headerlink\" title=\"1. 先来看 add 方法\"></a>1. 先来看 <code>add</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-再来看看-ensureCapacityInternal-方法\"><a href=\"#2-再来看看-ensureCapacityInternal-方法\" class=\"headerlink\" title=\"2. 再来看看 ensureCapacityInternal() 方法\"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p>\n<h3 id=\"3-ensureExplicitCapacity-方法\"><a href=\"#3-ensureExplicitCapacity-方法\" class=\"headerlink\" title=\"3. ensureExplicitCapacity() 方法\"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li>\n</ul>\n<p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p>\n<h3 id=\"4-grow-方法\"><a href=\"#4-grow-方法\" class=\"headerlink\" title=\"4. grow() 方法\"></a>4. <code>grow()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！（JDK1.6版本以后）</strong>  JDk1.6版本时，扩容之后容量为 1.5 倍+1！详情请参考源码</p>\n<blockquote>\n<p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p>\n</blockquote>\n<p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p>\n<ul>\n<li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li>\n<li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li>\n<li>以此类推······</li>\n</ul>\n<p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p>\n<ul>\n<li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li>\n<li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"5-hugeCapacity-方法。\"><a href=\"#5-hugeCapacity-方法。\" class=\"headerlink\" title=\"5. hugeCapacity() 方法。\"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-System-arraycopy-和-Arrays-copyOf-方法\"><a href=\"#三-System-arraycopy-和-Arrays-copyOf-方法\" class=\"headerlink\" title=\"三 System.arraycopy() 和 Arrays.copyOf()方法\"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p>\n<h3 id=\"3-1-System-arraycopy-方法\"><a href=\"#3-1-System-arraycopy-方法\" class=\"headerlink\" title=\"3.1 System.arraycopy() 方法\"></a>3.1 <code>System.arraycopy()</code> 方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们写一个简单的方法测试以下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArraycopyTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t\tSystem.arraycopy(a, <span class=\"number\">2</span>, a, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>]=<span class=\"number\">99</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-Arrays-copyOf-方法\"><a href=\"#3-2-Arrays-copyOf-方法\" class=\"headerlink\" title=\"3.2 Arrays.copyOf()方法\"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"> <span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayscopyOfTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\ta[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ta[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span>[] b = Arrays.copyOf(a, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"b.length\"</span>+b.length);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-两者联系和区别\"><a href=\"#3-3-两者联系和区别\" class=\"headerlink\" title=\"3.3 两者联系和区别\"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p>\n<p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法 </p>\n<p><strong>区别：</strong></p>\n<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>\n<h2 id=\"四-ensureCapacity方法\"><a href=\"#四-ensureCapacity方法\" class=\"headerlink\" title=\"四 ensureCapacity方法\"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">        <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">        ? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">        <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">        : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>\n<p>我们通过下面的代码实际测试以下这个方法的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnsureCapacityTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> N = <span class=\"number\">10000000</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法前：\"</span>+(endTime - startTime));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> startTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tlist.ensureCapacity(N);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> endTime1 = System.currentTimeMillis();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"使用ensureCapacity方法后：\"</span>+(endTime1 - startTime1));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ensureCapacity方法前：4637</span><br><span class=\"line\">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure>\n<p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数</p>\n"},{"title":"Java常见问题汇总-2","_content":"### String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\n\n####  String和StringBuffer、StringBuilder的区别\n\n**可变性**\n　\n\n简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\n\nStringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\n\nAbstractStringBuilder.java\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    int count;\n    AbstractStringBuilder() {\n    }\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n```\n\n\n**线程安全性**\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　\n\n**性能**\n\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：** \n1. 操作少量的数据 = String\n2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder\n3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer\n\n####  String为什么是不可变的吗？\n简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n####  String真的是不可变的吗？\n我觉得如果别人问这个问题的话，回答不可变就可以了。\n下面只是给大家看两个有代表性的例子：\n\n**1) String不可变但不代表引用不可以变**\n```java\n\t\tString str = \"Hello\";\n\t\tstr = str + \" World\";\n\t\tSystem.out.println(\"str=\" + str);\n```\n结果：\n```\nstr=Hello World\n```\n解析：\n\n实际上，原来String的内容是不变的，只是str由原来指向\"Hello\"的内存地址转为指向\"Hello World\"的内存地址而已，也就是说多开辟了一块内存区域给\"Hello World\"字符串。\n\n**2) 通过反射是可以修改所谓的“不可变”对象**\n\n```java\n\t\t// 创建字符串\"Hello World\"， 并赋给引用s\n\t\tString s = \"Hello World\";\n\n\t\tSystem.out.println(\"s = \" + s); // Hello World\n\n\t\t// 获取String类中的value字段\n\t\tField valueFieldOfString = String.class.getDeclaredField(\"value\");\n\n\t\t// 改变value属性的访问权限\n\t\tvalueFieldOfString.setAccessible(true);\n\n\t\t// 获取s对象上的value属性的值\n\t\tchar[] value = (char[]) valueFieldOfString.get(s);\n\n\t\t// 改变value所引用的数组中的第5个字符\n\t\tvalue[5] = '_';\n\n\t\tSystem.out.println(\"s = \" + s); // Hello_World\n```\n\n结果：\n\n```\ns = Hello World\ns = Hello_World\n```\n\n解析：\n\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n\n### 什么是反射机制？反射机制的应用场景有哪些？\n\n#### 反射机制介绍\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n#### 静态编译和动态编译\n\n- **静态编译：**在编译时确定类型，绑定对象\n- **动态编译：**运行时确定类型，绑定对象\n\n#### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。\n\n#### 反射的应用场景\n\n反射是框架设计的灵魂。\n\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;\n 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\n\n**推荐阅读：**\n\n- [Reflection：Java反射机制的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)\n- [Java基础之—反射（非常重要）](https://blog.csdn.net/sinat_38259539/article/details/71799078)\n### 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\n\n这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。\n\n**JDK:**  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。\n\n**JRE:** 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。\n\n**JVM：** 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。\n\n**区别与联系：**\n\n 1. JDK用于开发，JRE用于运行java程序 ；\n 2. JDK和JRE中都包含JVM ；\n 3. JVM是java编程语言的核心并且具有平台独立性。\n\n### 什么是字节码？采用字节码的最大好处是什么？\n\n**先看下java中的编译器和解释器：** 　　\n\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。\n\n Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。 \n\n**采用字节码的好处：** 　　\n\nJava语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n\n### Java和C++的区别\n\n我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java不提供指针来直接访问内存，程序内存更加安全\n-  Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n-   Java有自动内存管理机制，不需要程序员手动释放无用内存\n\n\n### 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法\n2.  接口中的实例变量默认是final类型的，而抽象类中则不一定 \n3.  一个类可以实现多个接口，但最多只能实现一个抽象类 \n4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定 \n5.  接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n\n注意：Java8 后接口可以有默认实现( default )。\n\n### 成员变量与局部变量的区别有那些？\n\n1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；\n2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存\n3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\n4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。\n\n### 重载和重写的区别\n\n**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　\n\n**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。\n\n### 字符型常量和字符串常量的区别\n1) 形式上:\n字符常量是单引号引起的一个字符 \n字符串常量是双引号引起的若干个字符\n2) 含义上:\n字符常量相当于一个整形值(ASCII值),可以参加表达式运算\n字符串常量代表一个地址值(该字符串在内存中存放位置)\n3) 占内存大小\n字符常量只占一个字节\n字符串常量占若干个字节(至少一个字符结束标志)\n","source":"_posts/Java/Summary/string.md","raw":"---\ntitle: Java常见问题汇总-2\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n### String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\n\n####  String和StringBuffer、StringBuilder的区别\n\n**可变性**\n　\n\n简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。\n\nStringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。\n\nAbstractStringBuilder.java\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    char[] value;\n    int count;\n    AbstractStringBuilder() {\n    }\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n```\n\n\n**线程安全性**\n\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　\n\n**性能**\n\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n**对于三者使用的总结：** \n1. 操作少量的数据 = String\n2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder\n3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer\n\n####  String为什么是不可变的吗？\n简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：\n\n```java\n    /** The value is used for character storage. */\n    private final char value[];\n```\n\n####  String真的是不可变的吗？\n我觉得如果别人问这个问题的话，回答不可变就可以了。\n下面只是给大家看两个有代表性的例子：\n\n**1) String不可变但不代表引用不可以变**\n```java\n\t\tString str = \"Hello\";\n\t\tstr = str + \" World\";\n\t\tSystem.out.println(\"str=\" + str);\n```\n结果：\n```\nstr=Hello World\n```\n解析：\n\n实际上，原来String的内容是不变的，只是str由原来指向\"Hello\"的内存地址转为指向\"Hello World\"的内存地址而已，也就是说多开辟了一块内存区域给\"Hello World\"字符串。\n\n**2) 通过反射是可以修改所谓的“不可变”对象**\n\n```java\n\t\t// 创建字符串\"Hello World\"， 并赋给引用s\n\t\tString s = \"Hello World\";\n\n\t\tSystem.out.println(\"s = \" + s); // Hello World\n\n\t\t// 获取String类中的value字段\n\t\tField valueFieldOfString = String.class.getDeclaredField(\"value\");\n\n\t\t// 改变value属性的访问权限\n\t\tvalueFieldOfString.setAccessible(true);\n\n\t\t// 获取s对象上的value属性的值\n\t\tchar[] value = (char[]) valueFieldOfString.get(s);\n\n\t\t// 改变value所引用的数组中的第5个字符\n\t\tvalue[5] = '_';\n\n\t\tSystem.out.println(\"s = \" + s); // Hello_World\n```\n\n结果：\n\n```\ns = Hello World\ns = Hello_World\n```\n\n解析：\n\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n\n### 什么是反射机制？反射机制的应用场景有哪些？\n\n#### 反射机制介绍\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n#### 静态编译和动态编译\n\n- **静态编译：**在编译时确定类型，绑定对象\n- **动态编译：**运行时确定类型，绑定对象\n\n#### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。\n\n#### 反射的应用场景\n\n反射是框架设计的灵魂。\n\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;\n 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\n\n**推荐阅读：**\n\n- [Reflection：Java反射机制的应用场景](https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral)\n- [Java基础之—反射（非常重要）](https://blog.csdn.net/sinat_38259539/article/details/71799078)\n### 什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\n\n这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。\n\n**JDK:**  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。\n\n**JRE:** 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。\n\n**JVM：** 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。\n\n**区别与联系：**\n\n 1. JDK用于开发，JRE用于运行java程序 ；\n 2. JDK和JRE中都包含JVM ；\n 3. JVM是java编程语言的核心并且具有平台独立性。\n\n### 什么是字节码？采用字节码的最大好处是什么？\n\n**先看下java中的编译器和解释器：** 　　\n\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。\n\n Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。 \n\n**采用字节码的好处：** 　　\n\nJava语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n\n### Java和C++的区别\n\n我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java不提供指针来直接访问内存，程序内存更加安全\n-  Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n-   Java有自动内存管理机制，不需要程序员手动释放无用内存\n\n\n### 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法\n2.  接口中的实例变量默认是final类型的，而抽象类中则不一定 \n3.  一个类可以实现多个接口，但最多只能实现一个抽象类 \n4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定 \n5.  接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n\n注意：Java8 后接口可以有默认实现( default )。\n\n### 成员变量与局部变量的区别有那些？\n\n1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；\n2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存\n3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。\n4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。\n\n### 重载和重写的区别\n\n**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　\n\n**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。\n\n### 字符型常量和字符串常量的区别\n1) 形式上:\n字符常量是单引号引起的一个字符 \n字符串常量是双引号引起的若干个字符\n2) 含义上:\n字符常量相当于一个整形值(ASCII值),可以参加表达式运算\n字符串常量代表一个地址值(该字符串在内存中存放位置)\n3) 占内存大小\n字符常量只占一个字节\n字符串常量占若干个字节(至少一个字符结束标志)\n","slug":"Java/Summary/string","published":1,"date":"2019-03-22T10:16:45.423Z","updated":"2019-03-24T06:08:45.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge1p00eoqnn9txxtcqtt","content":"<h3 id=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"><a href=\"#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id=\"String和StringBuffer、StringBuilder的区别\"><a href=\"#String和StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别\"></a>String和StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong>\n　</p>\n<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>\n<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>\n<p>AbstractStringBuilder.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    AbstractStringBuilder() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AbstractStringBuilder(<span class=\"keyword\">int</span> capacity) &#123;</span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线程安全性</strong></p>\n<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　</p>\n<p><strong>性能</strong></p>\n<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong> </p>\n<ol>\n<li>操作少量的数据 = String</li>\n<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>\n<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>\n</ol>\n<h4 id=\"String为什么是不可变的吗？\"><a href=\"#String为什么是不可变的吗？\" class=\"headerlink\" title=\"String为什么是不可变的吗？\"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n<h4 id=\"String真的是不可变的吗？\"><a href=\"#String真的是不可变的吗？\" class=\"headerlink\" title=\"String真的是不可变的吗？\"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p>\n<p><strong>1) String不可变但不代表引用不可以变</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">str = str + <span class=\"string\">\" World\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=Hello World</span><br></pre></td></tr></table></figure></p>\n<p>解析：</p>\n<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>\n<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符串\"Hello World\"， 并赋给引用s</span></span><br><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取String类中的value字段</span></span><br><span class=\"line\">Field valueFieldOfString = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value属性的访问权限</span></span><br><span class=\"line\">valueFieldOfString.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取s对象上的value属性的值</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] value = (<span class=\"keyword\">char</span>[]) valueFieldOfString.get(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value所引用的数组中的第5个字符</span></span><br><span class=\"line\">value[<span class=\"number\">5</span>] = <span class=\"string\">'_'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello_World</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = Hello World</span><br><span class=\"line\">s = Hello_World</span><br></pre></td></tr></table></figure>\n<p>解析：</p>\n<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>\n<h3 id=\"什么是反射机制？反射机制的应用场景有哪些？\"><a href=\"#什么是反射机制？反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"什么是反射机制？反射机制的应用场景有哪些？\"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id=\"反射机制介绍\"><a href=\"#反射机制介绍\" class=\"headerlink\" title=\"反射机制介绍\"></a>反射机制介绍</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\n<h4 id=\"静态编译和动态编译\"><a href=\"#静态编译和动态编译\" class=\"headerlink\" title=\"静态编译和动态编译\"></a>静态编译和动态编译</h4><ul>\n<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>\n<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>\n</ul>\n<h4 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h4><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>\n</ul>\n<h4 id=\"反射的应用场景\"><a href=\"#反射的应用场景\" class=\"headerlink\" title=\"反射的应用场景\"></a>反射的应用场景</h4><p>反射是框架设计的灵魂。</p>\n<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br> 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Reflection：Java反射机制的应用场景</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\" target=\"_blank\" rel=\"noopener\">Java基础之—反射（非常重要）</a><h3 id=\"什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\"><a href=\"#什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\" class=\"headerlink\" title=\"什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\"></a>什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别</h3></li>\n</ul>\n<p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p>\n<p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p>\n<p><strong>JRE:</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p>\n<p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p>\n<p><strong>区别与联系：</strong></p>\n<ol>\n<li>JDK用于开发，JRE用于运行java程序 ；</li>\n<li>JDK和JRE中都包含JVM ；</li>\n<li>JVM是java编程语言的核心并且具有平台独立性。</li>\n</ol>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么？\"><a href=\"#什么是字节码？采用字节码的最大好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么？\"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下java中的编译器和解释器：</strong> 　　</p>\n<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>\n<p> Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p>\n<p><strong>采用字节码的好处：</strong> 　　</p>\n<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>\n<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>\n</ul>\n<h3 id=\"接口和抽象类的区别是什么？\"><a href=\"#接口和抽象类的区别是什么？\" class=\"headerlink\" title=\"接口和抽象类的区别是什么？\"></a>接口和抽象类的区别是什么？</h3><ol>\n<li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>\n<li>接口中的实例变量默认是final类型的，而抽象类中则不一定 </li>\n<li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li>\n<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li>\n<li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>\n</ol>\n<p>注意：Java8 后接口可以有默认实现( default )。</p>\n<h3 id=\"成员变量与局部变量的区别有那些？\"><a href=\"#成员变量与局部变量的区别有那些？\" class=\"headerlink\" title=\"成员变量与局部变量的区别有那些？\"></a>成员变量与局部变量的区别有那些？</h3><ol>\n<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li>\n<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>\n<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>\n<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li>\n</ol>\n<h3 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>\n<p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>\n<h3 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别\"></a>字符型常量和字符串常量的区别</h3><p>1) 形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br>2) 含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br>3) 占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"><a href=\"#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？\"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h3><h4 id=\"String和StringBuffer、StringBuilder的区别\"><a href=\"#String和StringBuffer、StringBuilder的区别\" class=\"headerlink\" title=\"String和StringBuffer、StringBuilder的区别\"></a>String和StringBuffer、StringBuilder的区别</h4><p><strong>可变性</strong>\n　</p>\n<p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>\n<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>\n<p>AbstractStringBuilder.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    AbstractStringBuilder() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AbstractStringBuilder(<span class=\"keyword\">int</span> capacity) &#123;</span><br><span class=\"line\">        value = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[capacity];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线程安全性</strong></p>\n<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n　　</p>\n<p><strong>性能</strong></p>\n<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong> </p>\n<ol>\n<li>操作少量的数据 = String</li>\n<li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li>\n<li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li>\n</ol>\n<h4 id=\"String为什么是不可变的吗？\"><a href=\"#String为什么是不可变的吗？\" class=\"headerlink\" title=\"String为什么是不可变的吗？\"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n<h4 id=\"String真的是不可变的吗？\"><a href=\"#String真的是不可变的吗？\" class=\"headerlink\" title=\"String真的是不可变的吗？\"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p>\n<p><strong>1) String不可变但不代表引用不可以变</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">str = str + <span class=\"string\">\" World\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str=Hello World</span><br></pre></td></tr></table></figure></p>\n<p>解析：</p>\n<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>\n<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符串\"Hello World\"， 并赋给引用s</span></span><br><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取String类中的value字段</span></span><br><span class=\"line\">Field valueFieldOfString = String.class.getDeclaredField(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value属性的访问权限</span></span><br><span class=\"line\">valueFieldOfString.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取s对象上的value属性的值</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] value = (<span class=\"keyword\">char</span>[]) valueFieldOfString.get(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变value所引用的数组中的第5个字符</span></span><br><span class=\"line\">value[<span class=\"number\">5</span>] = <span class=\"string\">'_'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s = \"</span> + s); <span class=\"comment\">// Hello_World</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = Hello World</span><br><span class=\"line\">s = Hello_World</span><br></pre></td></tr></table></figure>\n<p>解析：</p>\n<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>\n<h3 id=\"什么是反射机制？反射机制的应用场景有哪些？\"><a href=\"#什么是反射机制？反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"什么是反射机制？反射机制的应用场景有哪些？\"></a>什么是反射机制？反射机制的应用场景有哪些？</h3><h4 id=\"反射机制介绍\"><a href=\"#反射机制介绍\" class=\"headerlink\" title=\"反射机制介绍\"></a>反射机制介绍</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>\n<h4 id=\"静态编译和动态编译\"><a href=\"#静态编译和动态编译\" class=\"headerlink\" title=\"静态编译和动态编译\"></a>静态编译和动态编译</h4><ul>\n<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>\n<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>\n</ul>\n<h4 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h4><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>\n</ul>\n<h4 id=\"反射的应用场景\"><a href=\"#反射的应用场景\" class=\"headerlink\" title=\"反射的应用场景\"></a>反射的应用场景</h4><p>反射是框架设计的灵魂。</p>\n<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>\n<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;<br> 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>\n<p><strong>推荐阅读：</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">Reflection：Java反射机制的应用场景</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\" target=\"_blank\" rel=\"noopener\">Java基础之—反射（非常重要）</a><h3 id=\"什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\"><a href=\"#什么是JDK-什么是JRE？什么是JVM？三者之间的联系与区别\" class=\"headerlink\" title=\"什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别\"></a>什么是JDK?什么是JRE？什么是JVM？三者之间的联系与区别</h3></li>\n</ul>\n<p>这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。</p>\n<p><strong>JDK:</strong>  顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p>\n<p><strong>JRE:</strong> 普通用户而只需要安装JRE（Java Runtime Environment）来运行Java程序。而程序开发者必须安装JDK来编译、调试程序。</p>\n<p><strong>JVM：</strong> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因。</p>\n<p><strong>区别与联系：</strong></p>\n<ol>\n<li>JDK用于开发，JRE用于运行java程序 ；</li>\n<li>JDK和JRE中都包含JVM ；</li>\n<li>JVM是java编程语言的核心并且具有平台独立性。</li>\n</ol>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么？\"><a href=\"#什么是字节码？采用字节码的最大好处是什么？\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么？\"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下java中的编译器和解释器：</strong> 　　</p>\n<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>\n<p> Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 </p>\n<p><strong>采用字节码的好处：</strong> 　　</p>\n<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>\n<ul>\n<li>都是面向对象的语言，都支持封装、继承和多态</li>\n<li>Java不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>\n<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>\n</ul>\n<h3 id=\"接口和抽象类的区别是什么？\"><a href=\"#接口和抽象类的区别是什么？\" class=\"headerlink\" title=\"接口和抽象类的区别是什么？\"></a>接口和抽象类的区别是什么？</h3><ol>\n<li>接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>\n<li>接口中的实例变量默认是final类型的，而抽象类中则不一定 </li>\n<li>一个类可以实现多个接口，但最多只能实现一个抽象类 </li>\n<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定 </li>\n<li>接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>\n</ol>\n<p>注意：Java8 后接口可以有默认实现( default )。</p>\n<h3 id=\"成员变量与局部变量的区别有那些？\"><a href=\"#成员变量与局部变量的区别有那些？\" class=\"headerlink\" title=\"成员变量与局部变量的区别有那些？\"></a>成员变量与局部变量的区别有那些？</h3><ol>\n<li>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；</li>\n<li>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</li>\n<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>\n<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。</li>\n</ol>\n<h3 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h3><p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</p>\n<p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。</p>\n<h3 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别\"></a>字符型常量和字符串常量的区别</h3><p>1) 形式上:<br>字符常量是单引号引起的一个字符<br>字符串常量是双引号引起的若干个字符<br>2) 含义上:<br>字符常量相当于一个整形值(ASCII值),可以参加表达式运算<br>字符串常量代表一个地址值(该字符串在内存中存放位置)<br>3) 占内存大小<br>字符常量只占一个字节<br>字符串常量占若干个字节(至少一个字符结束标志)</p>\n"},{"title":"Java常见问题汇总-thread","_content":"<!-- toc -->\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","source":"_posts/Java/Summary/thread.md","raw":"---\ntitle: Java常见问题汇总-thread\ncategories:\n  - Java\n  - Summary\ntags:\n  - interview-questions\n---\n<!-- toc -->\n\n## 1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\n\n**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  \n\n**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。\n\n**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。\n\n**线程** 是 **进程** 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n\n**线程上下文的切换比进程上下文切换要快很多**\n\n- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。\n- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。\n\n## 2. 线程有哪些基本状态？这些状态是如何定义的?\n\n1. **新建(new)**：新创建了一个线程对象。\n2. **可运行(runnable)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。\n3. **运行(running)**：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。\n4. **阻塞(block)**：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：\n  - **(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。\n  - **(二). 同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。\n  - **(三). 其他阻塞**: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。\n5. **死亡(dead)**：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。\n\n![](https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&h=492&f=png&s=128092)\n\n备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：\n\n1. 还没起床：sleeping \n2. 起床收拾好了，随时可以坐地铁出发：Runnable \n3. 等地铁来：Waiting \n4. 地铁来了，但要排队上地铁：I/O阻塞 \n5. 上了地铁，发现暂时没座位：synchronized阻塞 \n6. 地铁上找到座位：Running \n7. 到达目的地：Dead\n\n\n##  3. 何为多线程？\n\n多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。\n\n\n## 4. 为什么多线程是必要的？\n\n1. 使用线程可以把占据长时间的程序中的任务放到后台去处理。\n2. 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。\n3. 程序的运行速度可能加快。\n\n## 5 使用多线程常见的三种方式\n\n### ①继承Thread类\n\nMyThread.java\n\n```java\npublic class MyThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tsuper.run();\n\t\tSystem.out.println(\"MyThread\");\n\t}\n}\n```\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tMyThread mythread = new MyThread();\n\t\tmythread.start();\n\t\tSystem.out.println(\"运行结束\");\n\t}\n\n}\n\n```\n运行结果：\n![结果](https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&h=54&f=jpeg&s=7380)\n从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。\n\n### ②实现Runnable接口\n推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。\n\nMyRunnable.java\n\n```java\npublic class MyRunnable implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"MyRunnable\");\n\t}\n}\n```\n\nRun.java\n\n```java\npublic class Run {\n\n\tpublic static void main(String[] args) {\n\t\tRunnable runnable=new MyRunnable();\n\t\tThread thread=new Thread(runnable);\n\t\tthread.start();\n\t\tSystem.out.println(\"运行结束！\");\n\t}\n\n}\n```\n运行结果：\n![运行结果](https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&h=46&f=jpeg&s=7316)\n\n### ③使用线程池\n\n**在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**\n\n**为什么呢？**\n\n> **使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。**\n\n**另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险**\n\n> Executors 返回线程池对象的弊端如下：\n> \n> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。\n> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。\n\n对于线程池感兴趣的可以查看我的这篇文章：[《Java多线程学习（八）线程池与Executor 框架》](http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484042&idx=1&sn=541dbf2cb969a151d79f4a4f837ee1bd&chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd) 点击阅读原文即可查看到该文章的最新版。\n\n\n## 6 线程的优先级\n\n每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低\n优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。\n\n**线程优先级具有继承特性。** 比如A线程启动B线程，则B线程的优先级和A是一样的。\n\n**线程优先级具有随机性。** 也就是说线程优先级高的不一定每一次都先执行完。\n\nThread类中包含的成员变量代表了线程的某些优先级。如**Thread.MIN_PRIORITY（常数1）**，**Thread.NORM_PRIORITY（常数5）**,\n**Thread.MAX_PRIORITY（常数10）**。其中每个线程的优先级都在**Thread.MIN_PRIORITY（常数1）** 到**Thread.MAX_PRIORITY（常数10）** 之间，在默认情况下优先级都是**Thread.NORM_PRIORITY（常数5）**。\n\n学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。\n\n\n## 7 Java多线程分类\n\n### 用户线程\n\n运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程\n\n### 守护线程\n\n运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 **“佣人”**。\n\n\n- **特点：** 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作\n- **应用：** 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程\n- **最常见的守护线程：** 垃圾回收线程\n\n\n**如何设置守护线程？**\n\n可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程。\n\n注意事项：\n\n\t1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n\t2. 在守护线程中产生的新线程也是守护线程\n\t3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n\n\n##  8 sleep()方法和wait()方法简单对比\n\n- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 \n- 两者都可以暂停线程的执行。\n- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。\n- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。\n\n\n## 9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\n\n这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\n\nnew一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 \nstart()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n\n**总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。**\n\n\n\n\n","slug":"Java/Summary/thread","published":1,"date":"2019-03-22T10:16:45.422Z","updated":"2019-03-24T06:08:49.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge2e00ffqnn9qdsxg0n5","content":"<!-- toc -->\n<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<!-- toc -->\n<h2 id=\"1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"><a href=\"#1-简述线程，程序、进程的基本概念。以及他们之间关系是什么？\" class=\"headerlink\" title=\"1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？\"></a>1. 简述线程，程序、进程的基本概念。以及他们之间关系是什么？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。  </p>\n<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>\n<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>\n<p><strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<p><strong>线程上下文的切换比进程上下文切换要快很多</strong></p>\n<ul>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。</li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ul>\n<h2 id=\"2-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#2-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"2. 线程有哪些基本状态？这些状态是如何定义的?\"></a>2. 线程有哪些基本状态？这些状态是如何定义的?</h2><ol>\n<li><strong>新建(new)</strong>：新创建了一个线程对象。</li>\n<li><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。</li>\n<li><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</li>\n<li><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：<ul>\n<li><strong>(一). 等待阻塞</strong>：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waiting queue)中。</li>\n<li><strong>(二). 同步阻塞</strong>：运行(running)的线程在获取对象的同步锁时，若该同步  锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>\n<li><strong>(三). 其他阻塞</strong>: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>\n</ul>\n</li>\n<li><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/9/1651f19d7c4e93a3?w=876&amp;h=492&amp;f=png&amp;s=128092\" alt></p>\n<p>备注： 可以用早起坐地铁来比喻这个过程（下面参考自牛客网某位同学的回答）：</p>\n<ol>\n<li>还没起床：sleeping </li>\n<li>起床收拾好了，随时可以坐地铁出发：Runnable </li>\n<li>等地铁来：Waiting </li>\n<li>地铁来了，但要排队上地铁：I/O阻塞 </li>\n<li>上了地铁，发现暂时没座位：synchronized阻塞 </li>\n<li>地铁上找到座位：Running </li>\n<li>到达目的地：Dead</li>\n</ol>\n<h2 id=\"3-何为多线程？\"><a href=\"#3-何为多线程？\" class=\"headerlink\" title=\"3. 何为多线程？\"></a>3. 何为多线程？</h2><p>多线程就是多个线程同时运行或交替运行。单核CPU的话是顺序执行，也就是交替运行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。</p>\n<h2 id=\"4-为什么多线程是必要的？\"><a href=\"#4-为什么多线程是必要的？\" class=\"headerlink\" title=\"4. 为什么多线程是必要的？\"></a>4. 为什么多线程是必要的？</h2><ol>\n<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>\n<li>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>\n<li>程序的运行速度可能加快。</li>\n</ol>\n<h2 id=\"5-使用多线程常见的三种方式\"><a href=\"#5-使用多线程常见的三种方式\" class=\"headerlink\" title=\"5 使用多线程常见的三种方式\"></a>5 使用多线程常见的三种方式</h2><h3 id=\"①继承Thread类\"><a href=\"#①继承Thread类\" class=\"headerlink\" title=\"①继承Thread类\"></a>①继承Thread类</h3><p>MyThread.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mythread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmythread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e80f22a2d54?w=161&amp;h=54&amp;f=jpeg&amp;s=7380\" alt=\"结果\"><br>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>\n<h3 id=\"②实现Runnable接口\"><a href=\"#②实现Runnable接口\" class=\"headerlink\" title=\"②实现Runnable接口\"></a>②实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>\n<p>MyRunnable.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"MyRunnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Run.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Run</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRunnable runnable=<span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">\t\tThread thread=<span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\">\t\tthread.start();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"运行结束！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243f4373c6141a?w=137&amp;h=46&amp;f=jpeg&amp;s=7316\" alt=\"运行结果\"></p>\n<h3 id=\"③使用线程池\"><a href=\"#③使用线程池\" class=\"headerlink\" title=\"③使用线程池\"></a>③使用线程池</h3><p><strong>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p>\n<p><strong>为什么呢？</strong></p>\n<blockquote>\n<p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p>\n</blockquote>\n<p><strong>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<blockquote>\n<p>Executors 返回线程池对象的弊端如下：</p>\n<ul>\n<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li>\n<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>\n</ul>\n</blockquote>\n<p>对于线程池感兴趣的可以查看我的这篇文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484042&amp;idx=1&amp;sn=541dbf2cb969a151d79f4a4f837ee1bd&amp;chksm=fd9854ebcaefddfd1876bb96ab218be3ae7b12546695a403075d4ed22e5e17ff30ebdabc8bbf#rd\" target=\"_blank\" rel=\"noopener\">《Java多线程学习（八）线程池与Executor 框架》</a> 点击阅读原文即可查看到该文章的最新版。</p>\n<h2 id=\"6-线程的优先级\"><a href=\"#6-线程的优先级\" class=\"headerlink\" title=\"6 线程的优先级\"></a>6 线程的优先级</h2><p>每个线程都具有各自的优先级，<strong>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态</strong>。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>\n<p><strong>线程优先级具有继承特性。</strong> 比如A线程启动B线程，则B线程的优先级和A是一样的。</p>\n<p><strong>线程优先级具有随机性。</strong> 也就是说线程优先级高的不一定每一次都先执行完。</p>\n<p>Thread类中包含的成员变量代表了线程的某些优先级。如<strong>Thread.MIN_PRIORITY（常数1）</strong>，<strong>Thread.NORM_PRIORITY（常数5）</strong>,<br><strong>Thread.MAX_PRIORITY（常数10）</strong>。其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY（常数1）</strong> 到<strong>Thread.MAX_PRIORITY（常数10）</strong> 之间，在默认情况下优先级都是<strong>Thread.NORM_PRIORITY（常数5）</strong>。</p>\n<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>\n<h2 id=\"7-Java多线程分类\"><a href=\"#7-Java多线程分类\" class=\"headerlink\" title=\"7 Java多线程分类\"></a>7 Java多线程分类</h2><h3 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h3><p>运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>运行在后台，为其他前台线程服务.也可以说守护线程是JVM中非守护线程的 <strong>“佣人”</strong>。</p>\n<ul>\n<li><strong>特点：</strong> 一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作</li>\n<li><strong>应用：</strong> 数据库连接池中的检测线程，JVM虚拟机启动后的检测线程</li>\n<li><strong>最常见的守护线程：</strong> 垃圾回收线程</li>\n</ul>\n<p><strong>如何设置守护线程？</strong></p>\n<p>可以通过调用 Thead 类的 <code>setDaemon(true)</code> 方法设置当前的线程为守护线程。</p>\n<p>注意事项：</p>\n<pre><code>1.  setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n</code></pre><h2 id=\"8-sleep-方法和wait-方法简单对比\"><a href=\"#8-sleep-方法和wait-方法简单对比\" class=\"headerlink\" title=\"8 sleep()方法和wait()方法简单对比\"></a>8 sleep()方法和wait()方法简单对比</h2><ul>\n<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。 </li>\n<li>两者都可以暂停线程的执行。</li>\n<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>\n<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>\n</ul>\n<h2 id=\"9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\"><a href=\"#9-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？\" class=\"headerlink\" title=\"9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？\"></a>9 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h2><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。<br>start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>\n"},{"title":"Java容器——LinkedList","_content":"\n<!-- MarkdownTOC -->\n\n- [简介](#简介)\n- [内部结构分析](#内部结构分析)\n- [LinkedList源码分析](#linkedlist源码分析)\n    - [构造方法](#构造方法)\n    - [添加（add）方法](#add方法)\n    - [根据位置取数据的方法](#根据位置取数据的方法)\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\n    - [检查链表是否包含某对象的方法：](#检查链表是否包含某对象的方法：)\n    - [删除（remove/pop）方法](#删除方法)\n- [LinkedList类常用方法测试：](#linkedlist类常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n## <font face=\"楷体\" id=\"1\">简介</font>\n<font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。 \nLinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\nLinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法： \n```java\nList list=Collections.synchronizedList(new LinkedList(...));\n```\n## <font face=\"楷体\" id=\"2\">内部结构分析</font>\n**如下图所示：**\n![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)\n看完了图之后，我们再看LinkedList类中的一个<font color=\"red\">**内部私有类Node**</font>就很好理解了：\n```java\nprivate static class Node<E> {\n        E item;//节点值\n        Node<E> next;//后继节点\n        Node<E> prev;//前驱节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\n\n## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font>\n### <font face=\"楷体\" id=\"3.1\">构造方法</font>\n**空构造方法：**\n```java\n    public LinkedList() {\n    }\n```\n**用已有的集合创建链表的构造方法：**\n```java\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\n### <font face=\"楷体\" id=\"3.2\">add方法</font>\n**add(E e)** 方法：将元素添加到链表尾部\n```java\npublic boolean add(E e) {\n        linkLast(e);//这里就只调用了这一个方法\n        return true;\n    }\n```\n\n```java\n   /**\n     * 链接使e作为最后一个元素。\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;//新建节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;//指向后继元素也就是指向下一个元素\n        size++;\n        modCount++;\n    }\n```\n**add(int index,E e)**：在指定位置添加元素\n```java\npublic void add(int index, E element) {\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\n\n        if (index == size)//添加在链表尾部\n            linkLast(element);\n        else//添加在链表中间\n            linkBefore(element, node(index));\n    }\n```\n<font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n**addAll(Collection  c )：将集合插入到链表尾部**\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n```\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n        //1:检查index范围是否在size之内\n        checkPositionIndex(index);\n\n        //2:toArray()方法把集合的数据存到对象数组中\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        //3：得到插入位置的前驱节点和后继节点\n        Node<E> pred, succ;\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\n        if (index == size) {\n            succ = null;\n            pred = last;\n        }\n        //否则，调用node()方法得到后继节点，再得到前驱节点\n        else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 4：遍历数据将数据插入\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果插入位置在链表头部\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        //如果插入位置在尾部，重置last节点\n        if (succ == null) {\n            last = pred;\n        }\n        //否则，将插入的链表与先前链表连接起来\n        else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }    \n```\n上面可以看出addAll方法通常包括下面四个步骤：\n1. 检查index范围是否在size之内\n2. toArray()方法把集合的数据存到对象数组中\n3. 得到插入位置的前驱和后继节点\n4. 遍历数据，将数据插入到指定位置\n\n**addFirst(E e)：** 将元素添加到链表头部\n```java\n public void addFirst(E e) {\n        linkFirst(e);\n    }\n```\n```java\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\n        first = newNode;\n        //如果链表为空，last节点也指向该节点\n        if (f == null)\n            last = newNode;\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\n```java\npublic void addLast(E e) {\n        linkLast(e);\n    }\n```\n### <font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font>\n**get(int index)：** 根据指定索引返回数据\n```java\npublic E get(int index) {\n        //检查index范围是否在size之内\n        checkElementIndex(index);\n        //调用Node(index)去找到index对应的node然后返回它的值\n        return node(index).item;\n    }\n```\n**获取头节点（index=0）数据方法:**\n```java\npublic E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\npublic E element() {\n        return getFirst();\n    }\npublic E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\npublic E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n```\n**区别：**\ngetFirst(),element(),peek(),peekFirst()\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\n\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \n**获取尾节点（index=-1）数据方法:**\n```java\n public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n```\n**两者区别：**\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\n### <font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font>\n**int indexOf(Object o)：** 从头遍历找\n```java\npublic int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n**int lastIndexOf(Object o)：** 从尾遍历找\n```java\npublic int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font>\n**contains(Object o)：** 检查对象o是否存在于链表中\n```java\n public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.6\">删除方法</font>\n**remove()** ,**removeFirst(),pop():** 删除头节点\n```\npublic E pop() {\n        return removeFirst();\n    }\npublic E remove() {\n        return removeFirst();\n    }\npublic E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n```\n**removeLast(),pollLast():** 删除尾节点\n```java\npublic E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\npublic E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n```\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\n\n**remove(Object o):** 删除指定元素\n```java\npublic boolean remove(Object o) {\n        //如果删除对象为null\n        if (o == null) {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (x.item == null) {\n                   //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (o.equals(x.item)) {\n                    //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\n\nunlink(Node<E> x) 方法：\n```java\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;//得到后继节点\n        final Node<E> prev = x.prev;//得到前驱节点\n\n        //删除前驱指针\n        if (prev == null) {\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\n        } else {\n            prev.next = next;//将前驱节点的后继节点指向后继节点\n            x.prev = null;\n        }\n\n        //删除后继指针\n        if (next == null) {\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n**remove(int index)**：删除指定位置的元素\n```java\npublic E remove(int index) {\n        //检查index范围\n        checkElementIndex(index);\n        //将节点删除\n        return unlink(node(index));\n    }\n```\n## <font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font>\n\n```java\npackage list;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] srgs) {\n        //创建存放int类型的linkedList\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        /************************** linkedList的基本操作 ************************/\n        linkedList.addFirst(0); // 添加元素到列表开头\n        linkedList.add(1); // 在列表结尾添加元素\n        linkedList.add(2, 2); // 在指定位置添加元素\n        linkedList.addLast(3); // 添加元素到列表结尾\n        \n        System.out.println(\"LinkedList（直接输出的）: \" + linkedList);\n\n        System.out.println(\"getFirst()获得第一个元素: \" + linkedList.getFirst()); // 返回此列表的第一个元素\n        System.out.println(\"getLast()获得第最后一个元素: \" + linkedList.getLast()); // 返回此列表的最后一个元素\n        System.out.println(\"removeFirst()删除第一个元素并返回: \" + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\n        System.out.println(\"removeLast()删除最后一个元素并返回: \" + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\n        System.out.println(\"After remove:\" + linkedList);\n        System.out.println(\"contains()方法判断列表是否包含1这个元素:\" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\n        System.out.println(\"该linkedList的大小 : \" + linkedList.size()); // 返回此列表的元素个数\n\n        /************************** 位置访问操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\n        System.out.println(\"After set(1, 3):\" + linkedList);\n        System.out.println(\"get(1)获得指定位置（这里为1）的元素: \" + linkedList.get(1)); // 返回此列表中指定位置处的元素\n\n        /************************** Search操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.add(3);\n        System.out.println(\"indexOf(3): \" + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\n        System.out.println(\"lastIndexOf(3): \" + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\n\n        /************************** Queue操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        System.out.println(\"peek(): \" + linkedList.peek()); // 获取但不移除此列表的头\n        System.out.println(\"element(): \" + linkedList.element()); // 获取但不移除此列表的头\n        linkedList.poll(); // 获取并移除此列表的头\n        System.out.println(\"After poll():\" + linkedList);\n        linkedList.remove();\n        System.out.println(\"After remove():\" + linkedList); // 获取并移除此列表的头\n        linkedList.offer(4);\n        System.out.println(\"After offer(4):\" + linkedList); // 将指定元素添加到此列表的末尾\n\n        /************************** Deque操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\n        System.out.println(\"After offerFirst(2):\" + linkedList);\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\n        System.out.println(\"After offerLast(5):\" + linkedList);\n        System.out.println(\"peekFirst(): \" + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\n        System.out.println(\"peekLast(): \" + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\n        System.out.println(\"After pollFirst():\" + linkedList);\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\n        System.out.println(\"After pollLast():\" + linkedList);\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\n        System.out.println(\"After push(2):\" + linkedList);\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\n        System.out.println(\"After pop():\" + linkedList);\n        linkedList.add(3);\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n\n        /************************** 遍历操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.clear();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        // 迭代器遍历\n        long start = System.currentTimeMillis();\n        Iterator<Integer> iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            iterator.next();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"Iterator：\" + (end - start) + \" ms\");\n\n        // 顺序遍历(随机遍历)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedList.get(i);\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"for：\" + (end - start) + \" ms\");\n\n        // 另一种for循环遍历\n        start = System.currentTimeMillis();\n        for (Integer i : linkedList)\n            ;\n        end = System.currentTimeMillis();\n        System.out.println(\"for2：\" + (end - start) + \" ms\");\n\n        // 通过pollFirst()或pollLast()来遍历LinkedList\n        LinkedList<Integer> temp1 = new LinkedList<>();\n        temp1.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp1.size() != 0) {\n            temp1.pollFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"pollFirst()或pollLast()：\" + (end - start) + \" ms\");\n\n        // 通过removeFirst()或removeLast()来遍历LinkedList\n        LinkedList<Integer> temp2 = new LinkedList<>();\n        temp2.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp2.size() != 0) {\n            temp2.removeFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"removeFirst()或removeLast()：\" + (end - start) + \" ms\");\n    }\n}\n```\n","source":"_posts/Java/Collection-Framework/LinkedList.md","raw":"---\ntitle: Java容器——LinkedList\ncategories:\n  - Java\n  - Collection-Framework\ntags: \n- linked-list\n---\n\n<!-- MarkdownTOC -->\n\n- [简介](#简介)\n- [内部结构分析](#内部结构分析)\n- [LinkedList源码分析](#linkedlist源码分析)\n    - [构造方法](#构造方法)\n    - [添加（add）方法](#add方法)\n    - [根据位置取数据的方法](#根据位置取数据的方法)\n    - [根据对象得到索引的方法](#根据对象得到索引的方法)\n    - [检查链表是否包含某对象的方法：](#检查链表是否包含某对象的方法：)\n    - [删除（remove/pop）方法](#删除方法)\n- [LinkedList类常用方法测试：](#linkedlist类常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n## <font face=\"楷体\" id=\"1\">简介</font>\n<font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。 \nLinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;\nLinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法： \n```java\nList list=Collections.synchronizedList(new LinkedList(...));\n```\n## <font face=\"楷体\" id=\"2\">内部结构分析</font>\n**如下图所示：**\n![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)\n看完了图之后，我们再看LinkedList类中的一个<font color=\"red\">**内部私有类Node**</font>就很好理解了：\n```java\nprivate static class Node<E> {\n        E item;//节点值\n        Node<E> next;//后继节点\n        Node<E> prev;//前驱节点\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。\n\n## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font>\n### <font face=\"楷体\" id=\"3.1\">构造方法</font>\n**空构造方法：**\n```java\n    public LinkedList() {\n    }\n```\n**用已有的集合创建链表的构造方法：**\n```java\n    public LinkedList(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n```\n### <font face=\"楷体\" id=\"3.2\">add方法</font>\n**add(E e)** 方法：将元素添加到链表尾部\n```java\npublic boolean add(E e) {\n        linkLast(e);//这里就只调用了这一个方法\n        return true;\n    }\n```\n\n```java\n   /**\n     * 链接使e作为最后一个元素。\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;//新建节点\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;//指向后继元素也就是指向下一个元素\n        size++;\n        modCount++;\n    }\n```\n**add(int index,E e)**：在指定位置添加元素\n```java\npublic void add(int index, E element) {\n        checkPositionIndex(index); //检查索引是否处于[0-size]之间\n\n        if (index == size)//添加在链表尾部\n            linkLast(element);\n        else//添加在链表中间\n            linkBefore(element, node(index));\n    }\n```\n<font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n**addAll(Collection  c )：将集合插入到链表尾部**\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n```\n**addAll(int index, Collection c)：** 将集合从指定位置开始插入\n```java\npublic boolean addAll(int index, Collection<? extends E> c) {\n        //1:检查index范围是否在size之内\n        checkPositionIndex(index);\n\n        //2:toArray()方法把集合的数据存到对象数组中\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n\n        //3：得到插入位置的前驱节点和后继节点\n        Node<E> pred, succ;\n        //如果插入位置为尾部，前驱节点为last，后继节点为null\n        if (index == size) {\n            succ = null;\n            pred = last;\n        }\n        //否则，调用node()方法得到后继节点，再得到前驱节点\n        else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n\n        // 4：遍历数据将数据插入\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            //创建新节点\n            Node<E> newNode = new Node<>(pred, e, null);\n            //如果插入位置在链表头部\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n\n        //如果插入位置在尾部，重置last节点\n        if (succ == null) {\n            last = pred;\n        }\n        //否则，将插入的链表与先前链表连接起来\n        else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n\n        size += numNew;\n        modCount++;\n        return true;\n    }    \n```\n上面可以看出addAll方法通常包括下面四个步骤：\n1. 检查index范围是否在size之内\n2. toArray()方法把集合的数据存到对象数组中\n3. 得到插入位置的前驱和后继节点\n4. 遍历数据，将数据插入到指定位置\n\n**addFirst(E e)：** 将元素添加到链表头部\n```java\n public void addFirst(E e) {\n        linkFirst(e);\n    }\n```\n```java\nprivate void linkFirst(E e) {\n        final Node<E> f = first;\n        final Node<E> newNode = new Node<>(null, e, f);//新建节点，以头节点为后继节点\n        first = newNode;\n        //如果链表为空，last节点也指向该节点\n        if (f == null)\n            last = newNode;\n        //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素\n        else\n            f.prev = newNode;\n        size++;\n        modCount++;\n    }\n```\n**addLast(E e)：** 将元素添加到链表尾部，与 **add(E e)** 方法一样\n```java\npublic void addLast(E e) {\n        linkLast(e);\n    }\n```\n### <font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font>\n**get(int index)：** 根据指定索引返回数据\n```java\npublic E get(int index) {\n        //检查index范围是否在size之内\n        checkElementIndex(index);\n        //调用Node(index)去找到index对应的node然后返回它的值\n        return node(index).item;\n    }\n```\n**获取头节点（index=0）数据方法:**\n```java\npublic E getFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return f.item;\n    }\npublic E element() {\n        return getFirst();\n    }\npublic E peek() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n    }\n\npublic E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n```\n**区别：**\ngetFirst(),element(),peek(),peekFirst()\n这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中**getFirst()** 和**element()** 方法将会在链表为空时，抛出异常\n\nelement()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException  \n**获取尾节点（index=-1）数据方法:**\n```java\n public E getLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return l.item;\n    }\n public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n```\n**两者区别：**\n**getLast()** 方法在链表为空时，会抛出**NoSuchElementException**，而**peekLast()** 则不会，只是会返回 **null**。\n### <font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font>\n**int indexOf(Object o)：** 从头遍历找\n```java\npublic int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            //从头遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n**int lastIndexOf(Object o)：** 从尾遍历找\n```java\npublic int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            //从尾遍历\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font>\n**contains(Object o)：** 检查对象o是否存在于链表中\n```java\n public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n```\n### <font face=\"楷体\" id=\"3.6\">删除方法</font>\n**remove()** ,**removeFirst(),pop():** 删除头节点\n```\npublic E pop() {\n        return removeFirst();\n    }\npublic E remove() {\n        return removeFirst();\n    }\npublic E removeFirst() {\n        final Node<E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    }\n```\n**removeLast(),pollLast():** 删除尾节点\n```java\npublic E removeLast() {\n        final Node<E> l = last;\n        if (l == null)\n            throw new NoSuchElementException();\n        return unlinkLast(l);\n    }\npublic E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n```\n**区别：** removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。\n\n**remove(Object o):** 删除指定元素\n```java\npublic boolean remove(Object o) {\n        //如果删除对象为null\n        if (o == null) {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (x.item == null) {\n                   //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            //从头开始遍历\n            for (Node<E> x = first; x != null; x = x.next) {\n                //找到元素\n                if (o.equals(x.item)) {\n                    //从链表中移除找到的元素\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n```\n当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。\n\nunlink(Node<E> x) 方法：\n```java\nE unlink(Node<E> x) {\n        // assert x != null;\n        final E element = x.item;\n        final Node<E> next = x.next;//得到后继节点\n        final Node<E> prev = x.prev;//得到前驱节点\n\n        //删除前驱指针\n        if (prev == null) {\n            first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点\n        } else {\n            prev.next = next;//将前驱节点的后继节点指向后继节点\n            x.prev = null;\n        }\n\n        //删除后继指针\n        if (next == null) {\n            last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n        } else {\n            next.prev = prev;\n            x.next = null;\n        }\n\n        x.item = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n**remove(int index)**：删除指定位置的元素\n```java\npublic E remove(int index) {\n        //检查index范围\n        checkElementIndex(index);\n        //将节点删除\n        return unlink(node(index));\n    }\n```\n## <font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font>\n\n```java\npackage list;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] srgs) {\n        //创建存放int类型的linkedList\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        /************************** linkedList的基本操作 ************************/\n        linkedList.addFirst(0); // 添加元素到列表开头\n        linkedList.add(1); // 在列表结尾添加元素\n        linkedList.add(2, 2); // 在指定位置添加元素\n        linkedList.addLast(3); // 添加元素到列表结尾\n        \n        System.out.println(\"LinkedList（直接输出的）: \" + linkedList);\n\n        System.out.println(\"getFirst()获得第一个元素: \" + linkedList.getFirst()); // 返回此列表的第一个元素\n        System.out.println(\"getLast()获得第最后一个元素: \" + linkedList.getLast()); // 返回此列表的最后一个元素\n        System.out.println(\"removeFirst()删除第一个元素并返回: \" + linkedList.removeFirst()); // 移除并返回此列表的第一个元素\n        System.out.println(\"removeLast()删除最后一个元素并返回: \" + linkedList.removeLast()); // 移除并返回此列表的最后一个元素\n        System.out.println(\"After remove:\" + linkedList);\n        System.out.println(\"contains()方法判断列表是否包含1这个元素:\" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true\n        System.out.println(\"该linkedList的大小 : \" + linkedList.size()); // 返回此列表的元素个数\n\n        /************************** 位置访问操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素\n        System.out.println(\"After set(1, 3):\" + linkedList);\n        System.out.println(\"get(1)获得指定位置（这里为1）的元素: \" + linkedList.get(1)); // 返回此列表中指定位置处的元素\n\n        /************************** Search操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.add(3);\n        System.out.println(\"indexOf(3): \" + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引\n        System.out.println(\"lastIndexOf(3): \" + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引\n\n        /************************** Queue操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        System.out.println(\"peek(): \" + linkedList.peek()); // 获取但不移除此列表的头\n        System.out.println(\"element(): \" + linkedList.element()); // 获取但不移除此列表的头\n        linkedList.poll(); // 获取并移除此列表的头\n        System.out.println(\"After poll():\" + linkedList);\n        linkedList.remove();\n        System.out.println(\"After remove():\" + linkedList); // 获取并移除此列表的头\n        linkedList.offer(4);\n        System.out.println(\"After offer(4):\" + linkedList); // 将指定元素添加到此列表的末尾\n\n        /************************** Deque操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素\n        System.out.println(\"After offerFirst(2):\" + linkedList);\n        linkedList.offerLast(5); // 在此列表末尾插入指定的元素\n        System.out.println(\"After offerLast(5):\" + linkedList);\n        System.out.println(\"peekFirst(): \" + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素\n        System.out.println(\"peekLast(): \" + linkedList.peekLast()); // 获取但不移除此列表的第一个元素\n        linkedList.pollFirst(); // 获取并移除此列表的第一个元素\n        System.out.println(\"After pollFirst():\" + linkedList);\n        linkedList.pollLast(); // 获取并移除此列表的最后一个元素\n        System.out.println(\"After pollLast():\" + linkedList);\n        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）\n        System.out.println(\"After push(2):\" + linkedList);\n        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）\n        System.out.println(\"After pop():\" + linkedList);\n        linkedList.add(3);\n        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）\n        System.out.println(\"After removeFirstOccurrence(3):\" + linkedList);\n\n        /************************** 遍历操作 ************************/\n        System.out.println(\"-----------------------------------------\");\n        linkedList.clear();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        // 迭代器遍历\n        long start = System.currentTimeMillis();\n        Iterator<Integer> iterator = linkedList.iterator();\n        while (iterator.hasNext()) {\n            iterator.next();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"Iterator：\" + (end - start) + \" ms\");\n\n        // 顺序遍历(随机遍历)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedList.get(i);\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"for：\" + (end - start) + \" ms\");\n\n        // 另一种for循环遍历\n        start = System.currentTimeMillis();\n        for (Integer i : linkedList)\n            ;\n        end = System.currentTimeMillis();\n        System.out.println(\"for2：\" + (end - start) + \" ms\");\n\n        // 通过pollFirst()或pollLast()来遍历LinkedList\n        LinkedList<Integer> temp1 = new LinkedList<>();\n        temp1.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp1.size() != 0) {\n            temp1.pollFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"pollFirst()或pollLast()：\" + (end - start) + \" ms\");\n\n        // 通过removeFirst()或removeLast()来遍历LinkedList\n        LinkedList<Integer> temp2 = new LinkedList<>();\n        temp2.addAll(linkedList);\n        start = System.currentTimeMillis();\n        while (temp2.size() != 0) {\n            temp2.removeFirst();\n        }\n        end = System.currentTimeMillis();\n        System.out.println(\"removeFirst()或removeLast()：\" + (end - start) + \" ms\");\n    }\n}\n```\n","slug":"Java/Collection-Framework/LinkedList","published":1,"date":"2019-03-22T10:16:45.426Z","updated":"2019-03-23T03:49:13.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge2f00fgqnn9i19lnrmk","content":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#简介\">简介</a></li>\n<li><a href=\"#内部结构分析\">内部结构分析</a></li>\n<li><a href=\"#linkedlist源码分析\">LinkedList源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#add方法\">添加（add）方法</a></li>\n<li><a href=\"#根据位置取数据的方法\">根据位置取数据的方法</a></li>\n<li><a href=\"#根据对象得到索引的方法\">根据对象得到索引的方法</a></li>\n<li><a href=\"#检查链表是否包含某对象的方法：\">检查链表是否包含某对象的方法：</a></li>\n<li><a href=\"#删除方法\">删除（remove/pop）方法</a></li>\n</ul>\n</li>\n<li><a href=\"#linkedlist类常用方法测试\">LinkedList类常用方法测试：</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font face=\"楷体\" id=\"1\">简介</font></h2><font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。<br>LinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><br><br>## <font face=\"楷体\" id=\"2\">内部结构分析</font><br><strong>如下图所示：</strong><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&amp;h=481&amp;f=jpeg&amp;s=18502\" alt=\"LinkedList内部结构\"><br>看完了图之后，我们再看LinkedList类中的一个<font color=\"red\"><strong>内部私有类Node</strong></font>就很好理解了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        E item;<span class=\"comment\">//节点值</span></span><br><span class=\"line\">        Node&lt;E&gt; next;<span class=\"comment\">//后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; prev;<span class=\"comment\">//前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。<br><br>## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font><br>### <font face=\"楷体\" id=\"3.1\">构造方法</font><br><strong>空构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>用已有的集合创建链表的构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>### <font face=\"楷体\" id=\"3.2\">add方法</font><br><strong>add(E e)</strong> 方法：将元素添加到链表尾部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);<span class=\"comment\">//这里就只调用了这一个方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 链接使e作为最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">     last = newNode;<span class=\"comment\">//新建节点</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">         first = newNode;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">         l.next = newNode;<span class=\"comment\">//指向后继元素也就是指向下一个元素</span></span><br><span class=\"line\">     size++;</span><br><span class=\"line\">     modCount++;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br><br><strong>add(int index,E e)</strong>：在指定位置添加元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index); <span class=\"comment\">//检查索引是否处于[0-size]之间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//添加在链表尾部</span></span><br><span class=\"line\">            linkLast(element);</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//添加在链表中间</span></span><br><span class=\"line\">            linkBefore(element, node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n<p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1:检查index范围是否在size之内</span></span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">            succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            pred = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            succ = node(index);</span><br><span class=\"line\">            pred = succ.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4：遍历数据将数据插入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">            <span class=\"comment\">//创建新节点</span></span><br><span class=\"line\">            Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">//如果插入位置在链表头部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                first = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                pred.next = newNode;</span><br><span class=\"line\">            pred = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置在尾部，重置last节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将插入的链表与先前链表连接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pred.next = succ;</span><br><span class=\"line\">            succ.prev = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看出addAll方法通常包括下面四个步骤：</p>\n<ol>\n<li>检查index范围是否在size之内</li>\n<li>toArray()方法把集合的数据存到对象数组中</li>\n<li>得到插入位置的前驱和后继节点</li>\n<li>遍历数据，将数据插入到指定位置</li>\n</ol>\n<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       linkFirst(e);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);<span class=\"comment\">//新建节点，以头节点为后继节点</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表为空，last节点也指向该节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            last = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.prev = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"根据位置取数据的方法\"><a href=\"#根据位置取数据的方法\" class=\"headerlink\" title=\"根据位置取数据的方法\"></a><font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围是否在size之内</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>获取头节点（index=0）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>\n<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : l.item;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>\n<h3 id=\"根据对象得到索引的方法\"><a href=\"#根据对象得到索引的方法\" class=\"headerlink\" title=\"根据对象得到索引的方法\"></a><font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"检查链表是否包含某对象的方法：\"><a href=\"#检查链表是否包含某对象的方法：\" class=\"headerlink\" title=\"检查链表是否包含某对象的方法：\"></a><font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除方法\"><a href=\"#删除方法\" class=\"headerlink\" title=\"删除方法\"></a><font face=\"楷体\" id=\"3.6\">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E pop() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E remove() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E removeFirst() &#123;</span><br><span class=\"line\">        final Node&lt;E&gt; f = first;</span><br><span class=\"line\">        if (f == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        return unlinkFirst(f);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>removeLast(),pollLast():</strong> 删除尾节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>\n<p><strong>remove(Object o):</strong> 删除指定元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果删除对象为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p>\n<p>unlink(Node<e> x) 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;<span class=\"comment\">//得到后继节点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;<span class=\"comment\">//得到前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除前驱指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = next;<span class=\"comment\">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev.next = next;<span class=\"comment\">//将前驱节点的后继节点指向后继节点</span></span><br><span class=\"line\">            x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除后继指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = prev;<span class=\"comment\">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next.prev = prev;</span><br><span class=\"line\">            x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></e></p>\n<p><strong>remove(int index)</strong>：删除指定位置的元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//将节点删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"LinkedList类常用方法测试\"><a href=\"#LinkedList类常用方法测试\" class=\"headerlink\" title=\"LinkedList类常用方法测试\"></a><font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedListDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建存放int类型的linkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">/************************** linkedList的基本操作 ************************/</span></span><br><span class=\"line\">        linkedList.addFirst(<span class=\"number\">0</span>); <span class=\"comment\">// 添加元素到列表开头</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">1</span>); <span class=\"comment\">// 在列表结尾添加元素</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">        linkedList.addLast(<span class=\"number\">3</span>); <span class=\"comment\">// 添加元素到列表结尾</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"LinkedList（直接输出的）: \"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getFirst()获得第一个元素: \"</span> + linkedList.getFirst()); <span class=\"comment\">// 返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getLast()获得第最后一个元素: \"</span> + linkedList.getLast()); <span class=\"comment\">// 返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()删除第一个元素并返回: \"</span> + linkedList.removeFirst()); <span class=\"comment\">// 移除并返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeLast()删除最后一个元素并返回: \"</span> + linkedList.removeLast()); <span class=\"comment\">// 移除并返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove:\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"contains()方法判断列表是否包含1这个元素:\"</span> + linkedList.contains(<span class=\"number\">1</span>)); <span class=\"comment\">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该linkedList的大小 : \"</span> + linkedList.size()); <span class=\"comment\">// 返回此列表的元素个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 位置访问操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.set(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After set(1, 3):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"get(1)获得指定位置（这里为1）的元素: \"</span> + linkedList.get(<span class=\"number\">1</span>)); <span class=\"comment\">// 返回此列表中指定位置处的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Search操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"indexOf(3): \"</span> + linkedList.indexOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lastIndexOf(3): \"</span> + linkedList.lastIndexOf(<span class=\"number\">3</span>));<span class=\"comment\">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Queue操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peek(): \"</span> + linkedList.peek()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"element(): \"</span> + linkedList.element()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        linkedList.poll(); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After poll():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.remove();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove():\"</span> + linkedList); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        linkedList.offer(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offer(4):\"</span> + linkedList); <span class=\"comment\">// 将指定元素添加到此列表的末尾</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Deque操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.offerFirst(<span class=\"number\">2</span>); <span class=\"comment\">// 在此列表的开头插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerFirst(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.offerLast(<span class=\"number\">5</span>); <span class=\"comment\">// 在此列表末尾插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerLast(5):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekFirst(): \"</span> + linkedList.peekFirst()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekLast(): \"</span> + linkedList.peekLast()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        linkedList.pollFirst(); <span class=\"comment\">// 获取并移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollFirst():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pollLast(); <span class=\"comment\">// 获取并移除此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollLast():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.push(<span class=\"number\">2</span>); <span class=\"comment\">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After push(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pop(); <span class=\"comment\">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pop():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        linkedList.removeFirstOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.removeLastOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 遍历操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">            linkedList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代器遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            iterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Iterator：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顺序遍历(随机遍历)</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class=\"line\">            linkedList.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 另一种for循环遍历</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : linkedList)</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for2：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp1.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp1.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"pollFirst()或pollLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp2.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp2.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp2.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()或removeLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#简介\">简介</a></li>\n<li><a href=\"#内部结构分析\">内部结构分析</a></li>\n<li><a href=\"#linkedlist源码分析\">LinkedList源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#add方法\">添加（add）方法</a></li>\n<li><a href=\"#根据位置取数据的方法\">根据位置取数据的方法</a></li>\n<li><a href=\"#根据对象得到索引的方法\">根据对象得到索引的方法</a></li>\n<li><a href=\"#检查链表是否包含某对象的方法：\">检查链表是否包含某对象的方法：</a></li>\n<li><a href=\"#删除方法\">删除（remove/pop）方法</a></li>\n</ul>\n</li>\n<li><a href=\"#linkedlist类常用方法测试\">LinkedList类常用方法测试：</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font face=\"楷体\" id=\"1\">简介</font></h2><font color=\"red\">LinkedList</font>是一个实现了<font color=\"red\">List接口</font>和<font color=\"red\">Deque接口</font>的<font color=\"red\">双端链表</font>。<br>LinkedList底层的链表结构使它<font color=\"red\">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color=\"red\">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color=\"red\">Collections类</font>中的<font color=\"red\">synchronizedList</font>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><br><br>## <font face=\"楷体\" id=\"2\">内部结构分析</font><br><strong>如下图所示：</strong><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&amp;h=481&amp;f=jpeg&amp;s=18502\" alt=\"LinkedList内部结构\"><br>看完了图之后，我们再看LinkedList类中的一个<font color=\"red\"><strong>内部私有类Node</strong></font>就很好理解了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        E item;<span class=\"comment\">//节点值</span></span><br><span class=\"line\">        Node&lt;E&gt; next;<span class=\"comment\">//后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; prev;<span class=\"comment\">//前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。<br><br>## <font face=\"楷体\" id=\"3\">LinkedList源码分析</font><br>### <font face=\"楷体\" id=\"3.1\">构造方法</font><br><strong>空构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>用已有的集合创建链表的构造方法：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br>### <font face=\"楷体\" id=\"3.2\">add方法</font><br><strong>add(E e)</strong> 方法：将元素添加到链表尾部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);<span class=\"comment\">//这里就只调用了这一个方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 链接使e作为最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">     <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">     last = newNode;<span class=\"comment\">//新建节点</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">         first = newNode;</span><br><span class=\"line\">     <span class=\"keyword\">else</span></span><br><span class=\"line\">         l.next = newNode;<span class=\"comment\">//指向后继元素也就是指向下一个元素</span></span><br><span class=\"line\">     size++;</span><br><span class=\"line\">     modCount++;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><br><br><strong>add(int index,E e)</strong>：在指定位置添加元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        checkPositionIndex(index); <span class=\"comment\">//检查索引是否处于[0-size]之间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size)<span class=\"comment\">//添加在链表尾部</span></span><br><span class=\"line\">            linkLast(element);</span><br><span class=\"line\">        <span class=\"keyword\">else</span><span class=\"comment\">//添加在链表中间</span></span><br><span class=\"line\">            linkBefore(element, node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br><br><font color=\"red\">linkBefore方法</font>需要给定两个参数，一个<font color=\"red\">插入节点的值</font>，一个<font color=\"red\">指定的node</font>，所以我们又调用了<font color=\"red\">Node(index)去找到index对应的node</font>\n\n<p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1:检查index范围是否在size之内</span></span><br><span class=\"line\">        checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class=\"line\">        Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">            succ = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            pred = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            succ = node(index);</span><br><span class=\"line\">            pred = succ.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4：遍历数据将数据插入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>) E e = (E) o;</span><br><span class=\"line\">            <span class=\"comment\">//创建新节点</span></span><br><span class=\"line\">            Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">//如果插入位置在链表头部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                first = newNode;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                pred.next = newNode;</span><br><span class=\"line\">            pred = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果插入位置在尾部，重置last节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (succ == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将插入的链表与先前链表连接起来</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            pred.next = succ;</span><br><span class=\"line\">            succ.prev = pred;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看出addAll方法通常包括下面四个步骤：</p>\n<ol>\n<li>检查index范围是否在size之内</li>\n<li>toArray()方法把集合的数据存到对象数组中</li>\n<li>得到插入位置的前驱和后继节点</li>\n<li>遍历数据，将数据插入到指定位置</li>\n</ol>\n<p><strong>addFirst(E e)：</strong> 将元素添加到链表头部<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">       linkFirst(e);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);<span class=\"comment\">//新建节点，以头节点为后继节点</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//如果链表为空，last节点也指向该节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            last = newNode;</span><br><span class=\"line\">        <span class=\"comment\">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.prev = newNode;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        linkLast(e);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"根据位置取数据的方法\"><a href=\"#根据位置取数据的方法\" class=\"headerlink\" title=\"根据位置取数据的方法\"></a><font face=\"楷体\" id=\"3.3\">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围是否在size之内</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>获取头节点（index=0）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">element</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (f == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : f.item;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p>\n<p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> l.item;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">peekLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : l.item;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p>\n<h3 id=\"根据对象得到索引的方法\"><a href=\"#根据对象得到索引的方法\" class=\"headerlink\" title=\"根据对象得到索引的方法\"></a><font face=\"楷体\" id=\"3.4\">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从尾遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = last; x != <span class=\"keyword\">null</span>; x = x.prev) &#123;</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"检查链表是否包含某对象的方法：\"><a href=\"#检查链表是否包含某对象的方法：\" class=\"headerlink\" title=\"检查链表是否包含某对象的方法：\"></a><font face=\"楷体\" id=\"3.5\">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> indexOf(o) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除方法\"><a href=\"#删除方法\" class=\"headerlink\" title=\"删除方法\"></a><font face=\"楷体\" id=\"3.6\">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E pop() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E remove() &#123;</span><br><span class=\"line\">        return removeFirst();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">public E removeFirst() &#123;</span><br><span class=\"line\">        final Node&lt;E&gt; f = first;</span><br><span class=\"line\">        if (f == null)</span><br><span class=\"line\">            throw new NoSuchElementException();</span><br><span class=\"line\">        return unlinkFirst(f);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>removeLast(),pollLast():</strong> 删除尾节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (l == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : unlinkLast(l);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p>\n<p><strong>remove(Object o):</strong> 删除指定元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果删除对象为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//从头开始遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//从链表中移除找到的元素</span></span><br><span class=\"line\">                    unlink(x);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p>\n<p>unlink(Node<e> x) 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;<span class=\"comment\">//得到后继节点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;<span class=\"comment\">//得到前驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除前驱指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = next;<span class=\"comment\">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev.next = next;<span class=\"comment\">//将前驱节点的后继节点指向后继节点</span></span><br><span class=\"line\">            x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//删除后继指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            last = prev;<span class=\"comment\">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            next.prev = prev;</span><br><span class=\"line\">            x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></e></p>\n<p><strong>remove(int index)</strong>：删除指定位置的元素<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查index范围</span></span><br><span class=\"line\">        checkElementIndex(index);</span><br><span class=\"line\">        <span class=\"comment\">//将节点删除</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"LinkedList类常用方法测试\"><a href=\"#LinkedList类常用方法测试\" class=\"headerlink\" title=\"LinkedList类常用方法测试\"></a><font face=\"楷体\" id=\"4\">LinkedList类常用方法测试</font></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedListDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建存放int类型的linkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">/************************** linkedList的基本操作 ************************/</span></span><br><span class=\"line\">        linkedList.addFirst(<span class=\"number\">0</span>); <span class=\"comment\">// 添加元素到列表开头</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">1</span>); <span class=\"comment\">// 在列表结尾添加元素</span></span><br><span class=\"line\">        linkedList.add(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">        linkedList.addLast(<span class=\"number\">3</span>); <span class=\"comment\">// 添加元素到列表结尾</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"LinkedList（直接输出的）: \"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getFirst()获得第一个元素: \"</span> + linkedList.getFirst()); <span class=\"comment\">// 返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"getLast()获得第最后一个元素: \"</span> + linkedList.getLast()); <span class=\"comment\">// 返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()删除第一个元素并返回: \"</span> + linkedList.removeFirst()); <span class=\"comment\">// 移除并返回此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeLast()删除最后一个元素并返回: \"</span> + linkedList.removeLast()); <span class=\"comment\">// 移除并返回此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove:\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"contains()方法判断列表是否包含1这个元素:\"</span> + linkedList.contains(<span class=\"number\">1</span>)); <span class=\"comment\">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"该linkedList的大小 : \"</span> + linkedList.size()); <span class=\"comment\">// 返回此列表的元素个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 位置访问操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.set(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After set(1, 3):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"get(1)获得指定位置（这里为1）的元素: \"</span> + linkedList.get(<span class=\"number\">1</span>)); <span class=\"comment\">// 返回此列表中指定位置处的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Search操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"indexOf(3): \"</span> + linkedList.indexOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"lastIndexOf(3): \"</span> + linkedList.lastIndexOf(<span class=\"number\">3</span>));<span class=\"comment\">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Queue操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peek(): \"</span> + linkedList.peek()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"element(): \"</span> + linkedList.element()); <span class=\"comment\">// 获取但不移除此列表的头</span></span><br><span class=\"line\">        linkedList.poll(); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After poll():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.remove();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After remove():\"</span> + linkedList); <span class=\"comment\">// 获取并移除此列表的头</span></span><br><span class=\"line\">        linkedList.offer(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offer(4):\"</span> + linkedList); <span class=\"comment\">// 将指定元素添加到此列表的末尾</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** Deque操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.offerFirst(<span class=\"number\">2</span>); <span class=\"comment\">// 在此列表的开头插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerFirst(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.offerLast(<span class=\"number\">5</span>); <span class=\"comment\">// 在此列表末尾插入指定的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After offerLast(5):\"</span> + linkedList);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekFirst(): \"</span> + linkedList.peekFirst()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"peekLast(): \"</span> + linkedList.peekLast()); <span class=\"comment\">// 获取但不移除此列表的第一个元素</span></span><br><span class=\"line\">        linkedList.pollFirst(); <span class=\"comment\">// 获取并移除此列表的第一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollFirst():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pollLast(); <span class=\"comment\">// 获取并移除此列表的最后一个元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pollLast():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.push(<span class=\"number\">2</span>); <span class=\"comment\">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After push(2):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.pop(); <span class=\"comment\">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After pop():\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">        linkedList.removeFirstOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\">        linkedList.removeLastOccurrence(<span class=\"number\">3</span>); <span class=\"comment\">// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"After removeFirstOccurrence(3):\"</span> + linkedList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/************************** 遍历操作 ************************/</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-----------------------------------------\"</span>);</span><br><span class=\"line\">        linkedList.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">            linkedList.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 迭代器遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            iterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Iterator：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顺序遍历(随机遍历)</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class=\"line\">            linkedList.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 另一种for循环遍历</span></span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer i : linkedList)</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"for2：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp1.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp1.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp1.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"pollFirst()或pollLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class=\"line\">        LinkedList&lt;Integer&gt; temp2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        temp2.addAll(linkedList);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp2.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp2.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"removeFirst()或removeLast()：\"</span> + (end - start) + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java容器——HashMap","_content":"<!-- MarkdownTOC -->\n\n- [HashMap 简介](#hashmap-简介)\n- [底层数据结构分析](#底层数据结构分析)\n  - [JDK1.8之前](#jdk18之前)\n  - [JDK1.8之后](#jdk18之后)\n- [HashMap源码分析](#hashmap源码分析)\n  - [构造方法](#构造方法)\n  - [put方法](#put方法)\n  - [get方法](#get方法)\n  - [resize方法](#resize方法)\n- [HashMap常用方法测试](#hashmap常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\n\n## HashMap 简介\nHashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 \n\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。\n\n## 底层数据结构分析\n### JDK1.8之前\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\n\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n  ```java\n      static final int hash(Object key) {\n        int h;\n        // key.hashCode()：返回散列值也就是hashcode\n        // ^ ：按位异或\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n  ```\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\n\n### JDK1.8之后\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\n\n**类的属性：**\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n}\n```\n- **loadFactor加载因子**\n\n  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n\n  **loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值**。 \n  \n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n- **threshold**\n\n  **threshold = capacity * loadFactor**，**当Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\n\n**Node节点类源码:**\n\n```java\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n**树节点类源码:**\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n```\n## HashMap源码分析\n### 构造方法\n![四个构造方法](https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&h=90&f=jpeg&s=26744)\n```java\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n     \n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);//下面会分析到这个方法\n     }\n     \n     // 指定“容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n     \n     // 指定“容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n```\n\n**putMapEntries方法：**\n\n```java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的t大于阈值，则初始化阈值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n### put方法\nHashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。\n\n**对putVal方法添加元素的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入。\n\n\n\n![put方法](https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&h=679&f=png&s=54486)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n} \n```\n\n**我们再来对比一下 JDK1.7 put方法的代码**\n\n**对于put方法的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。\n\n```java\npublic V put(K key, V value)\n    if (table == EMPTY_TABLE) { \n    inflateTable(threshold); \n}  \n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue; \n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);  // 再插入\n    return null;\n}\n```\n\n\n\n### get方法\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n### resize方法\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else { \n        // signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算新的resize上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n## HashMap常用方法测试\n```java\npackage map;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class HashMapDemo {\n\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        // 键不能重复，值可以重复\n        map.put(\"san\", \"张三\");\n        map.put(\"si\", \"李四\");\n        map.put(\"wu\", \"王五\");\n        map.put(\"wang\", \"老王\");\n        map.put(\"wang\", \"老王2\");// 老王被覆盖\n        map.put(\"lao\", \"老王\");\n        System.out.println(\"-------直接输出hashmap:-------\");\n        System.out.println(map);\n        /**\n         * 遍历HashMap\n         */\n        // 1.获取Map中的所有键\n        System.out.println(\"-------foreach获取Map中所有的键:------\");\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            System.out.print(key+\"  \");\n        }\n        System.out.println();//换行\n        // 2.获取Map中所有值\n        System.out.println(\"-------foreach获取Map中所有的值:------\");\n        Collection<String> values = map.values();\n        for (String value : values) {\n            System.out.print(value+\"  \");\n        }\n        System.out.println();//换行\n        // 3.得到key的值的同时得到key所对应的值\n        System.out.println(\"-------得到key的值的同时得到key所对应的值:-------\");\n        Set<String> keys2 = map.keySet();\n        for (String key : keys2) {\n            System.out.print(key + \"：\" + map.get(key)+\"   \");\n\n        }\n        /**\n         * 另外一种不常用的遍历方式\n         */\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\n        for (java.util.Map.Entry<String, String> entry : entrys) {\n            System.out.println(entry.getKey() + \"--\" + entry.getValue());\n        }\n        \n        /**\n         * HashMap其他常用方法\n         */\n        System.out.println(\"after map.size()：\"+map.size());\n        System.out.println(\"after map.isEmpty()：\"+map.isEmpty());\n        System.out.println(map.remove(\"san\"));\n        System.out.println(\"after map.remove()：\"+map);\n        System.out.println(\"after map.get(si)：\"+map.get(\"si\"));\n        System.out.println(\"after map.containsKey(si)：\"+map.containsKey(\"si\"));\n        System.out.println(\"after containsValue(李四)：\"+map.containsValue(\"李四\"));\n        System.out.println(map.replace(\"si\", \"李四2\"));\n        System.out.println(\"after map.replace(si, 李四2):\"+map);\n    }\n\n}\n\n```\n","source":"_posts/Java/Collection-Framework/HashMap.md","raw":"---\ntitle: Java容器——HashMap\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n- map\n- hashmap\n---\n<!-- MarkdownTOC -->\n\n- [HashMap 简介](#hashmap-简介)\n- [底层数据结构分析](#底层数据结构分析)\n  - [JDK1.8之前](#jdk18之前)\n  - [JDK1.8之后](#jdk18之后)\n- [HashMap源码分析](#hashmap源码分析)\n  - [构造方法](#构造方法)\n  - [put方法](#put方法)\n  - [get方法](#get方法)\n  - [resize方法](#resize方法)\n- [HashMap常用方法测试](#hashmap常用方法测试)\n\n<!-- /MarkdownTOC -->\n\n> 感谢 [changfubai](https://github.com/changfubai) 对本文的改进做出的贡献！\n\n## HashMap 简介\nHashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 \n\nJDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。\n\n## 底层数据结构分析\n### JDK1.8之前\nJDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**\n\n**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**\n\n**JDK 1.8 HashMap 的 hash 方法源码:**\n\nJDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\n\n  ```java\n      static final int hash(Object key) {\n        int h;\n        // key.hashCode()：返回散列值也就是hashcode\n        // ^ ：按位异或\n        // >>>:无符号右移，忽略符号位，空位都以0补齐\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n  ```\n对比一下 JDK1.7的 HashMap 的 hash 方法源码.\n\n```java\nstatic int hash(int h) {\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\n\n所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&h=427&f=png&s=10991)\n\n### JDK1.8之后\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n\n![JDK1.8之后的HashMap底层数据结构](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg)\n\n**类的属性：**\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {\n    // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n}\n```\n- **loadFactor加载因子**\n\n  loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n\n  **loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值**。 \n  \n  给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\n\n- **threshold**\n\n  **threshold = capacity * loadFactor**，**当Size>=threshold**的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 **衡量数组是否需要扩增的一个标准**。\n\n**Node节点类源码:**\n\n```java\n// 继承自 Map.Entry<K,V>\nstatic class Node<K,V> implements Map.Entry<K,V> {\n       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较\n       final K key;//键\n       V value;//值\n       // 指向下一个节点\n       Node<K,V> next;\n       Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n        // 重写hashCode()方法\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n        // 重写 equals() 方法\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n}\n```\n**树节点类源码:**\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 父\n        TreeNode<K,V> left;    // 左\n        TreeNode<K,V> right;   // 右\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;           // 判断颜色\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        // 返回根节点\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n       }\n```\n## HashMap源码分析\n### 构造方法\n![四个构造方法](https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&h=90&f=jpeg&s=26744)\n```java\n    // 默认构造函数。\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted\n     }\n     \n     // 包含另一个“Map”的构造函数\n     public HashMap(Map<? extends K, ? extends V> m) {\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         putMapEntries(m, false);//下面会分析到这个方法\n     }\n     \n     // 指定“容量大小”的构造函数\n     public HashMap(int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n     \n     // 指定“容量大小”和“加载因子”的构造函数\n     public HashMap(int initialCapacity, float loadFactor) {\n         if (initialCapacity < 0)\n             throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\n         if (initialCapacity > MAXIMUM_CAPACITY)\n             initialCapacity = MAXIMUM_CAPACITY;\n         if (loadFactor <= 0 || Float.isNaN(loadFactor))\n             throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\n         this.loadFactor = loadFactor;\n         this.threshold = tableSizeFor(initialCapacity);\n     }\n```\n\n**putMapEntries方法：**\n\n```java\nfinal void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {\n    int s = m.size();\n    if (s > 0) {\n        // 判断table是否已经初始化\n        if (table == null) { // pre-size\n            // 未初始化，s为m的实际元素个数\n            float ft = ((float)s / loadFactor) + 1.0F;\n            int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            // 计算得到的t大于阈值，则初始化阈值\n            if (t > threshold)\n                threshold = tableSizeFor(t);\n        }\n        // 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s > threshold)\n            resize();\n        // 将m中的所有元素添加至HashMap中\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n            K key = e.getKey();\n            V value = e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        }\n    }\n}\n```\n### put方法\nHashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。\n\n**对putVal方法添加元素的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用`e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`将元素添加进入。如果不是就遍历链表插入。\n\n\n\n![put方法](https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&h=679&f=png&s=54486)\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // hash值不相等，即key不相等；为红黑树结点\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    // 结点数量达到阈值，转化为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        // 表示在桶中找到key值、hash值与插入元素相等的结点\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n} \n```\n\n**我们再来对比一下 JDK1.7 put方法的代码**\n\n**对于put方法的分析如下：**\n\n- ①如果定位到的数组位置没有元素 就直接插入。\n- ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。\n\n```java\npublic V put(K key, V value)\n    if (table == EMPTY_TABLE) { \n    inflateTable(threshold); \n}  \n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue; \n        }\n    }\n\n    modCount++;\n    addEntry(hash, key, value, i);  // 再插入\n    return null;\n}\n```\n\n\n\n### get方法\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 数组元素相等\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        // 桶中不止一个节点\n        if ((e = first.next) != null) {\n            // 在树中get\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 在链表中get\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n### resize方法\n进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else { \n        // signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算新的resize上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        // 原索引\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        // 原索引+oldCap\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n## HashMap常用方法测试\n```java\npackage map;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class HashMapDemo {\n\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        // 键不能重复，值可以重复\n        map.put(\"san\", \"张三\");\n        map.put(\"si\", \"李四\");\n        map.put(\"wu\", \"王五\");\n        map.put(\"wang\", \"老王\");\n        map.put(\"wang\", \"老王2\");// 老王被覆盖\n        map.put(\"lao\", \"老王\");\n        System.out.println(\"-------直接输出hashmap:-------\");\n        System.out.println(map);\n        /**\n         * 遍历HashMap\n         */\n        // 1.获取Map中的所有键\n        System.out.println(\"-------foreach获取Map中所有的键:------\");\n        Set<String> keys = map.keySet();\n        for (String key : keys) {\n            System.out.print(key+\"  \");\n        }\n        System.out.println();//换行\n        // 2.获取Map中所有值\n        System.out.println(\"-------foreach获取Map中所有的值:------\");\n        Collection<String> values = map.values();\n        for (String value : values) {\n            System.out.print(value+\"  \");\n        }\n        System.out.println();//换行\n        // 3.得到key的值的同时得到key所对应的值\n        System.out.println(\"-------得到key的值的同时得到key所对应的值:-------\");\n        Set<String> keys2 = map.keySet();\n        for (String key : keys2) {\n            System.out.print(key + \"：\" + map.get(key)+\"   \");\n\n        }\n        /**\n         * 另外一种不常用的遍历方式\n         */\n        // 当我调用put(key,value)方法的时候，首先会把key和value封装到\n        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取\n        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来\n        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了\n        Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();\n        for (java.util.Map.Entry<String, String> entry : entrys) {\n            System.out.println(entry.getKey() + \"--\" + entry.getValue());\n        }\n        \n        /**\n         * HashMap其他常用方法\n         */\n        System.out.println(\"after map.size()：\"+map.size());\n        System.out.println(\"after map.isEmpty()：\"+map.isEmpty());\n        System.out.println(map.remove(\"san\"));\n        System.out.println(\"after map.remove()：\"+map);\n        System.out.println(\"after map.get(si)：\"+map.get(\"si\"));\n        System.out.println(\"after map.containsKey(si)：\"+map.containsKey(\"si\"));\n        System.out.println(\"after containsValue(李四)：\"+map.containsValue(\"李四\"));\n        System.out.println(map.replace(\"si\", \"李四2\"));\n        System.out.println(\"after map.replace(si, 李四2):\"+map);\n    }\n\n}\n\n```\n","slug":"Java/Collection-Framework/HashMap","published":1,"date":"2019-03-22T10:16:45.425Z","updated":"2019-03-23T03:41:33.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge2h00fiqnn9oha1f06n","content":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#hashmap-简介\">HashMap 简介</a></li>\n<li><a href=\"#底层数据结构分析\">底层数据结构分析</a><ul>\n<li><a href=\"#jdk18之前\">JDK1.8之前</a></li>\n<li><a href=\"#jdk18之后\">JDK1.8之后</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap源码分析\">HashMap源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#put方法\">put方法</a></li>\n<li><a href=\"#get方法\">get方法</a></li>\n<li><a href=\"#resize方法\">resize方法</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap常用方法测试\">HashMap常用方法测试</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<blockquote>\n<p>感谢 <a href=\"https://github.com/changfubai\" target=\"_blank\" rel=\"noopener\">changfubai</a> 对本文的改进做出的贡献！</p>\n</blockquote>\n<h2 id=\"HashMap-简介\"><a href=\"#HashMap-简介\" class=\"headerlink\" title=\"HashMap 简介\"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 </p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<h2 id=\"底层数据结构分析\"><a href=\"#底层数据结构分析\" class=\"headerlink\" title=\"底层数据结构分析\"></a>底层数据结构分析</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class=\"line\">    <span class=\"comment\">// ^ ：按位异或</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">    <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">    <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&amp;h=427&amp;f=png&amp;s=10991\" alt=\"jdk1.8之前的内部结构\"></p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg\" alt=\"JDK1.8之后的HashMap底层数据结构\"></p>\n<p><strong>类的属性：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 序列号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    </span><br><span class=\"line\">    <span class=\"comment\">// 默认的初始容量是16</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   </span><br><span class=\"line\">    <span class=\"comment\">// 最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 默认的填充因子</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class=\"line\">    <span class=\"comment\">// 存放具体元素的集</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class=\"line\">    <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 每次扩容和更改map结构的计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   </span><br><span class=\"line\">    <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"comment\">// 加载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>loadFactor加载因子</strong></p>\n<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。 </p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li><p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node节点类源码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;<span class=\"comment\">//键</span></span><br><span class=\"line\">       V value;<span class=\"comment\">//值</span></span><br><span class=\"line\">       <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">       Node&lt;K,V&gt; next;</span><br><span class=\"line\">       Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写hashCode()方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">            V oldValue = value;</span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写 equals() 方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                    Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>树节点类源码:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 父</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;    <span class=\"comment\">// 左</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;   <span class=\"comment\">// 右</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;           <span class=\"comment\">// 判断颜色</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap源码分析\"><a href=\"#HashMap源码分析\" class=\"headerlink\" title=\"HashMap源码分析\"></a>HashMap源码分析</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&amp;h=90&amp;f=jpeg&amp;s=26744\" alt=\"四个构造方法\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造函数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all   other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 包含另一个“Map”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">     putMapEntries(m, <span class=\"keyword\">false</span>);<span class=\"comment\">//下面会分析到这个方法</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> + initialCapacity);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + loadFactor);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>putMapEntries方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断table是否已经初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// pre-size</span></span><br><span class=\"line\">            <span class=\"comment\">// 未初始化，s为m的实际元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                    (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"comment\">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"comment\">// 将m中的所有元素添加至HashMap中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对putVal方法添加元素的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&amp;h=679&amp;f=png&amp;s=54486\" alt=\"put方法\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 结点数量达到阈值，转化为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>\n<p><strong>对于put方法的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"params\">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class=\"line\">    inflateTable(threshold); </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123; <span class=\"comment\">// 先遍历</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    addEntry(hash, key, value, i);  <span class=\"comment\">// 再插入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 数组元素相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">// 桶中不止一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在树中get</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中get</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算新的resize上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ? (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把每个bucket都移动到新的buckets中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引+oldCap放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap常用方法测试\"><a href=\"#HashMap常用方法测试\" class=\"headerlink\" title=\"HashMap常用方法测试\"></a>HashMap常用方法测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 键不能重复，值可以重复</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"san\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wu\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王2\"</span>);<span class=\"comment\">// 老王被覆盖</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"lao\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------直接输出hashmap:-------\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 遍历HashMap</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 1.获取Map中的所有键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的键:------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            System.out.print(key+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取Map中所有值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的值:------\"</span>);</span><br><span class=\"line\">        Collection&lt;String&gt; values = map.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String value : values) &#123;</span><br><span class=\"line\">            System.out.print(value+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------得到key的值的同时得到key所对应的值:-------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys2) &#123;</span><br><span class=\"line\">            System.out.print(key + <span class=\"string\">\"：\"</span> + map.get(key)+<span class=\"string\">\"   \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 另外一种不常用的遍历方式</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class=\"line\">        <span class=\"comment\">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class=\"line\">        <span class=\"comment\">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class=\"line\">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"--\"</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * HashMap其他常用方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.size()：\"</span>+map.size());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.isEmpty()：\"</span>+map.isEmpty());</span><br><span class=\"line\">        System.out.println(map.remove(<span class=\"string\">\"san\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.remove()：\"</span>+map);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.get(si)：\"</span>+map.get(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.containsKey(si)：\"</span>+map.containsKey(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after containsValue(李四)：\"</span>+map.containsValue(<span class=\"string\">\"李四\"</span>));</span><br><span class=\"line\">        System.out.println(map.replace(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四2\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.replace(si, 李四2):\"</span>+map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<!-- MarkdownTOC -->\n<ul>\n<li><a href=\"#hashmap-简介\">HashMap 简介</a></li>\n<li><a href=\"#底层数据结构分析\">底层数据结构分析</a><ul>\n<li><a href=\"#jdk18之前\">JDK1.8之前</a></li>\n<li><a href=\"#jdk18之后\">JDK1.8之后</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap源码分析\">HashMap源码分析</a><ul>\n<li><a href=\"#构造方法\">构造方法</a></li>\n<li><a href=\"#put方法\">put方法</a></li>\n<li><a href=\"#get方法\">get方法</a></li>\n<li><a href=\"#resize方法\">resize方法</a></li>\n</ul>\n</li>\n<li><a href=\"#hashmap常用方法测试\">HashMap常用方法测试</a></li>\n</ul>\n<!-- /MarkdownTOC -->\n<blockquote>\n<p>感谢 <a href=\"https://github.com/changfubai\" target=\"_blank\" rel=\"noopener\">changfubai</a> 对本文的改进做出的贡献！</p>\n</blockquote>\n<h2 id=\"HashMap-简介\"><a href=\"#HashMap-简介\" class=\"headerlink\" title=\"HashMap 简介\"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 </p>\n<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<h2 id=\"底层数据结构分析\"><a href=\"#底层数据结构分析\" class=\"headerlink\" title=\"底层数据结构分析\"></a>底层数据结构分析</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>\n<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>\n<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>\n<p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class=\"line\">    <span class=\"comment\">// ^ ：按位异或</span></span><br><span class=\"line\">    <span class=\"comment\">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">    <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">    <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>\n<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?w=348&amp;h=427&amp;f=png&amp;s=10991\" alt=\"jdk1.8之前的内部结构\"></p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg\" alt=\"JDK1.8之后的HashMap底层数据结构\"></p>\n<p><strong>类的属性：</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 序列号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    </span><br><span class=\"line\">    <span class=\"comment\">// 默认的初始容量是16</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   </span><br><span class=\"line\">    <span class=\"comment\">// 最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 默认的填充因子</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\">    <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class=\"line\">    <span class=\"comment\">// 存放具体元素的集</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class=\"line\">    <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 每次扩容和更改map结构的计数器</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   </span><br><span class=\"line\">    <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\">    <span class=\"comment\">// 加载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>loadFactor加载因子</strong></p>\n<p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。 </p>\n<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>\n</li>\n<li><p><strong>threshold</strong></p>\n<p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>\n</li>\n</ul>\n<p><strong>Node节点类源码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class=\"line\">       <span class=\"keyword\">final</span> K key;<span class=\"comment\">//键</span></span><br><span class=\"line\">       V value;<span class=\"comment\">//值</span></span><br><span class=\"line\">       <span class=\"comment\">// 指向下一个节点</span></span><br><span class=\"line\">       Node&lt;K,V&gt; next;</span><br><span class=\"line\">       Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写hashCode()方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">            V oldValue = value;</span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 重写 equals() 方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                    Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>树节点类源码:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 父</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;    <span class=\"comment\">// 左</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;   <span class=\"comment\">// 右</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;           <span class=\"comment\">// 判断颜色</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap源码分析\"><a href=\"#HashMap源码分析\" class=\"headerlink\" title=\"HashMap源码分析\"></a>HashMap源码分析</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/162410d912a2e0e1?w=336&amp;h=90&amp;f=jpeg&amp;s=26744\" alt=\"四个构造方法\"><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造函数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all   other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 包含另一个“Map”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">     putMapEntries(m, <span class=\"keyword\">false</span>);<span class=\"comment\">//下面会分析到这个方法</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> + initialCapacity);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> + loadFactor);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>putMapEntries方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">putMapEntries</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = m.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断table是否已经初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// pre-size</span></span><br><span class=\"line\">            <span class=\"comment\">// 未初始化，s为m的实际元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = ((<span class=\"keyword\">float</span>)s / loadFactor) + <span class=\"number\">1.0F</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = ((ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class=\"line\">                    (<span class=\"keyword\">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class=\"line\">            <span class=\"comment\">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t &gt; threshold)</span><br><span class=\"line\">                threshold = tableSizeFor(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        <span class=\"comment\">// 将m中的所有元素添加至HashMap中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class=\"line\">            K key = e.getKey();</span><br><span class=\"line\">            V value = e.getValue();</span><br><span class=\"line\">            putVal(hash(key), key, value, <span class=\"keyword\">false</span>, evict);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>\n<p><strong>对putVal方法添加元素的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入。</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/9/2/16598bf758c747e6?w=999&amp;h=679&amp;f=png&amp;s=54486\" alt=\"put方法\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 结点数量达到阈值，转化为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p>\n<p><strong>对于put方法的分析如下：</strong></p>\n<ul>\n<li>①如果定位到的数组位置没有元素 就直接插入。</li>\n<li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"params\">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class=\"line\">    inflateTable(threshold); </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123; <span class=\"comment\">// 先遍历</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    addEntry(hash, key, value, i);  <span class=\"comment\">// 再插入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 数组元素相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">// 桶中不止一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在树中get</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中get</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算新的resize上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ? (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把每个bucket都移动到新的buckets中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 原索引+oldCap放到bucket里</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HashMap常用方法测试\"><a href=\"#HashMap常用方法测试\" class=\"headerlink\" title=\"HashMap常用方法测试\"></a>HashMap常用方法测试</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMapDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 键不能重复，值可以重复</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"san\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wu\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"wang\"</span>, <span class=\"string\">\"老王2\"</span>);<span class=\"comment\">// 老王被覆盖</span></span><br><span class=\"line\">        map.put(<span class=\"string\">\"lao\"</span>, <span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------直接输出hashmap:-------\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 遍历HashMap</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 1.获取Map中的所有键</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的键:------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">            System.out.print(key+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 2.获取Map中所有值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------foreach获取Map中所有的值:------\"</span>);</span><br><span class=\"line\">        Collection&lt;String&gt; values = map.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String value : values) &#123;</span><br><span class=\"line\">            System.out.print(value+<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println();<span class=\"comment\">//换行</span></span><br><span class=\"line\">        <span class=\"comment\">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------得到key的值的同时得到key所对应的值:-------\"</span>);</span><br><span class=\"line\">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : keys2) &#123;</span><br><span class=\"line\">            System.out.print(key + <span class=\"string\">\"：\"</span> + map.get(key)+<span class=\"string\">\"   \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 另外一种不常用的遍历方式</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class=\"line\">        <span class=\"comment\">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class=\"line\">        <span class=\"comment\">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class=\"line\">        <span class=\"comment\">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class=\"line\">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"--\"</span> + entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * HashMap其他常用方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.size()：\"</span>+map.size());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.isEmpty()：\"</span>+map.isEmpty());</span><br><span class=\"line\">        System.out.println(map.remove(<span class=\"string\">\"san\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.remove()：\"</span>+map);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.get(si)：\"</span>+map.get(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.containsKey(si)：\"</span>+map.containsKey(<span class=\"string\">\"si\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after containsValue(李四)：\"</span>+map.containsValue(<span class=\"string\">\"李四\"</span>));</span><br><span class=\"line\">        System.out.println(map.replace(<span class=\"string\">\"si\"</span>, <span class=\"string\">\"李四2\"</span>));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after map.replace(si, 李四2):\"</span>+map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java容器——ArrayList","_content":"\n## ArrayList简介\n\n　　`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 `ensureCapacity` 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\n　　它继承于 **AbstractList**，实现了 **List**, **RandomAccess**, **Cloneable**, **java.io.Serializable** 这些接口。\n　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n　　- ArrayList 实现了**RandomAccess 接口**。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n　　- ArrayList 实现了**Cloneable 接口**。即覆盖了函数 clone()，**能被克隆**。\n　　- ArrayList 实现**java.io.Serializable 接口**。这意味着ArrayList**支持序列化**，**能通过序列化去传输**。\n\n　　和 Vector 不同，**`ArrayList` 中的操作不是线程安全的！**所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 `Vector` 或者 ` CopyOnWriteArrayList`。\n　　\n\n## ArrayList核心源码\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //\n        elementData = c.toArray();\n        //如果指定集合元素个数不为0\n        if ((size = elementData.length) != 0) {\n            // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，\n            //这里用到了反射里面的getClass()方法\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 \n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。 \n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） \n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; \n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 \n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 \n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） \n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。 \n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 \n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素 \n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。 \n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。 \n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 \n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 \n     *返回的列表迭代器是fail-fast 。 \n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。 \n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。 \n     *返回的迭代器是fail-fast 。 \n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n  \n```\n### <font face=\"楷体\" id=\"1\" id=\"5\">ArrayList源码分析</font>\n####  System.arraycopy()和Arrays.copyOf()方法\n　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:\n```java \n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n又如toArray()方法中用到了copyOf()方法\n```java\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n##### 两者联系与区别\n**联系：**\n看两者源代码可以发现`copyOf()`内部调用了`System.arraycopy()`方法\n**区别：**\n\n1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n2. copyOf()是系统自动在内部新建一个数组，并返回该数组。\n#### ArrayList 核心扩容技术\n```java\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容,上面两个方法都要调用\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。\n        //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n```java\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n       //elementData为保存ArrayList数据的数组\n       ///elementData.length求数组长度elementData.size是求数组中的元素个数\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    \n```\n　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：**移位运算符**\n　　**简介**：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\"><<(左移)</font>、<font color=\"red\">>>(带符号右移)</font>和<font color=\"red\">>>>(无符号右移)</font>。\n　　**作用**：**对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源**\n　　比如这里：int newCapacity = oldCapacity + (oldCapacity >> 1);\n右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。\n\n**另外需要注意的是：**\n\n1. java 中的**length 属性**是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n\n2. java 中的**length()方法**是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.\n\n3. .java 中的**size()方法**是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n\n#### 内部类\n```java\n    (1)private class Itr implements Iterator<E>  \n    (2)private class ListItr extends Itr implements ListIterator<E>  \n    (3)private class SubList extends AbstractList<E> implements RandomAccess  \n    (4)static final class ArrayListSpliterator<E> implements Spliterator<E>  \n```\n　　ArrayList有四个内部类，其中的**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**，**next()**，**remove()**等方法；其中的**ListItr**继承**Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**，**nextIndex()**，**previousIndex()**，**previous()**，**set(E e)**，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。\n### <font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font>\n\n```java\npackage list;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class ArrayListDemo {\n\n    public static void main(String[] srgs){\n         ArrayList<Integer> arrayList = new ArrayList<Integer>();\n\n         System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size());\n\n         arrayList.add(1);\n         arrayList.add(3);\n         arrayList.add(5);\n         arrayList.add(7);\n         arrayList.add(9);\n         System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size());\n\n         System.out.println(\"Printing elements of arrayList\");\n         // 三种遍历方式打印元素\n         // 第一种：通过迭代器遍历\n         System.out.print(\"通过迭代器遍历:\");\n         Iterator<Integer> it = arrayList.iterator();\n         while(it.hasNext()){\n             System.out.print(it.next() + \" \");\n         }\n         System.out.println();\n\n         // 第二种：通过索引值遍历\n         System.out.print(\"通过索引值遍历:\");\n         for(int i = 0; i < arrayList.size(); i++){\n             System.out.print(arrayList.get(i) + \" \");\n         }\n         System.out.println();\n\n         // 第三种：for循环遍历\n         System.out.print(\"for循环遍历:\");\n         for(Integer number : arrayList){\n             System.out.print(number + \" \");\n         }\n\n         // toArray用法\n         // 第一种方式(最常用)\n         Integer[] integer = arrayList.toArray(new Integer[0]);\n\n         // 第二种方式(容易理解)\n         Integer[] integer1 = new Integer[arrayList.size()];\n         arrayList.toArray(integer1);\n\n         // 抛出异常，java不支持向下转型\n         //Integer[] integer2 = new Integer[arrayList.size()];\n         //integer2 = arrayList.toArray();\n         System.out.println();\n\n         // 在指定位置添加元素\n         arrayList.add(2,2);\n         // 删除指定位置上的元素\n         arrayList.remove(2);    \n         // 删除指定元素\n         arrayList.remove((Object)3);\n         // 判断arrayList是否包含5\n         System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5));\n\n         // 清空ArrayList\n         arrayList.clear();\n         // 判断ArrayList是否为空\n         System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty());\n    }\n}\n```\n\n","source":"_posts/Java/Collection-Framework/ArrayList.md","raw":"---\ntitle: Java容器——ArrayList\ncategories:\n  - Java\n  - Collection-Framework\ntags:\n  - array-list\n---\n\n## ArrayList简介\n\n　　`ArrayList` 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 `ensureCapacity` 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\n　　它继承于 **AbstractList**，实现了 **List**, **RandomAccess**, **Cloneable**, **java.io.Serializable** 这些接口。\n　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n　　- ArrayList 实现了**RandomAccess 接口**。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持**快速随机访问**的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n　　- ArrayList 实现了**Cloneable 接口**。即覆盖了函数 clone()，**能被克隆**。\n　　- ArrayList 实现**java.io.Serializable 接口**。这意味着ArrayList**支持序列化**，**能通过序列化去传输**。\n\n　　和 Vector 不同，**`ArrayList` 中的操作不是线程安全的！**所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 `Vector` 或者 ` CopyOnWriteArrayList`。\n　　\n\n## ArrayList核心源码\n\n```java\npackage java.util;\n\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    private static final long serialVersionUID = 8683452581122892189L;\n\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    /**\n     * 空数组（用于空实例）。\n     */\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n     //用于默认大小空实例的共享空数组实例。\n      //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     * 保存ArrayList数据的数组\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     * ArrayList 所包含的元素个数\n     */\n    private int size;\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n    /**\n     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。\n     */\n    public ArrayList(Collection<? extends E> c) {\n        //\n        elementData = c.toArray();\n        //如果指定集合元素个数不为0\n        if ((size = elementData.length) != 0) {\n            // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，\n            //这里用到了反射里面的getClass()方法\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // 用空数组代替\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n\n    /**\n     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 \n     */\n    public void trimToSize() {\n        modCount++;\n        if (size < elementData.length) {\n            elementData = (size == 0)\n              ? EMPTY_ELEMENTDATA\n              : Arrays.copyOf(elementData, size);\n        }\n    }\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    //比较minCapacity和 MAX_ARRAY_SIZE\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n\n    /**\n     *返回此列表中的元素数。 \n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 如果此列表不包含元素，则返回 true 。\n     */\n    public boolean isEmpty() {\n        //注意=和==的区别\n        return size == 0;\n    }\n\n    /**\n     * 如果此列表包含指定的元素，则返回true 。\n     */\n    public boolean contains(Object o) {\n        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n        return indexOf(o) >= 0;\n    }\n\n    /**\n     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 \n     */\n    public int indexOf(Object o) {\n        if (o == null) {\n            for (int i = 0; i < size; i++)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = 0; i < size; i++)\n                //equals()方法比较\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.\n     */\n    public int lastIndexOf(Object o) {\n        if (o == null) {\n            for (int i = size-1; i >= 0; i--)\n                if (elementData[i]==null)\n                    return i;\n        } else {\n            for (int i = size-1; i >= 0; i--)\n                if (o.equals(elementData[i]))\n                    return i;\n        }\n        return -1;\n    }\n\n    /**\n     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） \n     */\n    public Object clone() {\n        try {\n            ArrayList<?> v = (ArrayList<?>) super.clone();\n            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度\n            v.elementData = Arrays.copyOf(elementData, size);\n            v.modCount = 0;\n            return v;\n        } catch (CloneNotSupportedException e) {\n            // 这不应该发生，因为我们是可以克隆的\n            throw new InternalError(e);\n        }\n    }\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n\n    /**\n     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; \n     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 \n     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 \n     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。\n     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） \n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // 新建一个运行时类型的数组，但是ArrayList数组的内容\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n            //调用System提供的arraycopy()方法实现数组之间的复制\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n\n    // Positional Access Operations\n\n    @SuppressWarnings(\"unchecked\")\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n\n    /**\n     * 返回此列表中指定位置的元素。\n     */\n    public E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    /**\n     * 用指定的元素替换此列表中指定位置的元素。 \n     */\n    public E set(int index, E element) {\n        //对index进行界限检查\n        rangeCheck(index);\n\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        //返回原来在这个位置的元素\n        return oldValue;\n    }\n\n    /**\n     * 将指定的元素追加到此列表的末尾。 \n     */\n    public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n\n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n\n    /**\n     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 \n     */\n    public E remove(int index) {\n        rangeCheck(index);\n\n        modCount++;\n        E oldValue = elementData(index);\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n      //从列表中删除的元素 \n        return oldValue;\n    }\n\n    /**\n     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。\n     *返回true，如果此列表包含指定的元素\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (int index = 0; index < size; index++)\n                if (elementData[index] == null) {\n                    fastRemove(index);\n                    return true;\n                }\n        } else {\n            for (int index = 0; index < size; index++)\n                if (o.equals(elementData[index])) {\n                    fastRemove(index);\n                    return true;\n                }\n        }\n        return false;\n    }\n\n    /*\n     * Private remove method that skips bounds checking and does not\n     * return the value removed.\n     */\n    private void fastRemove(int index) {\n        modCount++;\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n    }\n\n    /**\n     * 从列表中删除所有元素。 \n     */\n    public void clear() {\n        modCount++;\n\n        // 把数组中所有的元素的值设为null\n        for (int i = 0; i < size; i++)\n            elementData[i] = null;\n\n        size = 0;\n    }\n\n    /**\n     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        rangeCheckForAdd(index);\n\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n\n        int numMoved = size - index;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index, elementData, index + numNew,\n                             numMoved);\n\n        System.arraycopy(a, 0, elementData, index, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\n    /**\n     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。\n     *将任何后续元素移动到左侧（减少其索引）。\n     */\n    protected void removeRange(int fromIndex, int toIndex) {\n        modCount++;\n        int numMoved = size - toIndex;\n        System.arraycopy(elementData, toIndex, elementData, fromIndex,\n                         numMoved);\n\n        // clear to let GC do its work\n        int newSize = size - (toIndex-fromIndex);\n        for (int i = newSize; i < size; i++) {\n            elementData[i] = null;\n        }\n        size = newSize;\n    }\n\n    /**\n     * 检查给定的索引是否在范围内。\n     */\n    private void rangeCheck(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * add和addAll使用的rangeCheck的一个版本\n     */\n    private void rangeCheckForAdd(int index) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n\n    /**\n     * 返回IndexOutOfBoundsException细节信息\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n\n    /**\n     * 从此列表中删除指定集合中包含的所有元素。 \n     */\n    public boolean removeAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        //如果此列表被修改则返回true\n        return batchRemove(c, false);\n    }\n\n    /**\n     * 仅保留此列表中包含在指定集合中的元素。\n     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 \n     */\n    public boolean retainAll(Collection<?> c) {\n        Objects.requireNonNull(c);\n        return batchRemove(c, true);\n    }\n\n\n    /**\n     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。\n     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 \n     *返回的列表迭代器是fail-fast 。 \n     */\n    public ListIterator<E> listIterator(int index) {\n        if (index < 0 || index > size)\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        return new ListItr(index);\n    }\n\n    /**\n     *返回列表中的列表迭代器（按适当的顺序）。 \n     *返回的列表迭代器是fail-fast 。\n     */\n    public ListIterator<E> listIterator() {\n        return new ListItr(0);\n    }\n\n    /**\n     *以正确的顺序返回该列表中的元素的迭代器。 \n     *返回的迭代器是fail-fast 。 \n     */\n    public Iterator<E> iterator() {\n        return new Itr();\n    }\n\n  \n```\n### <font face=\"楷体\" id=\"1\" id=\"5\">ArrayList源码分析</font>\n####  System.arraycopy()和Arrays.copyOf()方法\n　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:\n```java \n    /**\n     * 在此列表中的指定位置插入指定的元素。 \n     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；\n     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。\n     */\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        //arraycopy()方法实现数组自己复制自己\n        //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；\n        System.arraycopy(elementData, index, elementData, index + 1, size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n又如toArray()方法中用到了copyOf()方法\n```java\n\n    /**\n     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 \n     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。\n     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。\n     */\n    public Object[] toArray() {\n    //elementData：要复制的数组；size：要复制的长度\n        return Arrays.copyOf(elementData, size);\n    }\n```\n##### 两者联系与区别\n**联系：**\n看两者源代码可以发现`copyOf()`内部调用了`System.arraycopy()`方法\n**区别：**\n\n1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n2. copyOf()是系统自动在内部新建一个数组，并返回该数组。\n#### ArrayList 核心扩容技术\n```java\n//下面是ArrayList的扩容机制\n//ArrayList的扩容机制提高了性能，如果每次只扩充一个，\n//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。\n    /**\n     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量\n     * @param   minCapacity   所需的最小容量\n     */\n    public void ensureCapacity(int minCapacity) {\n        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            // any size if not default element table\n            ? 0\n            // larger than default for default empty table. It's already\n            // supposed to be at default size.\n            : DEFAULT_CAPACITY;\n\n        if (minCapacity > minExpand) {\n            ensureExplicitCapacity(minCapacity);\n        }\n    }\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n  //判断是否需要扩容,上面两个方法都要调用\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。\n        //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n\n```\n```java\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n       //elementData为保存ArrayList数据的数组\n       ///elementData.length求数组长度elementData.size是求数组中的元素个数\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        //再检查新容量是否超出了ArrayList所定义的最大容量，\n        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n    \n```\n　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：**移位运算符**\n　　**简介**：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\"><<(左移)</font>、<font color=\"red\">>>(带符号右移)</font>和<font color=\"red\">>>>(无符号右移)</font>。\n　　**作用**：**对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源**\n　　比如这里：int newCapacity = oldCapacity + (oldCapacity >> 1);\n右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。\n\n**另外需要注意的是：**\n\n1. java 中的**length 属性**是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n\n2. java 中的**length()方法**是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.\n\n3. .java 中的**size()方法**是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n\n#### 内部类\n```java\n    (1)private class Itr implements Iterator<E>  \n    (2)private class ListItr extends Itr implements ListIterator<E>  \n    (3)private class SubList extends AbstractList<E> implements RandomAccess  \n    (4)static final class ArrayListSpliterator<E> implements Spliterator<E>  \n```\n　　ArrayList有四个内部类，其中的**Itr是实现了Iterator接口**，同时重写了里面的**hasNext()**，**next()**，**remove()**等方法；其中的**ListItr**继承**Itr**，实现了**ListIterator接口**，同时重写了**hasPrevious()**，**nextIndex()**，**previousIndex()**，**previous()**，**set(E e)**，**add(E e)**等方法，所以这也可以看出了 **Iterator和ListIterator的区别:**ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。\n### <font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font>\n\n```java\npackage list;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class ArrayListDemo {\n\n    public static void main(String[] srgs){\n         ArrayList<Integer> arrayList = new ArrayList<Integer>();\n\n         System.out.printf(\"Before add:arrayList.size() = %d\\n\",arrayList.size());\n\n         arrayList.add(1);\n         arrayList.add(3);\n         arrayList.add(5);\n         arrayList.add(7);\n         arrayList.add(9);\n         System.out.printf(\"After add:arrayList.size() = %d\\n\",arrayList.size());\n\n         System.out.println(\"Printing elements of arrayList\");\n         // 三种遍历方式打印元素\n         // 第一种：通过迭代器遍历\n         System.out.print(\"通过迭代器遍历:\");\n         Iterator<Integer> it = arrayList.iterator();\n         while(it.hasNext()){\n             System.out.print(it.next() + \" \");\n         }\n         System.out.println();\n\n         // 第二种：通过索引值遍历\n         System.out.print(\"通过索引值遍历:\");\n         for(int i = 0; i < arrayList.size(); i++){\n             System.out.print(arrayList.get(i) + \" \");\n         }\n         System.out.println();\n\n         // 第三种：for循环遍历\n         System.out.print(\"for循环遍历:\");\n         for(Integer number : arrayList){\n             System.out.print(number + \" \");\n         }\n\n         // toArray用法\n         // 第一种方式(最常用)\n         Integer[] integer = arrayList.toArray(new Integer[0]);\n\n         // 第二种方式(容易理解)\n         Integer[] integer1 = new Integer[arrayList.size()];\n         arrayList.toArray(integer1);\n\n         // 抛出异常，java不支持向下转型\n         //Integer[] integer2 = new Integer[arrayList.size()];\n         //integer2 = arrayList.toArray();\n         System.out.println();\n\n         // 在指定位置添加元素\n         arrayList.add(2,2);\n         // 删除指定位置上的元素\n         arrayList.remove(2);    \n         // 删除指定元素\n         arrayList.remove((Object)3);\n         // 判断arrayList是否包含5\n         System.out.println(\"ArrayList contains 5 is: \" + arrayList.contains(5));\n\n         // 清空ArrayList\n         arrayList.clear();\n         // 判断ArrayList是否为空\n         System.out.println(\"ArrayList is empty: \" + arrayList.isEmpty());\n    }\n}\n```\n\n","slug":"Java/Collection-Framework/ArrayList","published":1,"date":"2019-03-22T10:16:45.424Z","updated":"2019-03-23T14:44:53.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2u3ge2p00fuqnn9nwhgy0ef","content":"<h2 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h2><p>　　<code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>　　它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。<br>　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>　　- ArrayList 实现了<strong>RandomAccess 接口</strong>。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。<br>　　- ArrayList 实现了<strong>Cloneable 接口</strong>。即覆盖了函数 clone()，<strong>能被克隆</strong>。<br>　　- ArrayList 实现<strong>java.io.Serializable 接口</strong>。这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>\n<p>　　和 Vector 不同，<strong><code>ArrayList</code> 中的操作不是线程安全的！</strong>所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 <code>Vector</code> 或者 <code>CopyOnWriteArrayList</code>。\n　　</p>\n<h2 id=\"ArrayList核心源码\"><a href=\"#ArrayList核心源码\" class=\"headerlink\" title=\"ArrayList核心源码\"></a>ArrayList核心源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.UnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">      <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果指定集合元素个数不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class=\"line\">            <span class=\"comment\">//这里用到了反射里面的getClass()方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用空数组代替</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">              ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">              : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中的元素数。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class=\"line\"><span class=\"comment\">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">            <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">      <span class=\"comment\">//从列表中删除的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     *返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private remove method that skips bounds checking and does not</span></span><br><span class=\"line\"><span class=\"comment\">     * return the value removed.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span>+index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList源码分析\"><a href=\"#ArrayList源码分析\" class=\"headerlink\" title=\"ArrayList源码分析\"></a><font face=\"楷体\" id=\"1\">ArrayList源码分析</font></h3><h4 id=\"System-arraycopy-和Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy()和Arrays.copyOf()方法\"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又如toArray()方法中用到了copyOf()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\"> *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\"> *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"><span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两者联系与区别\"><a href=\"#两者联系与区别\" class=\"headerlink\" title=\"两者联系与区别\"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p>\n<ol>\n<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>\n<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。<h4 id=\"ArrayList-核心扩容技术\"><a href=\"#ArrayList-核心扩容技术\" class=\"headerlink\" title=\"ArrayList 核心扩容技术\"></a>ArrayList 核心扩容技术</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class=\"line\">        <span class=\"comment\">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//elementData为保存ArrayList数据的数组</span></span><br><span class=\"line\">   <span class=\"comment\">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">    <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\">&lt;&lt;(左移)</font>、<font color=\"red\">&gt;&gt;(带符号右移)</font>和<font color=\"red\">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p>\n<p><strong>另外需要注意的是：</strong></p>\n<ol>\n<li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p>\n</li>\n<li><p>java 中的<strong>length()方法</strong>是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p>\n</li>\n<li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>\n</li>\n</ol>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(3)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>  </span></span><br><span class=\"line\"><span class=\"class\">(4)<span class=\"title\">static</span> <span class=\"title\">final</span> <span class=\"title\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>　　ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>\n<h3 id=\"ArrayList经典Demo\"><a href=\"#ArrayList经典Demo\" class=\"headerlink\" title=\" ArrayList经典Demo\"></a><font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span></span>&#123;</span><br><span class=\"line\">         ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"Before add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">7</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">9</span>);</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"After add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"Printing elements of arrayList\"</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 三种遍历方式打印元素</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种：通过迭代器遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class=\"line\">         <span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">             System.out.print(it.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种：通过索引值遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过索引值遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class=\"line\">             System.out.print(arrayList.get(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第三种：for循环遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"for循环遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(Integer number : arrayList)&#123;</span><br><span class=\"line\">             System.out.print(number + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// toArray用法</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种方式(最常用)</span></span><br><span class=\"line\">         Integer[] integer = arrayList.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种方式(容易理解)</span></span><br><span class=\"line\">         Integer[] integer1 = <span class=\"keyword\">new</span> Integer[arrayList.size()];</span><br><span class=\"line\">         arrayList.toArray(integer1);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 抛出异常，java不支持向下转型</span></span><br><span class=\"line\">         <span class=\"comment\">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class=\"line\">         <span class=\"comment\">//integer2 = arrayList.toArray();</span></span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 删除指定位置上的元素</span></span><br><span class=\"line\">         arrayList.remove(<span class=\"number\">2</span>);    </span><br><span class=\"line\">         <span class=\"comment\">// 删除指定元素</span></span><br><span class=\"line\">         arrayList.remove((Object)<span class=\"number\">3</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 判断arrayList是否包含5</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList contains 5 is: \"</span> + arrayList.contains(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 清空ArrayList</span></span><br><span class=\"line\">         arrayList.clear();</span><br><span class=\"line\">         <span class=\"comment\">// 判断ArrayList是否为空</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList is empty: \"</span> + arrayList.isEmpty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h2><p>　　<code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 <code>ensureCapacity</code> 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>　　它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。<br>　　- ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。<br>　　- ArrayList 实现了<strong>RandomAccess 接口</strong>。 RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。<br>　　- ArrayList 实现了<strong>Cloneable 接口</strong>。即覆盖了函数 clone()，<strong>能被克隆</strong>。<br>　　- ArrayList 实现<strong>java.io.Serializable 接口</strong>。这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p>\n<p>　　和 Vector 不同，<strong><code>ArrayList</code> 中的操作不是线程安全的！</strong>所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 <code>Vector</code> 或者 <code>CopyOnWriteArrayList</code>。\n　　</p>\n<h2 id=\"ArrayList核心源码\"><a href=\"#ArrayList核心源码\" class=\"headerlink\" title=\"ArrayList核心源码\"></a>ArrayList核心源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Consumer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Predicate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.UnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">8683452581122892189L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 空数组（用于空实例）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//用于默认大小空实例的共享空数组实例。</span></span><br><span class=\"line\">      <span class=\"comment\">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保存ArrayList数据的数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList 所包含的元素个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                               initialCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        elementData = c.toArray();</span><br><span class=\"line\">        <span class=\"comment\">//如果指定集合元素个数不为0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class=\"line\">            <span class=\"comment\">//这里用到了反射里面的getClass()方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用空数组代替</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; elementData.length) &#123;</span><br><span class=\"line\">            elementData = (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">              ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">              : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">        <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">        <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中的元素数。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意=和==的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> indexOf(o) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">                <span class=\"comment\">//equals()方法比较</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[i]==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[i]))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">            <span class=\"comment\">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class=\"line\">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class=\"line\">            v.modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class=\"line\"><span class=\"comment\">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class=\"line\"><span class=\"comment\">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class=\"line\"><span class=\"comment\">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">            <span class=\"comment\">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Positional Access Operations</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">elementData</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回此列表中指定位置的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//对index进行界限检查</span></span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        <span class=\"comment\">//返回原来在这个位置的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">        elementData[size++] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">        <span class=\"comment\">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">        System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                         size - index);</span><br><span class=\"line\">        elementData[index] = element;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">      <span class=\"comment\">//从列表中删除的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class=\"line\"><span class=\"comment\">     *返回true，如果此列表包含指定的元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                    fastRemove(index);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Private remove method that skips bounds checking and does not</span></span><br><span class=\"line\"><span class=\"comment\">     * return the value removed.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\">        elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中删除所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数组中所有的元素的值设为null</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = c.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">        ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class=\"line\">                             numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.arraycopy(a, <span class=\"number\">0</span>, elementData, index, numNew);</span><br><span class=\"line\">        size += numNew;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">removeRange</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numMoved = size - toIndex;</span><br><span class=\"line\">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = newSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查给定的索引是否在范围内。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">outOfBoundsMsg</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Index: \"</span>+index+<span class=\"string\">\", Size: \"</span>+size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"comment\">//如果此列表被修改则返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class=\"line\"><span class=\"comment\">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class=\"line\"><span class=\"comment\">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span>+index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的列表迭代器是fail-fast 。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListItr(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class=\"line\"><span class=\"comment\">     *返回的迭代器是fail-fast 。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList源码分析\"><a href=\"#ArrayList源码分析\" class=\"headerlink\" title=\"ArrayList源码分析\"></a><font face=\"楷体\" id=\"1\">ArrayList源码分析</font></h3><h4 id=\"System-arraycopy-和Arrays-copyOf-方法\"><a href=\"#System-arraycopy-和Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy()和Arrays.copyOf()方法\"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color=\"red\">add(int index, E element)</font>方法就很巧妙的用到了<font color=\"red\">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class=\"line\"><span class=\"comment\"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class=\"line\"><span class=\"comment\"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    <span class=\"comment\">//arraycopy()方法实现数组自己复制自己</span></span><br><span class=\"line\">    <span class=\"comment\">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>又如toArray()方法中用到了copyOf()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class=\"line\"><span class=\"comment\"> *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class=\"line\"><span class=\"comment\"> *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\"><span class=\"comment\">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"两者联系与区别\"><a href=\"#两者联系与区别\" class=\"headerlink\" title=\"两者联系与区别\"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p>\n<ol>\n<li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li>\n<li>copyOf()是系统自动在内部新建一个数组，并返回该数组。<h4 id=\"ArrayList-核心扩容技术\"><a href=\"#ArrayList-核心扩容技术\" class=\"headerlink\" title=\"ArrayList 核心扩容技术\"></a>ArrayList 核心扩容技术</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//下面是ArrayList的扩容机制</span></span><br><span class=\"line\"><span class=\"comment\">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class=\"line\"><span class=\"comment\">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>   minCapacity   所需的最小容量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class=\"line\">            <span class=\"comment\">// any size if not default element table</span></span><br><span class=\"line\">            ? <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"comment\">// larger than default for default empty table. It's already</span></span><br><span class=\"line\">            <span class=\"comment\">// supposed to be at default size.</span></span><br><span class=\"line\">            : DEFAULT_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class=\"line\">            ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class=\"line\">        <span class=\"comment\">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">            grow(minCapacity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//elementData为保存ArrayList数据的数组</span></span><br><span class=\"line\">   <span class=\"comment\">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class=\"line\">    <span class=\"comment\">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color=\"red\">&lt;&lt;(左移)</font>、<font color=\"red\">&gt;&gt;(带符号右移)</font>和<font color=\"red\">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</p>\n<p><strong>另外需要注意的是：</strong></p>\n<ol>\n<li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p>\n</li>\n<li><p>java 中的<strong>length()方法</strong>是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p>\n</li>\n<li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p>\n</li>\n</ol>\n<h4 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">(3)<span class=\"title\">private</span> <span class=\"title\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>  </span></span><br><span class=\"line\"><span class=\"class\">(4)<span class=\"title\">static</span> <span class=\"title\">final</span> <span class=\"title\">class</span> <span class=\"title\">ArrayListSpliterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Spliterator</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>　　ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>\n<h3 id=\"ArrayList经典Demo\"><a href=\"#ArrayList经典Demo\" class=\"headerlink\" title=\" ArrayList经典Demo\"></a><font face=\"楷体\" id=\"6\"> ArrayList经典Demo</font></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> list;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] srgs)</span></span>&#123;</span><br><span class=\"line\">         ArrayList&lt;Integer&gt; arrayList = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"Before add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">7</span>);</span><br><span class=\"line\">         arrayList.add(<span class=\"number\">9</span>);</span><br><span class=\"line\">         System.out.printf(<span class=\"string\">\"After add:arrayList.size() = %d\\n\"</span>,arrayList.size());</span><br><span class=\"line\"></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"Printing elements of arrayList\"</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 三种遍历方式打印元素</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种：通过迭代器遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class=\"line\">         <span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">             System.out.print(it.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种：通过索引值遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"通过索引值遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class=\"line\">             System.out.print(arrayList.get(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第三种：for循环遍历</span></span><br><span class=\"line\">         System.out.print(<span class=\"string\">\"for循环遍历:\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(Integer number : arrayList)&#123;</span><br><span class=\"line\">             System.out.print(number + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// toArray用法</span></span><br><span class=\"line\">         <span class=\"comment\">// 第一种方式(最常用)</span></span><br><span class=\"line\">         Integer[] integer = arrayList.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 第二种方式(容易理解)</span></span><br><span class=\"line\">         Integer[] integer1 = <span class=\"keyword\">new</span> Integer[arrayList.size()];</span><br><span class=\"line\">         arrayList.toArray(integer1);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 抛出异常，java不支持向下转型</span></span><br><span class=\"line\">         <span class=\"comment\">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class=\"line\">         <span class=\"comment\">//integer2 = arrayList.toArray();</span></span><br><span class=\"line\">         System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 在指定位置添加元素</span></span><br><span class=\"line\">         arrayList.add(<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 删除指定位置上的元素</span></span><br><span class=\"line\">         arrayList.remove(<span class=\"number\">2</span>);    </span><br><span class=\"line\">         <span class=\"comment\">// 删除指定元素</span></span><br><span class=\"line\">         arrayList.remove((Object)<span class=\"number\">3</span>);</span><br><span class=\"line\">         <span class=\"comment\">// 判断arrayList是否包含5</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList contains 5 is: \"</span> + arrayList.contains(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// 清空ArrayList</span></span><br><span class=\"line\">         arrayList.clear();</span><br><span class=\"line\">         <span class=\"comment\">// 判断ArrayList是否为空</span></span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"ArrayList is empty: \"</span> + arrayList.isEmpty());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck2u3gdqk0002qnn9bfvosdsn","category_id":"ck2u3gdqz0004qnn9xnt92701","_id":"ck2u3gdra000bqnn9mu58s0av"},{"post_id":"ck2u3gdqu0003qnn9w77l9ig6","category_id":"ck2u3gdr60008qnn9tniurxj9","_id":"ck2u3gdrf000fqnn98qboufbm"},{"post_id":"ck2u3gdr30006qnn90ycuxgf3","category_id":"ck2u3gdr60008qnn9tniurxj9","_id":"ck2u3gdrg000iqnn99qav9fmt"},{"post_id":"ck2u3gdr40007qnn9uagsz8tg","category_id":"ck2u3gdrf000eqnn9sxqsxyz2","_id":"ck2u3gdrh000lqnn96bwcqfsn"},{"post_id":"ck2u3gds6000uqnn92mzcdqj1","category_id":"ck2u3gdsc000vqnn9ajhup9n7","_id":"ck2u3gdsd000yqnn9nd57x4gi"},{"post_id":"ck2u3gdtk0014qnn9dg3wydo7","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdu3001rqnn9zq4kliuv"},{"post_id":"ck2u3gdtk0014qnn9dg3wydo7","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gdu5001wqnn96ofe661x"},{"post_id":"ck2u3gdtc000zqnn9emi77tcj","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdu80020qnn9ej05b412"},{"post_id":"ck2u3gdtc000zqnn9emi77tcj","category_id":"ck2u3gdty001lqnn9m9lntvoi","_id":"ck2u3gdua0024qnn9qcadw307"},{"post_id":"ck2u3gdtm0015qnn9j81d178h","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdub0028qnn9qyu8d4wq"},{"post_id":"ck2u3gdtm0015qnn9j81d178h","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gdud002cqnn9t8md7swv"},{"post_id":"ck2u3gdtp0018qnn91pxgww7q","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdug002gqnn9lwmbo771"},{"post_id":"ck2u3gdtp0018qnn91pxgww7q","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gduk002kqnn9lil4amvb"},{"post_id":"ck2u3gdtd0010qnn934t8tb0q","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdum002oqnn9lkdpa9qe"},{"post_id":"ck2u3gdtd0010qnn934t8tb0q","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gduo002rqnn9za2x7d4g"},{"post_id":"ck2u3gdtr0019qnn97u9ht7qf","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gduq002wqnn9aszkbbo4"},{"post_id":"ck2u3gdtr0019qnn97u9ht7qf","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gdut002zqnn9sc9h5cn9"},{"post_id":"ck2u3gdtt001cqnn9ap05uxfm","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdux0034qnn9qnwat1jk"},{"post_id":"ck2u3gdtt001cqnn9ap05uxfm","category_id":"ck2u3gdtu001fqnn9ktedibjc","_id":"ck2u3gdv00037qnn99fb45u9m"},{"post_id":"ck2u3gdtf0013qnn9k5q1l26a","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdv5003bqnn9ycn8j015"},{"post_id":"ck2u3gdtf0013qnn9k5q1l26a","category_id":"ck2u3gdty001lqnn9m9lntvoi","_id":"ck2u3gdv8003fqnn9x0wrd5i6"},{"post_id":"ck2u3gduy0036qnn9ochzx5cz","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdva003jqnn9iyae6wqg"},{"post_id":"ck2u3gduy0036qnn9ochzx5cz","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdve003nqnn9u1jw4k60"},{"post_id":"ck2u3gdtu001eqnn94n9yhkwf","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdvf003qqnn9f5wfpk9r"},{"post_id":"ck2u3gdtu001eqnn94n9yhkwf","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdvi003uqnn9w52vf4er"},{"post_id":"ck2u3gdv20039qnn92xj7hu21","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdvk003xqnn9cd2r4vhf"},{"post_id":"ck2u3gdv20039qnn92xj7hu21","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdvm0041qnn9z7itw4d0"},{"post_id":"ck2u3gdv6003eqnn939z9crwd","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdvn0044qnn9y7rtwq0u"},{"post_id":"ck2u3gdv6003eqnn939z9crwd","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdvp0048qnn937f31iwl"},{"post_id":"ck2u3gdtv001iqnn9m034umn9","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdvq004bqnn9yj08nqe7"},{"post_id":"ck2u3gdtv001iqnn9m034umn9","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdvs004fqnn9mz209xlm"},{"post_id":"ck2u3gdv8003hqnn9reexzcu8","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdvw004iqnn94t8p5svb"},{"post_id":"ck2u3gdv8003hqnn9reexzcu8","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdvz004mqnn9t9nnmcas"},{"post_id":"ck2u3gdvb003mqnn9895u4sgj","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdw4004pqnn9e52o87pl"},{"post_id":"ck2u3gdvb003mqnn9895u4sgj","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdw7004tqnn9gk0dklzu"},{"post_id":"ck2u3gdtw001kqnn9sy93l922","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdwd004wqnn9hcx1q3qe"},{"post_id":"ck2u3gdtw001kqnn9sy93l922","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdwf0050qnn97def1ra6"},{"post_id":"ck2u3gdve003pqnn99dnv58l2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdwi0053qnn9nlwjlum4"},{"post_id":"ck2u3gdve003pqnn99dnv58l2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdwk0057qnn9bi963w7i"},{"post_id":"ck2u3gdvg003tqnn9oeyla9o0","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdwm005aqnn9opeog4gf"},{"post_id":"ck2u3gdvg003tqnn9oeyla9o0","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdwp005eqnn94drvw733"},{"post_id":"ck2u3gdu0001oqnn99xb102at","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdwu005hqnn9i2m8yumq"},{"post_id":"ck2u3gdu0001oqnn99xb102at","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdwx005lqnn9np4rif14"},{"post_id":"ck2u3gdvi003wqnn9l5aru7vp","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdx0005oqnn9p7om6bqg"},{"post_id":"ck2u3gdvi003wqnn9l5aru7vp","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdx2005sqnn979u5rbm8"},{"post_id":"ck2u3gdvk0040qnn9l3nx5uly","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdx4005vqnn9x5lz3upv"},{"post_id":"ck2u3gdvk0040qnn9l3nx5uly","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdx6005zqnn96za86v2y"},{"post_id":"ck2u3gdu2001qqnn9269z1xlq","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdx90062qnn9bpdv22t0"},{"post_id":"ck2u3gdu2001qqnn9269z1xlq","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxc0066qnn9gqxamput"},{"post_id":"ck2u3gdvm0043qnn9epuuylto","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxe0069qnn9i61edida"},{"post_id":"ck2u3gdvm0043qnn9epuuylto","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxh006dqnn92icshaj1"},{"post_id":"ck2u3gdvn0047qnn9yw2zzk6z","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxi006gqnn9arcwlk2w"},{"post_id":"ck2u3gdvn0047qnn9yw2zzk6z","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxj006jqnn9zrxdr1pq"},{"post_id":"ck2u3gdu4001vqnn94bryx6ks","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxl006mqnn95fs62u6m"},{"post_id":"ck2u3gdu4001vqnn94bryx6ks","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxn006pqnn96tzguur2"},{"post_id":"ck2u3gdvp004aqnn9nxinyozx","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxq006sqnn9imt7qd08"},{"post_id":"ck2u3gdvp004aqnn9nxinyozx","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxs006vqnn9sm1cvbj8"},{"post_id":"ck2u3gdvq004eqnn9e6lzsom5","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxu006yqnn9viwcthl0"},{"post_id":"ck2u3gdvq004eqnn9e6lzsom5","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxw0071qnn9f7s5dr4m"},{"post_id":"ck2u3gdu6001yqnn92wyqw2bm","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdxx0074qnn9gklqldv7"},{"post_id":"ck2u3gdu6001yqnn92wyqw2bm","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdxz0077qnn9rp3q2cp5"},{"post_id":"ck2u3gdvs004hqnn99zg68hme","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdy0007aqnn9ejetynvz"},{"post_id":"ck2u3gdvs004hqnn99zg68hme","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdy1007dqnn93rp8ayj0"},{"post_id":"ck2u3gdvx004lqnn97msjfai9","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdy4007gqnn9ufhxubl9"},{"post_id":"ck2u3gdvx004lqnn97msjfai9","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdy8007jqnn93bzccxd0"},{"post_id":"ck2u3gdu90023qnn9nrtk0wsm","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdy9007mqnn9r3rs04d0"},{"post_id":"ck2u3gdu90023qnn9nrtk0wsm","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdyc007pqnn9ukmra89o"},{"post_id":"ck2u3gdvz004oqnn9842wec5f","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdye007sqnn983st0dt9"},{"post_id":"ck2u3gdvz004oqnn9842wec5f","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdyg007vqnn9m9ht4r3b"},{"post_id":"ck2u3gdw5004sqnn970iran1z","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdyi007yqnn9mvcz29b0"},{"post_id":"ck2u3gdw5004sqnn970iran1z","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdym0081qnn9cbfwnhgc"},{"post_id":"ck2u3gdua0026qnn9vqigreif","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdyp0084qnn9ict2dqa3"},{"post_id":"ck2u3gdua0026qnn9vqigreif","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdyr0087qnn9lms66jxg"},{"post_id":"ck2u3gdw8004vqnn98l5edvm2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdyu008aqnn9vuwzcdii"},{"post_id":"ck2u3gdw8004vqnn98l5edvm2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdyw008dqnn9vh3zzuyp"},{"post_id":"ck2u3gdwd004zqnn9z0a4xuik","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdyx008gqnn9g4xi2cj8"},{"post_id":"ck2u3gdwd004zqnn9z0a4xuik","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdyy008jqnn97l8st919"},{"post_id":"ck2u3gduc002aqnn9ex7xpznw","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdz0008mqnn9tgac5nxo"},{"post_id":"ck2u3gduc002aqnn9ex7xpznw","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdz3008pqnn9jlw3xgyx"},{"post_id":"ck2u3gdwf0052qnn9hp646n3p","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdz5008sqnn99ceeb7wg"},{"post_id":"ck2u3gdwf0052qnn9hp646n3p","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzc008vqnn9vx6m929u"},{"post_id":"ck2u3gdwj0056qnn9sbeew0r1","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzd008yqnn980wyrk5h"},{"post_id":"ck2u3gdwj0056qnn9sbeew0r1","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzf0091qnn9qppxo8cm"},{"post_id":"ck2u3gdud002eqnn9z2finjfo","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzg0094qnn9y7wq9ssj"},{"post_id":"ck2u3gdud002eqnn9z2finjfo","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzj0097qnn9e5j6hdc0"},{"post_id":"ck2u3gdwk0059qnn9o1cubcgy","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzm009aqnn9w3cardtw"},{"post_id":"ck2u3gdwk0059qnn9o1cubcgy","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzn009dqnn97w48v241"},{"post_id":"ck2u3gdwm005dqnn9bpxscj40","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzp009gqnn9tbuihdxp"},{"post_id":"ck2u3gdwm005dqnn9bpxscj40","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzs009jqnn944sdmste"},{"post_id":"ck2u3gdui002iqnn9clg6vvf0","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzt009mqnn967z2cncx"},{"post_id":"ck2u3gdui002iqnn9clg6vvf0","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3gdzv009pqnn96ruihsnt"},{"post_id":"ck2u3gdws005gqnn9fny530mr","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3gdzx009sqnn93bsfp8sy"},{"post_id":"ck2u3gdws005gqnn9fny530mr","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge01009vqnn9kck03efp"},{"post_id":"ck2u3gdwv005kqnn90n77pppd","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge03009yqnn9uea8gbiy"},{"post_id":"ck2u3gdwv005kqnn90n77pppd","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0600a1qnn98jarq040"},{"post_id":"ck2u3gduk002mqnn9sej1uqak","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0800a4qnn9re1brmpr"},{"post_id":"ck2u3gduk002mqnn9sej1uqak","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0a00a7qnn9d1q1zvas"},{"post_id":"ck2u3gdwx005nqnn9if3coh4v","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0c00aaqnn93c1owe59"},{"post_id":"ck2u3gdwx005nqnn9if3coh4v","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0d00adqnn9y0pe591y"},{"post_id":"ck2u3gdx1005rqnn90jv956w2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0e00afqnn9hiyelo0o"},{"post_id":"ck2u3gdx1005rqnn90jv956w2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0e00ajqnn9lv7p7lak"},{"post_id":"ck2u3gdum002qqnn9f8a98v7r","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0f00alqnn9tnclt3xv"},{"post_id":"ck2u3gdum002qqnn9f8a98v7r","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0f00anqnn92d6voqrh"},{"post_id":"ck2u3gdx3005uqnn9aefcxi3m","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0g00aqqnn9roo7sluv"},{"post_id":"ck2u3gdx3005uqnn9aefcxi3m","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0g00asqnn9bx2noer9"},{"post_id":"ck2u3gdx4005yqnn9i6y9q0n1","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0h00auqnn9tcu8l9qj"},{"post_id":"ck2u3gdx4005yqnn9i6y9q0n1","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0h00awqnn9wjqqrzlz"},{"post_id":"ck2u3gdup002uqnn9fxa9ut5o","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0h00ayqnn9bo185c9l"},{"post_id":"ck2u3gdup002uqnn9fxa9ut5o","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0h00b0qnn9qkeq9o5a"},{"post_id":"ck2u3gdx70061qnn9my0oyfg7","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0i00b2qnn9530sh9sd"},{"post_id":"ck2u3gdx70061qnn9my0oyfg7","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0i00b4qnn9mei93d6l"},{"post_id":"ck2u3gdxa0065qnn9ufo2x0o1","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0i00b6qnn9l0z2d1np"},{"post_id":"ck2u3gdxa0065qnn9ufo2x0o1","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0i00b8qnn9lghrafnp"},{"post_id":"ck2u3gdus002yqnn9908doukk","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0j00baqnn91z0fqxmm"},{"post_id":"ck2u3gdus002yqnn9908doukk","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0j00bcqnn955gf4ro2"},{"post_id":"ck2u3gdxd0068qnn9f2d43pms","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0j00beqnn9aaxa4fxi"},{"post_id":"ck2u3gdxd0068qnn9f2d43pms","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0j00bgqnn990q1zpnq"},{"post_id":"ck2u3gdxf006cqnn9pgr3oc72","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0j00bhqnn9aeidbbao"},{"post_id":"ck2u3gdxf006cqnn9pgr3oc72","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0j00biqnn9s13acprh"},{"post_id":"ck2u3gdut0032qnn9f637earg","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00bjqnn9qci3mlvr"},{"post_id":"ck2u3gdut0032qnn9f637earg","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00bkqnn94gw43i5b"},{"post_id":"ck2u3gdxh006fqnn9nff7ryda","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00blqnn94pyzd8jg"},{"post_id":"ck2u3gdxh006fqnn9nff7ryda","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00bmqnn9wsij10eg"},{"post_id":"ck2u3gdxi006iqnn91vh75xiw","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00bnqnn94xmdl74u"},{"post_id":"ck2u3gdxi006iqnn91vh75xiw","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00boqnn9fzskrq8s"},{"post_id":"ck2u3gdxk006lqnn9zfbl2nsv","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00bpqnn94wp8mqh0"},{"post_id":"ck2u3gdxk006lqnn9zfbl2nsv","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00bqqnn9sbmilhui"},{"post_id":"ck2u3gdxl006oqnn9miq6asag","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00brqnn9e5rzjr8m"},{"post_id":"ck2u3gdxl006oqnn9miq6asag","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00bsqnn901wyb8yp"},{"post_id":"ck2u3gdxo006rqnn979iji7io","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00btqnn98onti0pr"},{"post_id":"ck2u3gdxo006rqnn979iji7io","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00buqnn92s756pka"},{"post_id":"ck2u3gdxr006uqnn96gg1pt1o","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0k00bvqnn9xxvkdgim"},{"post_id":"ck2u3gdxr006uqnn96gg1pt1o","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0k00bwqnn99w54p6ip"},{"post_id":"ck2u3gdxs006xqnn98cpnhukq","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00bxqnn9g7ffmjob"},{"post_id":"ck2u3gdxs006xqnn98cpnhukq","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00byqnn96gn4w5l0"},{"post_id":"ck2u3gdxv0070qnn9bj4ca7ar","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00bzqnn9ek3yurdw"},{"post_id":"ck2u3gdxv0070qnn9bj4ca7ar","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00c0qnn98duqqruv"},{"post_id":"ck2u3gdxx0073qnn9vc2nnnu5","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00c1qnn95xl7j2bu"},{"post_id":"ck2u3gdxx0073qnn9vc2nnnu5","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00c2qnn9ozklp3dx"},{"post_id":"ck2u3gdxy0076qnn9u9xhizcb","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00c3qnn9disbwpo6"},{"post_id":"ck2u3gdxy0076qnn9u9xhizcb","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00c4qnn9ze1l0ntc"},{"post_id":"ck2u3gdxz0079qnn9alyk5ae4","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00c5qnn9y5y57hi7"},{"post_id":"ck2u3gdxz0079qnn9alyk5ae4","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00c6qnn9gnlfcqyo"},{"post_id":"ck2u3gdy0007cqnn91vitcfht","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0l00c7qnn9mith5uvk"},{"post_id":"ck2u3gdy0007cqnn91vitcfht","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0l00c8qnn93qpqex61"},{"post_id":"ck2u3gdy1007fqnn9k6693jva","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00c9qnn9pr5caidk"},{"post_id":"ck2u3gdy1007fqnn9k6693jva","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00caqnn9cmrn5015"},{"post_id":"ck2u3gdy5007iqnn9x6gs0uwi","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00cbqnn9qzrrvr9g"},{"post_id":"ck2u3gdy5007iqnn9x6gs0uwi","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00ccqnn97j1lcmry"},{"post_id":"ck2u3gdy8007lqnn98esbxdvc","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00cdqnn9fsyzhl4s"},{"post_id":"ck2u3gdy8007lqnn98esbxdvc","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00ceqnn9kwr07pnh"},{"post_id":"ck2u3gdya007oqnn9iaynms3u","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00cfqnn9atogwb15"},{"post_id":"ck2u3gdya007oqnn9iaynms3u","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00cgqnn9ynn3vo3x"},{"post_id":"ck2u3gdyd007rqnn9tihgrfs2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00chqnn9bxhe1fg7"},{"post_id":"ck2u3gdyd007rqnn9tihgrfs2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00ciqnn9gvrgs2a4"},{"post_id":"ck2u3gdye007uqnn9sjzimgvf","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0m00cjqnn9j152xybv"},{"post_id":"ck2u3gdye007uqnn9sjzimgvf","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0m00ckqnn96kh7xc3n"},{"post_id":"ck2u3gdyg007xqnn9fj4b7zmt","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00clqnn9vdtp5q9f"},{"post_id":"ck2u3gdyg007xqnn9fj4b7zmt","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00cmqnn9hfrazevo"},{"post_id":"ck2u3gdyj0080qnn9miotpc6c","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00cnqnn9ymw6r08l"},{"post_id":"ck2u3gdyj0080qnn9miotpc6c","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00coqnn9pgr251ap"},{"post_id":"ck2u3gdyo0083qnn98fc9asz5","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00cpqnn9dqny3i22"},{"post_id":"ck2u3gdyo0083qnn98fc9asz5","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00cqqnn92ob3nb7y"},{"post_id":"ck2u3gdyp0086qnn9tryha59e","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00crqnn90sqh6npw"},{"post_id":"ck2u3gdyp0086qnn9tryha59e","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00csqnn9m515v0g7"},{"post_id":"ck2u3gdyr0089qnn939pn4j1k","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00ctqnn9en31nlxv"},{"post_id":"ck2u3gdyr0089qnn939pn4j1k","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00cuqnn9sttd2009"},{"post_id":"ck2u3gdyu008cqnn9dgb31dsc","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00cvqnn9vctc8hix"},{"post_id":"ck2u3gdyu008cqnn9dgb31dsc","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0n00cwqnn9q17pf672"},{"post_id":"ck2u3gdyw008fqnn93howmxp2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0n00cxqnn9kg4hxv8h"},{"post_id":"ck2u3gdyw008fqnn93howmxp2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0o00cyqnn91m8rcrxy"},{"post_id":"ck2u3gdyx008iqnn9uhqboo6m","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0o00czqnn9keurzxeq"},{"post_id":"ck2u3gdyx008iqnn9uhqboo6m","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0o00d0qnn93bufvvca"},{"post_id":"ck2u3gdyz008lqnn924uucj74","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0o00d1qnn9vfygyx2u"},{"post_id":"ck2u3gdyz008lqnn924uucj74","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0o00d2qnn9qm9djkfa"},{"post_id":"ck2u3gdz0008oqnn9vqy4igcx","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0o00d3qnn92sky5yrd"},{"post_id":"ck2u3gdz0008oqnn9vqy4igcx","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0o00d4qnn985fehgzj"},{"post_id":"ck2u3gdz4008rqnn91dsbegz8","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0o00d5qnn9h4u6s0n8"},{"post_id":"ck2u3gdz4008rqnn91dsbegz8","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0p00d6qnn9m3isv5zd"},{"post_id":"ck2u3gdz6008uqnn9yciubzi8","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0p00d7qnn9gqiwfa8y"},{"post_id":"ck2u3gdz6008uqnn9yciubzi8","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0p00d8qnn9ibp03vk9"},{"post_id":"ck2u3gdzc008xqnn95q4udwgi","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0p00d9qnn9wsjjhyjh"},{"post_id":"ck2u3gdzc008xqnn95q4udwgi","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0p00daqnn9r5i9tt6a"},{"post_id":"ck2u3gdze0090qnn9x6jod2iq","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0p00dbqnn92yzf958w"},{"post_id":"ck2u3gdze0090qnn9x6jod2iq","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0p00dcqnn9oaozcff6"},{"post_id":"ck2u3gdzf0093qnn93e3w5ja0","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0p00ddqnn9jeyg4gxx"},{"post_id":"ck2u3gdzf0093qnn93e3w5ja0","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0p00deqnn9q7aet9ov"},{"post_id":"ck2u3gdzh0096qnn94dehcn80","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00dfqnn9ad14o5pv"},{"post_id":"ck2u3gdzh0096qnn94dehcn80","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0q00dgqnn9m8y25dfb"},{"post_id":"ck2u3gdzk0099qnn9nol0dtvb","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00dhqnn9x28a457p"},{"post_id":"ck2u3gdzk0099qnn9nol0dtvb","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0q00diqnn9f7xjtxsw"},{"post_id":"ck2u3gdzm009cqnn9kadgzfd2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00djqnn9wgj3kpuk"},{"post_id":"ck2u3gdzm009cqnn9kadgzfd2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0q00dkqnn94odcjt11"},{"post_id":"ck2u3gdzo009fqnn9o5h0trcv","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00dlqnn9hfkg7cje"},{"post_id":"ck2u3gdzo009fqnn9o5h0trcv","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0q00dmqnn9j9a31f72"},{"post_id":"ck2u3gdzq009iqnn9ozdr4ppt","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00dnqnn9vdslthub"},{"post_id":"ck2u3gdzq009iqnn9ozdr4ppt","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0q00doqnn9ax4xq975"},{"post_id":"ck2u3gdzs009lqnn90gvo1q6a","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0q00dpqnn9044e3tjv"},{"post_id":"ck2u3gdzs009lqnn90gvo1q6a","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00dqqnn96ir9sbti"},{"post_id":"ck2u3gdzu009oqnn9plvot9xy","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00drqnn9lu5v6tzy"},{"post_id":"ck2u3gdzu009oqnn9plvot9xy","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00dsqnn9qzlcrgcs"},{"post_id":"ck2u3gdzv009rqnn92lum0cab","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00dtqnn93ef9m4hm"},{"post_id":"ck2u3gdzv009rqnn92lum0cab","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00duqnn9sk1gk3vd"},{"post_id":"ck2u3gdzy009uqnn9nuzd4uap","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00dvqnn9r9hwg2v9"},{"post_id":"ck2u3gdzy009uqnn9nuzd4uap","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00dwqnn94ymintyl"},{"post_id":"ck2u3ge01009xqnn9ex7q4h1g","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00dxqnn97xjslzj5"},{"post_id":"ck2u3ge01009xqnn9ex7q4h1g","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00dyqnn9ifcy40r9"},{"post_id":"ck2u3ge0400a0qnn9u3um90h2","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00dzqnn9owxywifo"},{"post_id":"ck2u3ge0400a0qnn9u3um90h2","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00e0qnn9kk0720l9"},{"post_id":"ck2u3ge0600a3qnn9j6nh3d1j","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0r00e1qnn9txpnse5b"},{"post_id":"ck2u3ge0600a3qnn9j6nh3d1j","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0r00e2qnn9uq9tzaoe"},{"post_id":"ck2u3ge0800a6qnn9lg8rdndx","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0s00e3qnn94w54pfl1"},{"post_id":"ck2u3ge0800a6qnn9lg8rdndx","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0s00e4qnn9orkibzas"},{"post_id":"ck2u3ge0a00a9qnn9ujsvo7hk","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge0s00e5qnn9ya8s7vyi"},{"post_id":"ck2u3ge0a00a9qnn9ujsvo7hk","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge0s00e6qnn9vmz975v1"},{"post_id":"ck2u3ge0c00acqnn9nmzaaty3","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge0s00e7qnn9q4uji4j7"},{"post_id":"ck2u3ge0c00acqnn9nmzaaty3","category_id":"ck2u3ge0f00apqnn9feqhup37","_id":"ck2u3ge0s00e8qnn9zvcwa36p"},{"post_id":"ck2u3ge1900e9qnn9xf4uzf1i","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge1i00efqnn9mzmqik2i"},{"post_id":"ck2u3ge1900e9qnn9xf4uzf1i","category_id":"ck2u3gdty001lqnn9m9lntvoi","_id":"ck2u3ge1m00ejqnn9pdnw6q3t"},{"post_id":"ck2u3ge1a00eaqnn9lh5zb61p","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge1p00enqnn92behuf2m"},{"post_id":"ck2u3ge1a00eaqnn9lh5zb61p","category_id":"ck2u3gdty001lqnn9m9lntvoi","_id":"ck2u3ge1r00eqqnn9ab3jlv8o"},{"post_id":"ck2u3ge1d00ecqnn9xj41epul","category_id":"ck2u3gdtf0011qnn9yomtheaw","_id":"ck2u3ge1t00etqnn9bdpt8sdt"},{"post_id":"ck2u3ge1d00ecqnn9xj41epul","category_id":"ck2u3gduw0033qnn92z041qaj","_id":"ck2u3ge1v00ewqnn9qzt52opd"},{"post_id":"ck2u3ge1p00eoqnn9txxtcqtt","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge1x00eyqnn92lkhkl5f"},{"post_id":"ck2u3ge1p00eoqnn9txxtcqtt","category_id":"ck2u3ge1o00emqnn9bqqpgcdj","_id":"ck2u3ge1y00f1qnn9z2km75od"},{"post_id":"ck2u3ge1h00eeqnn9iaopocwj","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge1z00f3qnn9dwpsjh5v"},{"post_id":"ck2u3ge1h00eeqnn9iaopocwj","category_id":"ck2u3ge1o00emqnn9bqqpgcdj","_id":"ck2u3ge2100f4qnn9zn5mviax"},{"post_id":"ck2u3ge1k00eiqnn9i76t9m93","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2300f6qnn94cs604li"},{"post_id":"ck2u3ge1k00eiqnn9i76t9m93","category_id":"ck2u3ge1s00esqnn9za2dfsr5","_id":"ck2u3ge2400f8qnn9m89829c5"},{"post_id":"ck2u3ge1n00elqnn94x7nuu66","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2500fbqnn9vm2o5els"},{"post_id":"ck2u3ge1n00elqnn94x7nuu66","category_id":"ck2u3ge1x00ezqnn9e4gpdebw","_id":"ck2u3ge2500fdqnn9ml3q5e70"},{"post_id":"ck2u3ge2e00ffqnn9qdsxg0n5","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2k00fkqnn953k74bk7"},{"post_id":"ck2u3ge2e00ffqnn9qdsxg0n5","category_id":"ck2u3ge1o00emqnn9bqqpgcdj","_id":"ck2u3ge2l00fmqnn9rfngsplo"},{"post_id":"ck2u3ge2f00fgqnn9i19lnrmk","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2l00fnqnn9xs7zedew"},{"post_id":"ck2u3ge2f00fgqnn9i19lnrmk","category_id":"ck2u3ge1x00ezqnn9e4gpdebw","_id":"ck2u3ge2m00fpqnn9j582viq0"},{"post_id":"ck2u3ge2h00fiqnn9oha1f06n","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2m00fqqnn9t4ranob3"},{"post_id":"ck2u3ge2h00fiqnn9oha1f06n","category_id":"ck2u3ge1x00ezqnn9e4gpdebw","_id":"ck2u3ge2m00frqnn95abrjooc"},{"post_id":"ck2u3ge2p00fuqnn9nwhgy0ef","category_id":"ck2u3ge0e00agqnn93ywogllt","_id":"ck2u3ge2s00fwqnn9o112a8gd"},{"post_id":"ck2u3ge2p00fuqnn9nwhgy0ef","category_id":"ck2u3ge1x00ezqnn9e4gpdebw","_id":"ck2u3ge2s00fxqnn9fcg4ggc0"}],"PostTag":[{"post_id":"ck2u3gdqk0002qnn9bfvosdsn","tag_id":"ck2u3gdr20005qnn98zsv4dvq","_id":"ck2u3gdr9000aqnn9dp5w59q6"},{"post_id":"ck2u3gdqu0003qnn9w77l9ig6","tag_id":"ck2u3gdr70009qnn9zz8ucnzm","_id":"ck2u3gdrg000hqnn9s57n0rf7"},{"post_id":"ck2u3gdqu0003qnn9w77l9ig6","tag_id":"ck2u3gdra000dqnn91zf3j7o9","_id":"ck2u3gdrg000jqnn9xbjxkor3"},{"post_id":"ck2u3gdr30006qnn90ycuxgf3","tag_id":"ck2u3gdrg000gqnn9t4xjp9lp","_id":"ck2u3gdrh000oqnn9h4qtm1z9"},{"post_id":"ck2u3gdr30006qnn90ycuxgf3","tag_id":"ck2u3gdrg000kqnn9l9426hrh","_id":"ck2u3gdrh000pqnn9c1pmx0hb"},{"post_id":"ck2u3gdr30006qnn90ycuxgf3","tag_id":"ck2u3gdrh000mqnn9kpgbe3cr","_id":"ck2u3gdri000rqnn9g2wcoz1i"},{"post_id":"ck2u3gdr40007qnn9uagsz8tg","tag_id":"ck2u3gdrh000nqnn9kl3ulzk4","_id":"ck2u3gdrj000sqnn9ohcjd4t9"},{"post_id":"ck2u3gdr40007qnn9uagsz8tg","tag_id":"ck2u3gdrh000mqnn9kpgbe3cr","_id":"ck2u3gdrj000tqnn9w5cr10mm"},{"post_id":"ck2u3gds6000uqnn92mzcdqj1","tag_id":"ck2u3gdsc000wqnn9tp9rrw50","_id":"ck2u3gdsd000xqnn951tqbqky"},{"post_id":"ck2u3gdtc000zqnn9emi77tcj","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdtt001dqnn97h5exylv"},{"post_id":"ck2u3gdtc000zqnn9emi77tcj","tag_id":"ck2u3gdtn0017qnn9ugpbhdb4","_id":"ck2u3gdtv001gqnn9gp2wbvpl"},{"post_id":"ck2u3gdtu001eqnn94n9yhkwf","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdtw001jqnn9e10rdspl"},{"post_id":"ck2u3gdtv001iqnn9m034umn9","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdtz001nqnn9uzooxo0m"},{"post_id":"ck2u3gdtd0010qnn934t8tb0q","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdu2001pqnn9qxv9khie"},{"post_id":"ck2u3gdtd0010qnn934t8tb0q","tag_id":"ck2u3gdtv001hqnn93o1lnha9","_id":"ck2u3gdu4001uqnn9qq9rgfxb"},{"post_id":"ck2u3gdtw001kqnn9sy93l922","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdu5001xqnn985kc0tru"},{"post_id":"ck2u3gdu0001oqnn99xb102at","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdu80021qnn98r1rv1db"},{"post_id":"ck2u3gdu2001qqnn9269z1xlq","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdua0025qnn9390vbi5r"},{"post_id":"ck2u3gdu4001vqnn94bryx6ks","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdub0029qnn9wbyybzio"},{"post_id":"ck2u3gdu6001yqnn92wyqw2bm","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdud002dqnn91bhkucqu"},{"post_id":"ck2u3gdu90023qnn9nrtk0wsm","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gduh002hqnn9zpn9aig0"},{"post_id":"ck2u3gdua0026qnn9vqigreif","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gduk002lqnn9lw6fd7g9"},{"post_id":"ck2u3gdtf0013qnn9k5q1l26a","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdum002pqnn9b7o04q3s"},{"post_id":"ck2u3gdtf0013qnn9k5q1l26a","tag_id":"ck2u3gdu3001tqnn9e1h7zyfl","_id":"ck2u3gduo002tqnn9ihi9gjp2"},{"post_id":"ck2u3gdtf0013qnn9k5q1l26a","tag_id":"ck2u3gdu90022qnn90dauclx7","_id":"ck2u3gduq002xqnn9tf9ifcug"},{"post_id":"ck2u3gduc002aqnn9ex7xpznw","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdut0030qnn9zoi8r64a"},{"post_id":"ck2u3gdud002eqnn9z2finjfo","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdux0035qnn9hm62wkr5"},{"post_id":"ck2u3gdtk0014qnn9dg3wydo7","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdv00038qnn9ksrzqdi3"},{"post_id":"ck2u3gdtk0014qnn9dg3wydo7","tag_id":"ck2u3gduc002bqnn9yri7zys6","_id":"ck2u3gdv5003cqnn99fxikd3m"},{"post_id":"ck2u3gdui002iqnn9clg6vvf0","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdv8003gqnn9ivdbfjm6"},{"post_id":"ck2u3gduk002mqnn9sej1uqak","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdva003kqnn96utauvo8"},{"post_id":"ck2u3gdum002qqnn9f8a98v7r","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdve003oqnn92vvw0e1k"},{"post_id":"ck2u3gdup002uqnn9fxa9ut5o","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvg003rqnn995lnekrr"},{"post_id":"ck2u3gdtm0015qnn9j81d178h","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvi003vqnn9u4lsodgt"},{"post_id":"ck2u3gdtm0015qnn9j81d178h","tag_id":"ck2u3gduj002jqnn9u4y25ukh","_id":"ck2u3gdvk003yqnn9b3kiy8c7"},{"post_id":"ck2u3gdtm0015qnn9j81d178h","tag_id":"ck2u3gduo002sqnn9xm2bd5cx","_id":"ck2u3gdvm0042qnn9mymmdiug"},{"post_id":"ck2u3gdus002yqnn9908doukk","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvn0045qnn9mr0x96oz"},{"post_id":"ck2u3gdut0032qnn9f637earg","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvp0049qnn9r6cwjiwp"},{"post_id":"ck2u3gduy0036qnn9ochzx5cz","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvq004cqnn9wy20iah4"},{"post_id":"ck2u3gdtp0018qnn91pxgww7q","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvs004gqnn9wohoeto4"},{"post_id":"ck2u3gdtp0018qnn91pxgww7q","tag_id":"ck2u3gdut0031qnn9itzb9wvh","_id":"ck2u3gdvx004jqnn9htdsvxbc"},{"post_id":"ck2u3gdv20039qnn92xj7hu21","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdvz004nqnn9awghkpit"},{"post_id":"ck2u3gdv6003eqnn939z9crwd","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdw5004qqnn914jso9y3"},{"post_id":"ck2u3gdtr0019qnn97u9ht7qf","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdw8004uqnn9yel3c5ix"},{"post_id":"ck2u3gdtr0019qnn97u9ht7qf","tag_id":"ck2u3gdv4003aqnn9wxijve5q","_id":"ck2u3gdwd004xqnn9f4igxcbf"},{"post_id":"ck2u3gdv8003hqnn9reexzcu8","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdwf0051qnn9mtsn3p9e"},{"post_id":"ck2u3gdvb003mqnn9895u4sgj","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdwi0054qnn9pffolh88"},{"post_id":"ck2u3gdtt001cqnn9ap05uxfm","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdwk0058qnn9ixa99b7m"},{"post_id":"ck2u3gdtt001cqnn9ap05uxfm","tag_id":"ck2u3gdva003iqnn9qs2j2q24","_id":"ck2u3gdwm005bqnn9ykqrhnaa"},{"post_id":"ck2u3gdve003pqnn99dnv58l2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdws005fqnn93s11s7x4"},{"post_id":"ck2u3gdvg003tqnn9oeyla9o0","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdwu005iqnn90d3kc8tv"},{"post_id":"ck2u3gdvi003wqnn9l5aru7vp","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdwx005mqnn9srs0y0bb"},{"post_id":"ck2u3gdvk0040qnn9l3nx5uly","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdx0005pqnn9w2mw4we6"},{"post_id":"ck2u3gdvm0043qnn9epuuylto","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdx2005tqnn9mw22p0nw"},{"post_id":"ck2u3gdvn0047qnn9yw2zzk6z","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdx4005wqnn9koppml80"},{"post_id":"ck2u3gdvp004aqnn9nxinyozx","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdx70060qnn9wxtq735y"},{"post_id":"ck2u3gdvq004eqnn9e6lzsom5","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdx90063qnn90k40fgkh"},{"post_id":"ck2u3gdvs004hqnn99zg68hme","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxd0067qnn9oxdqvuak"},{"post_id":"ck2u3gdvx004lqnn97msjfai9","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxf006aqnn90ynykjf1"},{"post_id":"ck2u3gdvz004oqnn9842wec5f","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxh006eqnn9kzshsxt0"},{"post_id":"ck2u3gdw5004sqnn970iran1z","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxi006hqnn98cmp0wrg"},{"post_id":"ck2u3gdw8004vqnn98l5edvm2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxk006kqnn9ojppno8d"},{"post_id":"ck2u3gdwd004zqnn9z0a4xuik","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxl006nqnn9re1euaxz"},{"post_id":"ck2u3gdwf0052qnn9hp646n3p","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxo006qqnn9nancsh1w"},{"post_id":"ck2u3gdwj0056qnn9sbeew0r1","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxr006tqnn959jkmagj"},{"post_id":"ck2u3gdwk0059qnn9o1cubcgy","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxs006wqnn9b0y8u35q"},{"post_id":"ck2u3gdwm005dqnn9bpxscj40","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxv006zqnn91ah5szfd"},{"post_id":"ck2u3gdws005gqnn9fny530mr","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxw0072qnn9d91xwbcr"},{"post_id":"ck2u3gdwv005kqnn90n77pppd","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxy0075qnn9mda6f5oe"},{"post_id":"ck2u3gdwx005nqnn9if3coh4v","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdxz0078qnn9j2zkaakx"},{"post_id":"ck2u3gdx1005rqnn90jv956w2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdy0007bqnn9xqzmlw26"},{"post_id":"ck2u3gdx3005uqnn9aefcxi3m","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdy1007eqnn9el66ucb5"},{"post_id":"ck2u3gdx4005yqnn9i6y9q0n1","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdy5007hqnn9l8ud8spa"},{"post_id":"ck2u3gdx70061qnn9my0oyfg7","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdy8007kqnn9jvzamvg7"},{"post_id":"ck2u3gdxa0065qnn9ufo2x0o1","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdya007nqnn9j93236nw"},{"post_id":"ck2u3gdxd0068qnn9f2d43pms","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyc007qqnn97vz3gaw5"},{"post_id":"ck2u3gdxf006cqnn9pgr3oc72","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdye007tqnn9o4esilcw"},{"post_id":"ck2u3gdxh006fqnn9nff7ryda","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyg007wqnn9p7lsuk9x"},{"post_id":"ck2u3gdxi006iqnn91vh75xiw","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyi007zqnn9idliwi8v"},{"post_id":"ck2u3gdxk006lqnn9zfbl2nsv","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyn0082qnn90qw5aj73"},{"post_id":"ck2u3gdxl006oqnn9miq6asag","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyp0085qnn9loc5jvo2"},{"post_id":"ck2u3gdxo006rqnn979iji7io","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyr0088qnn9s1l5gv3t"},{"post_id":"ck2u3gdxr006uqnn96gg1pt1o","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyu008bqnn98l6rzyzq"},{"post_id":"ck2u3gdxs006xqnn98cpnhukq","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyw008eqnn9ntcm8mus"},{"post_id":"ck2u3gdxv0070qnn9bj4ca7ar","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyx008hqnn9l8m351hq"},{"post_id":"ck2u3gdxx0073qnn9vc2nnnu5","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdyy008kqnn99m6wvq3c"},{"post_id":"ck2u3gdxy0076qnn9u9xhizcb","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdz0008nqnn9s5mvlyah"},{"post_id":"ck2u3gdxz0079qnn9alyk5ae4","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdz4008qqnn9pgd2poam"},{"post_id":"ck2u3gdy0007cqnn91vitcfht","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdz6008tqnn9weh2zu9d"},{"post_id":"ck2u3gdy1007fqnn9k6693jva","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzc008wqnn9katuhnq4"},{"post_id":"ck2u3gdy5007iqnn9x6gs0uwi","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdze008zqnn92dwkfwzd"},{"post_id":"ck2u3gdy8007lqnn98esbxdvc","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzf0092qnn94guzy33m"},{"post_id":"ck2u3gdya007oqnn9iaynms3u","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzh0095qnn9so6joqp4"},{"post_id":"ck2u3gdyd007rqnn9tihgrfs2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzk0098qnn960wjby1k"},{"post_id":"ck2u3gdye007uqnn9sjzimgvf","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzm009bqnn9ba8x0hx8"},{"post_id":"ck2u3gdyg007xqnn9fj4b7zmt","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzo009eqnn9teqq0fvj"},{"post_id":"ck2u3gdyj0080qnn9miotpc6c","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzp009hqnn95nxp6jr4"},{"post_id":"ck2u3gdyo0083qnn98fc9asz5","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzs009kqnn94zqrqgxs"},{"post_id":"ck2u3gdyp0086qnn9tryha59e","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzt009nqnn9o2vu3fxt"},{"post_id":"ck2u3gdyr0089qnn939pn4j1k","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzv009qqnn98sx0blbu"},{"post_id":"ck2u3gdyu008cqnn9dgb31dsc","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3gdzx009tqnn93xewv75v"},{"post_id":"ck2u3gdyw008fqnn93howmxp2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge01009wqnn9h51bqbwn"},{"post_id":"ck2u3gdyx008iqnn9uhqboo6m","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge04009zqnn9gubjrmhi"},{"post_id":"ck2u3gdyz008lqnn924uucj74","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0600a2qnn9qrjq5t92"},{"post_id":"ck2u3gdz0008oqnn9vqy4igcx","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0800a5qnn9boc5bhlb"},{"post_id":"ck2u3gdz4008rqnn91dsbegz8","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0a00a8qnn9mlsjpi2r"},{"post_id":"ck2u3gdz6008uqnn9yciubzi8","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0c00abqnn9vy5jc6a5"},{"post_id":"ck2u3gdzc008xqnn95q4udwgi","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0d00aeqnn9iymg5f9v"},{"post_id":"ck2u3gdze0090qnn9x6jod2iq","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0e00aiqnn9rpehacfi"},{"post_id":"ck2u3gdzf0093qnn93e3w5ja0","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0e00akqnn9nzgr4nwx"},{"post_id":"ck2u3gdzh0096qnn94dehcn80","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0f00amqnn91rk6w327"},{"post_id":"ck2u3gdzk0099qnn9nol0dtvb","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0f00aoqnn9zbfujlix"},{"post_id":"ck2u3gdzm009cqnn9kadgzfd2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0g00arqnn9256nvd8i"},{"post_id":"ck2u3gdzo009fqnn9o5h0trcv","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0h00atqnn9m4h73zrf"},{"post_id":"ck2u3gdzq009iqnn9ozdr4ppt","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0h00avqnn9ytbipzd2"},{"post_id":"ck2u3gdzs009lqnn90gvo1q6a","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0h00axqnn9nyms336t"},{"post_id":"ck2u3gdzu009oqnn9plvot9xy","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0h00azqnn909e6ne7z"},{"post_id":"ck2u3gdzv009rqnn92lum0cab","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0i00b1qnn9ysctlfbv"},{"post_id":"ck2u3gdzy009uqnn9nuzd4uap","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0i00b3qnn98jy837z8"},{"post_id":"ck2u3ge01009xqnn9ex7q4h1g","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0i00b5qnn9xs64xxpk"},{"post_id":"ck2u3ge0400a0qnn9u3um90h2","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0i00b7qnn9bp5ve25l"},{"post_id":"ck2u3ge0600a3qnn9j6nh3d1j","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0i00b9qnn91rzygen7"},{"post_id":"ck2u3ge0800a6qnn9lg8rdndx","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0j00bbqnn9k6ea95vg"},{"post_id":"ck2u3ge0a00a9qnn9ujsvo7hk","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge0j00bdqnn9n5rto764"},{"post_id":"ck2u3ge0c00acqnn9nmzaaty3","tag_id":"ck2u3ge0e00ahqnn97c9uzj3y","_id":"ck2u3ge0j00bfqnn9hmxuokyi"},{"post_id":"ck2u3ge1900e9qnn9xf4uzf1i","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge1c00ebqnn9damevo7a"},{"post_id":"ck2u3ge1900e9qnn9xf4uzf1i","tag_id":"ck2u3gdtn0017qnn9ugpbhdb4","_id":"ck2u3ge1h00edqnn9tnvorsk8"},{"post_id":"ck2u3ge1a00eaqnn9lh5zb61p","tag_id":"ck2u3gdu3001tqnn9e1h7zyfl","_id":"ck2u3ge1j00ehqnn91jdznev6"},{"post_id":"ck2u3ge1a00eaqnn9lh5zb61p","tag_id":"ck2u3gdu90022qnn90dauclx7","_id":"ck2u3ge1n00ekqnn9wmmvw83o"},{"post_id":"ck2u3ge1d00ecqnn9xj41epul","tag_id":"ck2u3gdtf0012qnn9srjqgahn","_id":"ck2u3ge1s00erqnn94rmue5lq"},{"post_id":"ck2u3ge1d00ecqnn9xj41epul","tag_id":"ck2u3ge1j00egqnn9usbtpliy","_id":"ck2u3ge1t00euqnn9tbs028gb"},{"post_id":"ck2u3ge1d00ecqnn9xj41epul","tag_id":"ck2u3gdtv001hqnn93o1lnha9","_id":"ck2u3ge1x00exqnn9kr0pqtfo"},{"post_id":"ck2u3ge1h00eeqnn9iaopocwj","tag_id":"ck2u3ge1r00epqnn99kgu0gp3","_id":"ck2u3ge1y00f0qnn96ji3fgvw"},{"post_id":"ck2u3ge1k00eiqnn9i76t9m93","tag_id":"ck2u3ge1u00evqnn9brziz9x2","_id":"ck2u3ge2300f7qnn9uk0n7dbr"},{"post_id":"ck2u3ge1k00eiqnn9i76t9m93","tag_id":"ck2u3ge1y00f2qnn9fn49wt50","_id":"ck2u3ge2400f9qnn9jm0yiyc3"},{"post_id":"ck2u3ge1n00elqnn94x7nuu66","tag_id":"ck2u3ge2200f5qnn9x81fn45x","_id":"ck2u3ge2500fcqnn9wzot8jdn"},{"post_id":"ck2u3ge1p00eoqnn9txxtcqtt","tag_id":"ck2u3ge1r00epqnn99kgu0gp3","_id":"ck2u3ge2500feqnn94cg9apzf"},{"post_id":"ck2u3ge2e00ffqnn9qdsxg0n5","tag_id":"ck2u3ge1r00epqnn99kgu0gp3","_id":"ck2u3ge2h00fhqnn97b45qkze"},{"post_id":"ck2u3ge2f00fgqnn9i19lnrmk","tag_id":"ck2u3gdut0031qnn9itzb9wvh","_id":"ck2u3ge2k00fjqnn9b0anvl84"},{"post_id":"ck2u3ge2h00fiqnn9oha1f06n","tag_id":"ck2u3ge2k00flqnn9ivlansrw","_id":"ck2u3ge2n00fsqnn94ic1019q"},{"post_id":"ck2u3ge2h00fiqnn9oha1f06n","tag_id":"ck2u3ge2m00foqnn98vwm88s1","_id":"ck2u3ge2n00ftqnn9bbsbl9x0"},{"post_id":"ck2u3ge2p00fuqnn9nwhgy0ef","tag_id":"ck2u3ge2200f5qnn9x81fn45x","_id":"ck2u3ge2r00fvqnn943pjf5q1"}],"Tag":[{"name":"android","_id":"ck2u3gdr20005qnn98zsv4dvq"},{"name":"automation","_id":"ck2u3gdr70009qnn9zz8ucnzm"},{"name":"tool","_id":"ck2u3gdra000dqnn91zf3j7o9"},{"name":"jenkins","_id":"ck2u3gdrg000gqnn9t4xjp9lp"},{"name":"testlink","_id":"ck2u3gdrg000kqnn9l9426hrh"},{"name":"plugin","_id":"ck2u3gdrh000mqnn9kpgbe3cr"},{"name":"vscode","_id":"ck2u3gdrh000nqnn9kl3ulzk4"},{"name":"tools","_id":"ck2u3gdsc000wqnn9tp9rrw50"},{"name":"algorithm","_id":"ck2u3gdtf0012qnn9srjqgahn"},{"name":"tree","_id":"ck2u3gdtn0017qnn9ugpbhdb4"},{"name":"array","_id":"ck2u3gdtv001hqnn93o1lnha9"},{"name":"graph","_id":"ck2u3gdu3001tqnn9e1h7zyfl"},{"name":"topological-sort","_id":"ck2u3gdu90022qnn90dauclx7"},{"name":"search","_id":"ck2u3gduc002bqnn9yri7zys6"},{"name":"queue","_id":"ck2u3gduj002jqnn9u4y25ukh"},{"name":"stack","_id":"ck2u3gduo002sqnn9xm2bd5cx"},{"name":"linked-list","_id":"ck2u3gdut0031qnn9itzb9wvh"},{"name":"string","_id":"ck2u3gdv4003aqnn9wxijve5q"},{"name":"binary-tree","_id":"ck2u3gdva003iqnn9qs2j2q24"},{"name":"jvm","_id":"ck2u3ge0e00ahqnn97c9uzj3y"},{"name":"linear-list","_id":"ck2u3ge1j00egqnn9usbtpliy"},{"name":"interview-questions","_id":"ck2u3ge1r00epqnn99kgu0gp3"},{"name":"multithread","_id":"ck2u3ge1u00evqnn9brziz9x2"},{"name":"interview","_id":"ck2u3ge1y00f2qnn9fn49wt50"},{"name":"array-list","_id":"ck2u3ge2200f5qnn9x81fn45x"},{"name":"map","_id":"ck2u3ge2k00flqnn9ivlansrw"},{"name":"hashmap","_id":"ck2u3ge2m00foqnn98vwm88s1"}]}}